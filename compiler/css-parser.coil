export protocol matches?

def String:prototype.matches?(str)
  if str:startsWith(this)
    return {result: this, skip: this.len()}
  else
    return false
  end
end

def RegExp:prototype.matches?(str)
  let result = str:match(this)
  if result.nil?() or result:index != 0
    return false
  else
    return {result: result.0, skip: result.0.:length}
  end
end

export def Parser(...@steps) end
def Parser:prototype.invoke([_ str]) =
  this:steps.reduce(|[result str] parser| parser([result str]), [nil str])

export def Init(@state) end
def Init:prototype.invoke([_ str]) = [this:state str]

export def Then(@parser @property) end
def Then:prototype.invoke([state str]) = this:parser([state str])
  .pipe(|[result str]| [{...state this:property => result} str])

export def Skip(@pattern) end
def Skip:prototype.invoke([state str])
  if let {result skip} = this:pattern.matches?(str)
    return [state str:slice(skip)]
  else
    this.log({state: state, str: str}) Error[]:stack.log() panic!()
  end
end

export def Store(@pattern @property) end
def Store:prototype.invoke([state str])
  if let {result skip} = this:pattern.matches?(str)
    return [{...state this:property => result} str:slice(skip)]
  else
    this.log() Error[]:stack.log() panic!()
  end
end

def Until(@pattern @parser @property) end
def Until:prototype.invoke([state str])
  let nodes = []
  while !this:pattern.matches?(str)
    let [result rest_str] = this:parser([nil str])
    nodes:push(result)
    str = rest_str
  end
  return [{...state this:property => nodes} str]
end

def ParseMap(@entries) end
def ParseMap:prototype.invoke([state str])
  if let [_ parser] = this:entries.find(|[pattern _]| pattern.matches?(str))
    return parser([state str])
  else
    this.log([state str])
    panic!("ParseMap failed!")
  end
end

def Trim end
def Trim.invoke([state str]) = [state str:trimLeft()]

def Debug(@msg) end
def Debug:prototype.invoke([state str]) = [state str].log(this:msg)

let parse_class_selector = Parser[
  Init[{kind: :class_selector}]
  Skip["."]
  Store[/^\w+/ :name]
]

let parse_selector_arg = Parser[
  Init[{kind: :selector_arg}]
  Trim Store[/^\w+/ :arg] Trim
]

let parse_pseudo_selector_with_args = Parser[
  Init[{kind: :pseudo_selector_with_args}]
  Skip[":"]
  Store[/^(\w|-)+/ :name]
  Skip["("]
  Trim Until[")" parse_selector_arg :args]
  Trim Skip[")"]
]

let parse_pseudo_selector_without_args = Parser[
  Init[{kind: :pseudo_selector_without_args}]
  Skip[":"]
  Store[/^(\w|-)+/ :name]
]

let parse_query = ParseMap{
  "." => parse_class_selector
  /^:(\w|-)+\(/ => parse_pseudo_selector_with_args
  ":" => parse_pseudo_selector_without_args
}

let parse_px_value = Parser[
  Init[{kind: :px_value}]
  Store[/^\d+/ :value]
  Skip["px"]
]

let parse_pct_value = Parser[
  Init[{kind: :pct_value}]
  Store[/^\d+/ :value]
  Skip["%"]
]

let parse_value = ParseMap{
  /^\d+px/ => parse_px_value
  /^\d+%/ => parse_pct_value
}

let parse_rule = Parser[
  Init[{kind: :rule}]
  Trim Store[/^\w+/ :name]
  Debug["rule"]
  Trim Skip[":"]
  Trim Then[parse_value :value]
  Trim Skip[";"]
]

let parse_declaration = Parser[
  Init[{kind: :declaration}]
  Trim Then[parse_query :query]
  Trim Skip["{"]
  Until[/\s*}/ parse_rule :rules]
  Trim Skip["}"]
]

let program = "
:nth-child(odd) {
  
}
"

parse_declaration([nil program]).0.log()
