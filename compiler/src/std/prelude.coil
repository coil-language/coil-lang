protocol Meta
impl Meta for Object = {
  ["[]"]: fn (...keys) = keys::reduce(js_dynamic_object_lookup this)
  ["[]="]: fn (keys, expr) = js_set_property(this, keys, expr)
}
impl Meta for Function = {
  ["[]"]: fn (...args) = Reflect.construct(this args)
  ["{}"]: fn (entries) = Reflect.construct(this [entries])
}
define Meta for Set = {
  ["[]"]: fn (...elems) = new Set(elems)
}

fn def_global(f) {
  let resolved_name = f.name
    .replaceAll("?", "__q")
    .replaceAll("!", "__b")
    .replaceAll(">", "_lt_")
    .replaceAll("-", "_")
  globalThis.[resolved_name] = f
  return f
}

protocol CustomNumberLiteral
globalThis.CustomNumberLiteral = CustomNumberLiteral

define CustomNumberLiteral for :custom_number_literal/n = BigInt

// Doc Protocol

protocol Doc
globalThis.Doc = Doc

@def_global
fn doc(f, doc_str) {
  define Doc for f = doc_str.trim()
  return f
}

@def_global
fn log_doc() {
  if this.name {
    console.log(str("# " this.name))
  }  
  console.log(this.[Doc])
  return this
}

protocol Call
globalThis.Call = Call

// can't use decorators, ::call, or ::reduce since its being depended on everywhere
fn compose(first_fn, ...fns) = fn(...args) {
  let result = first_fn&.[Call](...args)
  for f of fns {
    result = f&.[Call](result)
  }
  return result
}

compose = def_global(compose)
compose = doc(compose "
composes a list of [[Call]] objects into a single function

example:
  compose(:users 0 :id)({users: [{id: 123}]}) // -> 123 
")

impl Call for Function = fn(...args) = this(...args)
impl Call for Set = fn(key) = this.has(key)
impl Call for Map = fn(key) = this.get(key)
impl Call for ObjectLiteral = fn(key) = this.[key]
impl Call for Array = fn(index) = this.at(index)
impl Call for String = fn(collection) {
  if typeof(collection) === "string" || collection is Keyword {
    raise!(new TypeError("Can't 'call' a string with " + collection::as_str()))
  } else {
    return collection::call(this)
  }
}
impl Call for Number = fn(collection) {
  if collection is Keyword {
    // this feels wrong
    return this[collection]
  } else {
    return collection::call(this)
  }
}
impl Call for Keyword = fn(collection) {
  if collection is Keyword || typeof(collection) === "string" {
    raise!(new TypeError("Can't 'call' a keyword with" + collection::as_str()))
  } else if Call keyof collection {
    return collection::call(this)
  } else {
    // hmm? what is an example of this occurring?
    return collection[this]
  }
}

@[def_global doc("
Invokes [[Call]] on 'this'


Usage:
- On Object Literals
  {a: 10}::call(:a) // 10
")]
fn call(...args) = this&.[Call](...args)

// make sets callable using bind syntax
impl :bind for Set = fn(val) = ::fn() = this::call(val)

let nil? = Object.freeze(Set[undefined null])

protocol Pipe
globalThis.Pipe = Pipe

impl Pipe for Object = fn(callable) = callable::call(this)

@[def_global doc("
invokes [[Pipe]] protocol

args:
  ...callables: list of [[Call]] objects

returns:
  result of invoking 'callables' on this

nil handling:
  since nil doesn't impl Pipe, we'll call 'f' directly.

note on [[Pipe]]:
  pipe is protocol based so that it can be used with Underscore among other objects.
")]
fn pipe(...callables) {
  let f = compose(...callables)
  if ::nil?() {
    return f(this)
  } else {
    return this&.[Pipe](f)
  }
}

@[def_global doc("
decorator to define [[Call]]

takes f, and applies first argument as the 'this' arg.

this is helpful when you are writing functions that rely on 'this'
and don't have any arguments.

example:
  fn first() = this[0]

  // I want this to work.. but it doesn't
  [[1] [2] [3]]::map(first) // Error

  // if I use @def_call we can do this
  @def_call
  fn first() = this[0]

  [[1] [2] [3]]::map(first) // [1 2 3]  
")]
fn def_call(f) {
  define Call for f = fn(first, ...rest) = first::f(...rest)
  return f
}

// Iterable Protocol

@[def_call doc("
Returns an iterator of 'this'.

In the case 'this' is nil, you will get an empty array iterator.
")]
fn iter() = this&.[Symbol.iterator]() ?? []::iter()

@[def_call doc("
Determines if 'this' is a valid Symbol.iterator

See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol for more
")]
fn iter?() = ::iter() === this

protocol Iterator
globalThis.Iterator = Iterator

let default_iterator_impl = {
  fn* take(n) {
    for [elem i] of this::zip(0..) {
      if i == n {
        break
      } else {
        yield elem
      }
    }
  }
  fn* until(f) {
    for elem of this {
      if f(elem) {
        break
      } else {
        yield elem
      }
    }
  }
  fn* skip(n) {
    for [elem i] of this::zip(0..) {
      if i < n {
        continue
      } else {
        yield elem
      }
    }
  }
  fn find(f) {
    for elem of this {
      if f(elem) {
        return elem
      }
    }
  }
  fn* zip(...collections) {
    let generators = [this, ...collections]::map(iter)::into([])
    loop {
      let gen_states = generators::map(#(&.next()))::into([])
      if gen_states::any?(:done) {
        break
      } else {
        yield gen_states::map(:value)::into([])
      }
    }
  }
  fn reduce(f, start) {
    let acc = start
    for elem of this {
      acc = f(acc, elem)
    }
    return acc
  }
  fn* map(f) {
    for elem of this {
      yield f(elem)
    }
  }
  fn* flat_map(f) {
    for elem of this {
      yield* f(elem)
    }
  }
  fn each(f) {
    for elem of this {
      f(elem)
    }
  }
  fn* keep(f) {
    for elem of this {
      if f(elem) {
        yield elem
      }
    }
  }
  fn all?(f) {
    for elem of this {
      if !f(elem) {
        return false
      }
    }
    return true
  }
  fn any?(f) {
    for elem of this {
      if f(elem) {
        return true
      }
    }
    return false
  }
  fn* split(f) {
    let chunk = []
    for elem of this {
      if f(elem) {
        yield chunk
        chunk = []
      } else {
        chunk = chunk::push(elem)
      }
    }
    yield chunk
  }
  fn* compact() {
    for elem of this {
      if elem::nil?() {
        continue
      } else {
        yield elem
      }
    }
  }
}

fn iterator_impl() = this&.[Iterator] || default_iterator_impl

@[def_global doc("
lazily skips 'n' elements for an iterator

Examples:
  [1 2 3 4 5]::skip(1)::into([]) // -> [2 3 4 5]
  [1 2 3]::skip(20)::into([]) // -> []
")]
fn skip(n) = ::iterator_impl().skip.call(this::iter(), n)

@[def_global doc("
lazily takes 'n' elements for an iterator

Examples:
  [1 2 3 4]::take(2)::into([]) // -> [1 2]
  [1 2 3]::take(200)::into([]) // -> [1 2 3]
")]
fn take(n) = ::iterator_impl().take.call(this::iter(), n)

@[def_global doc("
eagerly consumes an iterator by calling 'f' on each elem

Examples:
  [{name: \"bob\"} {name: \"jill\"}]
    ::each(:name log) // prints 'bob' and 'jill'
")]
fn each(...fns) = ::iterator_impl().each.call(this::iter(), compose(...fns))

@[def_global doc("
lazily defines an end point for an iterator

Examples:
  [1 2 3 4 5 6 7]
    ::until(_ > 3)
    ::into([]) // [1 2 3]
")]
fn until(...fns) = ::iterator_impl().until.call(this::iter(), compose(...fns))

@[def_global doc("
lazily zips together a number of iterators

Examples:
  [:axe :hammer :pickaxe]
    ::zip([3 1 4])
    ::into(~Map{})
  // -> ~Map{axe: 3, hammer: 1, pickaxe: 4}
")]
fn zip(...iterables) = ::iterator_impl().zip.call(this::iter(), ...iterables)

@[def_global doc("
lazily maps functions over an iterator

Examples:
  [{name: \"marcelle\"}, {name: \"jack\"}]
    ::map(:name len)
    ::into([]) // [8 4]
")]
fn map(...fns) = ::iterator_impl().map.call(this::iter(), compose(...fns))

@[def_global doc("
lazily flat maps functions over an iterator

Examples:
  [[1 5] [6 10]]
    ::flat_map(fn([start, end]) = (start..=end)::into([]))
    ::into([]) // [1 2 3 4 5 6 7 8 9 10]
")]
fn flat_map(...fns) = ::iterator_impl().flat_map.call(this::iter(), compose(...fns))

@[def_global doc("
eagerly finds a value in an iterator

Examples:
  [1 2 3 4 5]
    ::find(Set[4 5]) // 4
")]
fn find(...fns) = ::iterator_impl().find.call(this::iter(), compose(...fns))

@[def_global doc("
lazily keeps values based off a condition

Examples:
  [{admin: true, name: \"bob\"} {admin: false, name: \"jill\"}]
    ::keep(:admin)
    ::into([]) // [{admin: true, name: \"bob\"}]
")]
fn keep(...fns) = ::iterator_impl().keep.call(this::iter(), compose(...fns))

@[def_global doc("
lazily rejects values based of a condition

Examples:
  [{admin: true, name: \"bob\"} {admin: false, name: \"jill\"}]
    ::reject(:admin)
    ::into([]) // [{admin: false, name: \"jill\"}]
")]
fn reject(...fns) = ::keep(...fns, !_)

@[def_global doc("
eagerly finds out if an element matches the condition

Examples:
  [1 2 3 4 5]::any?(Set[3]) // true
")]
fn any?(...fns) = ::iterator_impl().any?.call(this::iter(), compose(...fns))

@[def_global doc("
eagerly finds out all elements matches the condition

Examples:
  [1 2 3 4 5]::all?(_ > 0) // true
")]
fn all?(...fns) = ::iterator_impl().all?.call(this::iter(), compose(...fns))

@[def_global doc("
eagerly reduces an iterator

Examples:
  [1 2 3 4 5]::reduce(+ 0) // 15
")]
fn reduce(f, start) = ::iterator_impl().reduce.call(this::iter(), f::call, start)

@[def_global doc("
lazily splits an iterator

Examples:
  \"hey there buddy\"
    ::split(Set[" "])
    ::take(2)
    ::into([]) // [\"hey\" \"there\"]
")]
fn split(...fns) = ::iterator_impl().split.call(this::iter(), compose(...fns))

@[def_global doc("
lazily compacts an iterator

Examples:
  [{status: :great} {status: :broken} {}]
    ::map(:status)
    ::compact()
    ::into([]) // [:great :broken]
")]
fn compact() = ::iterator_impl().compact.call(this::iter())

@[def_global doc("
eagerly joins an iterator

Examples:
  [\"hey\" \"there\"]
    ::join(\" \") // \"hey there\"
")]
fn join(sep) = ::reduce(fn(prev cur) {
  if prev::empty?() {
    return cur
  } else {
    return prev + sep + cur
  }
} "")

// INTO

protocol Into
globalThis.Into = Into

impl Into for Array = fn(iterable) = [...this, ...iterable]
impl Into for ObjectLiteral = fn(iterable) = ::merge(iterable)
impl Into for Map = fn(iterable) = ::merge(iterable)
impl Into for Set = fn(iterable) = ::concat(iterable)
impl Into for String = fn(iterable) = this + iterable::reduce(+ "")
define Into for Object = fn(iterable) = Object.fromEntries(iterable)

@[def_global doc("
converts 'this' iterator into 'output', prepending existing values in 'output'

Examples:
  [1 2 3 4]
    ::into(Set[]) // Set[1 2 3 4]

  [[:score 10] [:grade :bad]]
    ::into({}) // {score: 20, grade: :bad}
")]
fn into(output) = output[Into](this)

protocol Collection
globalThis.Collection = Collection

impl Collection for ObjectLiteral = {
  fn at(key) = this.[key]
  fn len() = Object.keys(this).length
  fn empty?() = this::len() === 0
  fn has?(key) = key keyof this
}

impl Collection for Array = {
  fn at(idx) = this.at(idx)
  fn len() = this.length
  fn empty?() = this.length === 0
  fn has?(val) = ::any?(_ == val)
}

impl Collection for Map = {
  fn at(key) = this.get(key)
  fn len() = this.size
  fn empty?() = this.size === 0
  fn has?(key) = this.has(key)
}

impl Collection for String = {
  fn at(idx) = this.at(idx)
  fn len() = this.length
  fn empty?() = this.length === 0
  fn has?(substr) = this.includes(substr)
}

impl Collection for Set = {
  fn at(val) = this.has(val) && val
  fn len() = this.size
  fn empty?() = this.size === 0
  fn has?(val) = this.has(val)
}

@[def_call def_global doc("
gets length of a collection

Examples:
  [1 2 3]::len() // 3
  Set[1 2 3]::len() // 3
  {a: 10}::len() // 1
  ~Map{a: :a, b: :b}::len() // 2
")]
fn len() = this.[Collection].len.call(this)

@[def_call def_global doc("
determines if a collection is empty

Examples:
  []::empty?() // true
  Set[1]::empty?() // false
  null::empty?() // true
  ""::empty?() // true
")]
fn empty?() = this&.[Collection].empty?.call(this) ?? true

@[def_call def_global doc("
determines if a collection is not empty

Examples:
  [1]::not_empty?() // true
  ""::not_empty?() // false
  null::not_empty?() // false
")]
fn not_empty?() = !this::empty?()

@[def_global doc("
extracts value from collection based on a key or index

Examples:
  [1 3 4]::at(2) // 4
  // set::at works as an identity function if the value is in the set
  Set[4 3 1]::at(4) // 4
  // keywords coerce to strings for objects
  {a: 10}::at(:a) // 10
  {a: 10}::at(\"a\") // 10
  ~Map{a: 10}::at(:a) // 10
  // strings can not lookup keywords in maps
  ~Map{a: 10}::at(\"a\") // undefined
")]
fn at(key_or_idx) = this.[Collection].at.call(this, key_or_idx)

@[def_global doc("
determines if a collection has a value

Examples:
  [1 2 3 4]::has?(3) // true
  Set[1 2 3]::has?(2) // true
  {a: 10}::has?(:a) // true
")]
fn has?(val) = this.[Collection].has?.call(this, val)

protocol Record
globalThis.Record = Record

impl Record for ObjectLiteral = {
  fn insert(key, value) = {...this, [key]: value}
  fn merge(other) = ObjectLiteral.from_entries([...this, ...other])
  fn keys() = Object.keys(this)
  fn values() = Object.values(this)
}

impl Record for Map = {
  fn insert(key, value) = new Map([...this, [key, value]])
  fn merge(other) = new Map([...this, ...other])
  fn keys() = this.keys()
  fn values() = this.values()
}

@[def_call def_global doc("
Get keys of a record as an iterator OR a collection

Example:
  {a: 10}::keys() // [\"a\"]
  Map{a: 10}::keys()::into(Set[]) // Set[:a]
")]
fn keys() = this.[Record].keys.call(this)

@[def_call def_global doc("
Get values of a record as an iterator OR a collection

Example:
  {a: 10}::values() // [10]
  ~Map{a: 10}::values()::into(Set[]) // Set[10]
")]
fn values() = this.[Record].values.call(this)

@[def_global doc("
Insert key & value into a record

Example:
  {a: 10}::insert(:b 20) // {a: 10, b: 20}
  ~Map{a: 10}::insert(:b 20) // ~Map{a: 10, b: 20}
")]
fn insert(key, value) = this.[Record].insert.call(this, key, value)

@[def_global doc("
Merge 2 records together

Note that since all object literal keys are strings, merging a
richer record that can hold keywords may have unexpected consequences

Do not merge a rich record type with a non rich record unless you are ok
with lossy conversions.

Example:
  {a: 10}::merge({b: 20}) {a: 10 b: 20}
  {a: 10}::merge({a: 20})
  ~Map{a: 10}::merge(~Map{a: 20}) // ~Map{a: 20}
  // here's the unexpected result
  ~Map{a: 10}::merge({a: 20}) // ~Map{a: 10, \"a\" => 20}
")]
fn merge(other) = this.[Record].merge.call(this, other)

// phase these out
define Record for Map = fn(entries) = new Map(entries)
define Record for Object = Object.fromEntries

@[def_global doc("
Determines if 'this' is a record

Examples:
  {}::record?() // true
  Map{}::record?() // true
  Set[]::record?() // false
")]
fn record?() = this.[Record]::exists?()

@[def_global doc("
Constructs a record based off an entries array

This is used for record syntax

Examples:
  Map::construct_record([[:a 20]])
    ==
  ~Map{a: 20}
")]
fn construct_record(entries) = this.[Record](entries)

// TODO: this should be called Sequence or something
protocol Vector
globalThis.Vector = Vector

@[def_global doc("
Determines if 'this' conforms to the vector protocol

Examples:
  []::vector?() // true
  Set[]::vector?() // true
  {}::vector?() // false
")]
fn vector?() = this.[Vector]::exists?()

impl Vector for Array = {
  fn push(val) = [...this, val]
  fn replace(old_val, new_val) = ::map(fn(val) {
    if val == old_val {
      return new_val
    } else {
      return val
    }
  })
  fn concat(other) = [...this, ...other]
}

impl Vector for Set = {
  fn push(value) = new Set(this).add(value)
  fn replace(old_val, new_val) {
    let self = new Set(this)
    self.delete(old_value)
    self.add(new_val)
    return self
  }
  fn concat(other) = new Set([...this, ...other])
}

impl Vector for String = {
  fn push(val) = this + val
  fn replace(old_substr, new_substr) = this.replaceAll(old_substr, new_substr)
  fn concat(other) = this + other
}

@[def_global doc("
push a value onto a vector

Examples:
  [1 2]::push(3) // [1 2 3]
  // order is not guaranteed for sets
  Set[1 2]::push(3) // Set[3 1 2]
")]
fn push(val) = this.[Vector].push.call(this, val)

@[def_global doc("
replace a value in a vector

Examples:
  [1 2 3]::replace(2 3) // [1 3 3]
  Set[1 2 3]::replace(2 3) // Set[1 3]
")]
fn replace(old_val, new_val) = this.[Vector].replace.call(this, old_val, new_val)

@[def_global doc("
concat two vectors

Examples:
  [1 2]::concat([3 4]) // [1 2 3 4]
  [1 2]::concat(Set[3 4]) // [1 2 4 3] - set order unknowable
  Set[1 2]::concat([3 4]) // Set[1 2 3 4]
  Set[1 2]::concat(Set[2 3]) // Set[1 2 3]
")]
fn concat(other) = this.[Vector].concat.call(this, other)

protocol OrderedSequence
globalThis.OrderedSequence = OrderedSequence

impl OrderedSequence for Array = {
  fn prepend(val) = [val, ...this]
  fn update_at(idx, f) {
    let [before after] = [this::take(idx) this::skip(idx + 1)]
    return [...before, f(::at(idx)), ...after]
  }
  fn insert_at(idx, val) {
    let [before after] = [this::take(idx) this::skip(idx + 1)]
    return [...before, val, ...after]
  }
  fn first() = this.[0]
  fn last() = this.at(-1)
}

impl OrderedSequence for String = {
  fn prepend(val) = val + this
  fn update_at(idx, f) = this.slice(0, idx) + f(this.at(idx)) + this.slice(idx)
  fn insert_at(idx, val) = this.slice(0, idx) + val + this.slice(idx)
  fn first() = this.[0]
  fn last() = this.at(-1)
}

@[def_global doc("
inserts element at beginning of collection

Examples:
  [1 2 3]::prepend(0) // [0 1 2 3]
")]
fn prepend(val) = this.[OrderedSequence].prepend.call(this, val)

@[def_global doc("
updates element at given index

Examples:
  [1 2 3]::update_at(1 as_keyword) // [1 :2 3]
")]
fn update_at(idx, ...fns) = this.[OrderedSequence].update_at.call(this, idx, compose(...fns))

@[def_global doc("
inserts element at given index

Examples:
  [1 2 4]::insert_at(1 3) // [1 2 3 4]
")]
fn insert_at(idx, val) = this.[OrderedSequence].insert_at.call(this, idx, val)

@[def_call def_global doc("
gets first element of collection

Examples:
  [1 2 3]::first() // 1
")]
fn first() = this.[OrderedSequence].first.call(this)

@[def_call def_global doc("
gets last element of collection

Examples:
  [1 2 3]::last() // 3
")]
fn last() = this.[OrderedSequence].last.call(this)

@[def_global doc("
constructs vector based off entries

this is used for custom vector syntax

Examples:
  import { List } from \"immutable\"

  List::constructor_vector([1 2 3 4])
    ==
  ~List[1 2 3 4]
")]
fn construct_vector(entries) = this.[Vector](entries)

// EQUAL PROTOCOl

protocol Equal
globalThis.Equal = Equal

@[def_global doc("
implement [[Equal]] for a generic constructor by
specifying the keys to measure equality by

Examples:
  fn Dog(@name, @age) {}

  new Dog(\"joey\" 1) == new Dog(\"joey\" 1) // false

  @impl_equal(:name :age)
  fn Dog(@name @age) {}

  new Dog(\"joey\" 1) == new Dog(\"joey\" 1) // true
")]
fn impl_equal(Ctor, ...keys) {
  impl Equal for Ctor = fn(other) =
    other is Ctor && keys::all?(::fn(key) = this.[key] == other.[key])
  return Ctor
}

impl Equal for Object = fn(other) = this === other

impl Equal for Set = fn(other) {
  if !(other is Set) {
    return false
  } else if other.size !== this.size {
    return false
  } else {
    return ::all?(fn(val) = other.has(val))
  }
}

impl Equal for Array = fn(other) {
  if !(other is Array) {
    return false
  } else if other.length !== this.length {
    return false
  } else {
    return ::zip(other)::all?(fn([a, b]) = a == b)
  }
}

@doc("determine if 2 records of any kind are equal")
fn record_equals?(other) {
  if this.constructor !== other.constructor {
    return false
  } else if this::len() != other::len() {
    return false
  } else {
    return this::all?(fn([key, value]) = other::at(key) == value)
  }
}

impl Equal for Map = record_equals?

impl Equal for ObjectLiteral = record_equals?

@[def_call def_global doc("
[[Equal]] invocation

Examples:
  1::equals?(1) // true
  // is the same as
  1 == 1 // true
")]
fn equals?(other) = this&.[Equal](other) ?? this === other

// OPERATORS

protocol Plus
globalThis.Plus = Plus
protocol Negate
globalThis.Negate = Negate
protocol Minus
globalThis.Minus = Minus
protocol Times
globalThis.Times = Times
protocol Divide
globalThis.Divide = Divide
protocol Exponent
globalThis.Exponent = Exponent
protocol Mod
globalThis.Mod = Mod
protocol Comparable
globalThis.Comparable = Comparable
protocol LessThan
globalThis.LessThan = LessThan
protocol And
globalThis.And = And
protocol Or
globalThis.Or = Or

@doc("raise! if 'this' isn't a 'type_str'")
fn expect_primitive_type!(type_str) {
  if typeof(this) !== type_str {
    raise!(new Error(str("Expected " type_str)))
  }
}

impl Negate for Object = fn() = js_negate(this)
impl And for Object = fn(thunk) = js_and(this, thunk)
impl Or for Object = fn(thunk) = js_or(this, thunk)
impl Plus for Set = fn(other_set) = this::concat(other_set)
impl Plus for Array = fn(arr) = this::concat(arr)
impl Plus for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_plus(this, other)
}
impl Minus for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_minus(this, other)
}
impl Times for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_times(this, other)
}
impl Divide for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_divide(this, other)
}
impl Exponent for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_exponent(this, other)
}
impl Mod for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_mod(this, other)
}
impl Plus for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_plus(this, other)
}
impl Minus for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_minus(this, other)
}
impl Times for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_times(this, other)
}
impl Divide for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_divide(this, other)
}
impl Exponent for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_exponent(this, other)
}
impl Mod for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_mod(this, other)
}
impl Comparable for Number = {
  fn greater_than_eq(other) {
    other::expect_primitive_type!("number")
    return js_greater_than_eq(this, other)
  }
  fn less_than_eq(other) {
    other::expect_primitive_type!("number")
    return js_less_than_eq(this, other)
  }
  fn greater_than(other) {
    other::expect_primitive_type!("number")
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    other::expect_primitive_type!("number")
    return js_less_than(this, other)
  }
}
impl Comparable for BigInt = {
  fn greater_than_eq(other) {
    other::expect_primitive_type!("bigint")
    return js_greater_than_eq(this, other)
  }
  fn less_than_eq(other) {
    other::expect_primitive_type!("bigint")
    return js_less_than_eq(this, other)
  }
  fn greater_than(other) {
    other::expect_primitive_type!("bigint")
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    other::expect_primitive_type!("bigint")
    return js_less_than(this, other)
  }
}
impl Plus for String = fn(other) {
  other::expect_primitive_type!("string")
  return js_plus(this, other)
}
impl Times for String = fn(amount) {
  amount::expect_primitive_type!("number")
  return this.repeat(amount)
}
impl Comparable for String = {
  fn greater_than_eq(other) {
    other::expect_primitive_type!("string")
    return js_greater_than_eq(this, other)
  }
  fn less_than_eq(other) {
    other::expect_primitive_type!("string")
    return js_less_than_eq(this, other)
  }
  fn greater_than(other) {
    other::expect_primitive_type!("string")
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    other::expect_primitive_type!("string")
    return js_less_than(this, other)
  }
}

@[def_call def_global doc("
[[Plus]] method for '+' infix operator

Examples:
  1::plus(2) == 1 + 2
")]
fn plus(other) = this.[Plus](other)

@[def_call def_global doc("
[[Negate]] method for '!' prefix operator

Examples:
  !true == true::negate()
")]
fn negate() = this&.[Negate]() ?? true

@[def_global doc("
[[Minus]] method for '-' infix operator

Examples:
  1::minus(2) == 1 - 2
")]
fn minus(other) = this.[Minus](other)

@[def_global doc("
[[Times]] method for '*' infix operator

Examples:
  2::times(3) == 2 * 3
")]
fn times(other) = this.[Times](other)

@[def_global doc("
[[Divide]] method for '/' infix operator

Examples:
  2::divide_by(3) == 2 / 3
")]
fn divide_by(other) = this.[Divide](other)

@[def_global doc("
[[Exponent]] method for '**' infix operator

Examples:
  2::exponent(3) == 2 ** 3
")]
fn exponent(other) = this.[Exponent](other)

@[def_global doc("
[[Mod]] method for '%' infix operator

Examples:
  11::mod(2) == 11 % 2
")]
fn mod(other) = this.[Mod](other)

@[def_global doc("
[[Comparable]].greater_than method for '>' infix operator

Examples:
  2::greater_than(1) == 2 > 1
")]
fn greater_than(other) = this.[Comparable].greater_than.call(this, other)

@[def_global doc("
[[Comparable]].greater_than_eq method for '>=' infix operator

Examples:
  2::greater_than_eq(2) == 2 >= 2
")]
fn greater_than_eq(other) = this.[Comparable].greater_than_eq.call(this, other)

@[def_global doc("
[[Comparable]].less_than method for '<' infix operator

Examples:
  2::less_than(3) == 2 < 3
")]
fn less_than(other) = this.[Comparable].less_than.call(this, other)

@[def_global doc("
[[Comparable]].less_than_eq method for '<=' infix operator

Examples:
  2::less_than_eq(2) == 2 <= 3
")]
fn less_than_eq(other) = this.[Comparable].less_than_eq.call(this, other)

@[def_global doc("
[[And]] method for '&&' infix operator

Examples:
  true::and(fn = :val) == true && :val
")]
fn and(thunk) = this&.[And](thunk)

@[def_global doc("
[[Or]] method for '||' infix operator

Examples:
  false::or(fn = :val) == false || :val
")]
fn or(thunk) = this&.[Or](thunk) ?? thunk()

@[def_global def_call]
fn log(...args) {
  console.log(...args, this)
  return this
}

// Global Helpers

@def_global
fn str(...args) = args.join("")

@[def_global def_call]
fn nan?() = Number.isNaN(this)

@[def_global def_call]
fn num?() = typeof(this) == "number"

@[def_global def_call]
fn bigint?() = typeof(this) == "bigint"

@[def_global def_call]
fn str?() = typeof(this) == "string"

@[def_global def_call]
fn as_keyword() = Keyword.["for"](this.toString())

@[def_global def_call]
fn as_num() = Number(this)

@[def_global def_call]
fn as_str() = this&.toString() ?? ""

@[def_global def_call]
fn exists?() = !this::nil?()

// Underscore

@def_global
fn Underscore(@transforms) {}

protocol UnderscoreInterpreter
globalThis.UnderscoreInterpreter = UnderscoreInterpreter

let _ = new Underscore([{f: fn id() = this, args: []}])
globalThis._ = _

impl :insert for Underscore = fn(f, ...args) =
  new Underscore(this.transforms::push({f, args}))

impl UnderscoreInterpreter for Object = fn(underscore) {
  let initial_value = this
  let result = initial_value
  for {f args} of underscore.transforms {
    result = result::f::call(...args)
    // this may not always be true, but this handles And, and Or
    if result is Underscore {
      // we could do something like f[UnderscoreInterpreter]::call(result, initial_value)
      // but I'm not 100% sure
      result = result::call(initial_value)
    }
  }
  return result
}

impl Call for Underscore = fn(data, ...args) {
  if data::nil?() {
    return js_lookup_property_key(Object, UnderscoreInterpreter).call(data, this, ...args)
  } else {
    return data.[UnderscoreInterpreter](this, ...args)
  }
}

impl Comparable for Underscore = {
  fn less_than(val) = this.insert(less_than, val)
  fn greater_than(val) = this.insert(greater_than, val)
  fn less_than_eq(val) = this.insert(less_than_eq, val)
  fn greater_than_eq(val) = this.insert(greater_than_eq, val)
}

impl Negate for Underscore = fn() = this.insert(negate)
impl Equal for Underscore = fn(other) = this.insert(equals?, other)
impl Collection for Underscore = {
  fn at(key) = this.insert(at, key)
  fn has?(k) = this.insert(has?, k)
  fn len() = this.insert(len)
  fn empty?() = this.insert(empty?)
}
impl Record for Underscore = {
  fn insert(key, value) = this.insert(insert, key, value)
  fn merge(other) = this.insert(merge, other)
  fn keys() = this.insert(keys)
  fn values() = this.insert(values)
}
impl OrderedSequence for Underscore = {
  fn prepend(value) = this.insert(prepend, value)
  fn update_at(idx, callable) = this.insert(update_at, idx, callable)
  fn insert_at(idx, val) = this.insert(insert_at, idx, val)
  fn first() = this.insert(first)
  fn last() = this.insert(last)
}
impl Vector for Underscore = {
  fn push(value) = this.insert(push, value)
  fn replace(old_value, new_value) = this.insert(has?, old_value, new_value)
  fn concat(other) = this.insert(concat, other)
}
impl Pipe for Underscore = fn(f) = this.insert(pipe, f)
impl And for Underscore = fn(thunk) = this.insert(and, thunk)
impl Or for Underscore = fn(thunk) = this.insert(or, thunk)
impl Plus for Underscore = fn(other) = this.insert(plus, other)
impl Minus for Underscore = fn(other) = this.insert(minus, other)
impl Times for Underscore = fn(other) = this.insert(times, other)
impl Divide for Underscore = fn(other) = this.insert(divide_by, other)
impl Exponent for Underscore = fn(other) = this.insert(exponent, other)
impl Mod for Underscore = fn(other) = this.insert(mod, other)

// Ranges

protocol Inc
globalThis.Inc = Inc

impl Inc for Number = fn() = this + 1
impl Inc for BigInt = fn() = this + 1n
impl Inc for String = fn() = String.fromCharCode(this.charCodeAt(0) + 1)

@[def_call def_global]
fn inc() = this.[Inc]()

@[def_global impl_equal(:start, :end)]
fn IRange(@start, @end) {}

@[def_global impl_equal(:start, :end)]
fn ERange(@start, @end) {}

@[def_global impl_equal(:end)]
fn IRangeNoMin(@end) {}

@[def_global impl_equal(:start)]
fn ERangeNoMax(@start) {}

@[def_global impl_equal(:end)]
fn ERangeNoMin(@end) {}

impl Call for IRange = fn(value) = value >= this.start && value <= this.end
impl Call for ERange = fn(value) = value >= this.start && value < this.end
impl Call for IRangeNoMin = fn(value) = value <= this.end
impl Call for ERangeNoMax = fn(value) = value >= this.start
impl Call for ERangeNoMin = fn(value) = value < this.end

impl Symbol.iterator for IRange = fn*() {
  let {start: i, end} = this
  while i <= end {
    yield i
    i = i::inc()
  }
}
impl Symbol.iterator for ERange = fn*() {
  let {start: i, end} = this
  while i < end {
    yield i
    i = i::inc()
  }
}
impl Symbol.iterator for ERangeNoMax = fn*() {
  let i = this.start
  loop {
    yield i
    i = i::inc()
  }
}

@def_global
fn def_vector(Constructor) {
  define Vector for Constructor = fn(args) = new Constructor(...args)
  return Constructor
}

@[def_global doc("
Defines a basic record type for a given constructor.

Important! make sure your constructor has its entries stored at this.entries.

Example:
  @def_record
  fn ArrayMap(@entries) {}

  let name->role = ~ArrayMap{
    \"marcelle rusu\" => \"coil language designer\"
  }

  // note that in this most minimal use, def_record isn't super useful.
  // let's take a look at something more practical

  @def_record
  fn CallMap(@entries) {}

  impl Call for CallMap = fn(val) =
    ::find(fn([key]) = key::call(val))
    ::pipe(1)

  let score->letter_grade = ~CallMap{
    ..50 => :F
    50..60 => :D
    60..70 => :C
    70..80 => :B
    80.. => :A
  }
  score->letter_grade::call(60) // :C
")]
fn def_record(Constructor) {
  define Record for Constructor = fn(entries) = new Constructor(entries)
  impl Symbol.iterator for Constructor = fn() = this.entries::iter()
  return Constructor
}

// string helpers
let char_alpha? = ("a"..="z")::into(Set[]) + ("A"..="Z")::into(Set[])
let char_numeric? = ("0"..="9")::into(Set[])
let char_alpha_numeric? = char_alpha? + char_numeric?
globalThis.char_alpha__q = char_alpha?
globalThis.char_numeric__q = char_numeric?
globalThis.char_alpha_numeric__q = char_alpha_numeric?

@[def_global doc("all characters in string are in a-z or A-Z")]
fn alpha?() = this::all?(char_alpha?)

@[def_global doc("all characters in string are in a-z or A-Z or 0-9")]
fn alpha_numeric?() = this::all?(char_alpha_numeric?)

@[def_record def_global]
fn CallMap(@entries) {}

impl Call for CallMap = fn(value) =
  ::find(fn([callable, _]) = callable::call(value))
  ::pipe(fn([_, val]) = val)
