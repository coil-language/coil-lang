import tokenize from "./tokenizer.mjs"
import parse from "./parser.mjs"
import emit from "./emit.mjs"
import {str, CollectionView} from "./shared.mjs"

let nid_count = 0
def nid()
  nid_count = nid_count + 1
  return str("nid_" nid_count)
end

def quote(s) = str("\"" s "\"")

def line_and_col(pos, Ctx) = 
  str("line_and_col(" Ctx ", " pos:line ", " pos:col ").")

def emit_args(args, Parent)
  let Self = nid()
  return str(
    "fn_args(" Self ", " Parent ").\n"
    args
      .map(|node| emit_node(node, Self))
      .join("\n")
  )
end

def emit_node(node, Parent) = node.pipe(:type Map{
  def :let({assign_expr, rhs, pos})
    let [Self Assign Rhs] = [nid() nid() nid()]
    return str(
      "let(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "assign_expr(" Assign ", " Self ").\n"
      emit_node(assign_expr, Self) "\n"
      "rhs(" Rhs ", " Self ").\n"
      emit_node(rhs, Rhs)
    )
  end
  def :array({elements, pos})
    let Self = nid()
    return str(
      "line_and_col(" Self ", " pos:line ", " pos:col ").\n"
      "array_node(" Self ", " Parent ").\n"
      elements.zip(0..).map(|[expr idx]| {
        let V2 = nid()
        return str(
          emit_node(expr, V2) "\n"
          "array_element(" V2 ", " idx ", " Self ")."
        )
      }).join("\n")
    )
  end
  def :regular_record_entry({key_expr value_expr, pos})
    let [Self Key Value] = [nid() nid() nid()]
    return str(
      line_and_col(pos, Self) "\n"
      "regular_record_entry(" Self ", " Parent ").\n"
      "key_expr(" Key ", " Self ").\n"
      emit_node(key_expr, Key) "\n"
      "value_expr(" Value ", " Self ").\n"
      emit_node(value_expr, Value)
    )
  end
  def :keyword_record_entry({name, expr, pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "keyword_record_entry(" quote(name) ", " Self ", " Parent ").\n"
      emit_node(expr, Self)
    )
  end
  def :id_assign({name pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "id_assign(" quote(name) ", " Self ", " Parent ").\n"
    )
  end
  def :array_deconstruction({entries}) = entries.zip(0..)
    .map(|[node idx]| {
      let Var = nid()
      return str(
        emit_node(node, Var) "\n"
        line_and_col(node:pos, Var) "\n"
        "array_deconstruction(" Var ", " idx ", " Parent ")."
      )
    }).join("\n")
  def :id_lookup({name pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "id_lookup(" quote(name) ", " Self ", " Parent ").\n"
    )
  end
  def :num({value, pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "num(" value ", " Self ", " Parent ")."
    )
  end
  def :keyword({value, pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "keyword(" quote(value) ", " Self ", " Parent ")."
    )
  end
  def :str({value, pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "str(" value:replaceAll("\n" "\\n") ", " Self ", "Parent ")."
    )
  end
  def :object_literal({entries, pos})
    let Self = nid()
    return str(
      "object_literal(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      entries.map(|node| emit_node(node, Self)).join("\n")
    )
  end
  def :return({expr pos})
    let Self = nid()
    return str(
      "return(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :fn({args, name_expr, body, pos, is_async?, generator?})
    let [Self Name] = [nid() nid()]
    return str(
      "fn(" Self ", " Parent ").\n"
      "name_expr(" Name ", " Self ").\n"
      emit_node(name_expr, Name) "\n"
      line_and_col(pos, Self) "\n"
      "is_async(" is_async?.as_bool() ", " Self ").\n"
      "generator(" generator?.as_bool() ", " Self ").\n"
      emit_args(args, Self) "\n"
      emit_ast(body, Self) "\n"
    )
  end
  def :snd_assign({lhs rhs pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "snd_assign(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs "," Self ").\n"
      emit_node(lhs, Lhs) "\n"
      "rhs(" Rhs ", " Self ").\n"
      emit_node(rhs, Rhs) "\n"
    )
  end
  def :direct_import({path pos})
    let Self = nid()
    return str(
      "direct_import(" path ", " Self ", " Parent ").\n"  
      line_and_col(pos, Self) "\n"
    )
  end
  def :export_default({expr pos})
    let Self = nid()
    return str(
      "export_default(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :export({statement pos})
    let Self = nid()
    return str(
      "export(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(statement, Self)
    )
  end
  def :import({assign_expr path pos})
    let [Self, Assign] = [nid() nid()]
    return str(
      "import(" path:value ", " Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "assign_expr(" Assign ", " Self ").\n"
      emit_node(assign_expr, Assign)
    )
  end
  def :break({pos})
    let Self = nid()
    return str(
      "break(" Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :continue({pos})
    let Self = nid()
    return str(
      "continue(" Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :try(node)
    let [Self Body] = [nid() nid()]
    return str(
      "try(" Self ", " Parent ").\n"
      line_and_col(node:pos, Self) "\n"
      "body(" Body ", " Self ").\n"
      emit_ast(node:body, Body) "\n"
      node:catch and emit_node(node:catch, Self)
      node:finally and emit_node(node:finally, Self)
    )
  end
  def :finally({body, pos})
    let [Self Body] = [nid() nid()]
    return str(
      "finally(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "body(" Body ", " Self ").\n"
      emit_ast(body, Body)
    )
  end
  def :catch({name, body, pos})
    let [Self Body] = [nid() nid()]
    return str(
      "catch(" quote(name) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "body(" Body ", " Self ").\n"
      emit_ast(body, Body)
    )
  end
  def :while_let_loop({assign_expr, test_expr, body, pos})
    let [Self Assign Test Body] = [nid() nid() nid() nid()]
    return str(
      "while_let_loop(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "assign_expr(" Assign ", " Self ").\n"
      emit_node(assign_expr, Assign) "\n"
      "test_expr(" Test ", " Self ").\n"
      emit_node(test_expr, Test) "\n"
      "body(" Body ", " Self ").\n"
      emit_ast(body, Body)
    )
  end
  def :while_loop({body, test_expr, pos})
    let [Self TestExpr] = [nid() nid()]
    return str(
      "while_loop(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "test_expr(" TestExpr ", " Self ").\n"
      emit_node(test_expr, TestExpr) "\n"
      emit_ast(body, Self)
    )
  end
  def :loop({body pos})
    let Self = nid()
    return str(
      "loop(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_ast(body, Self)
    )
  end
  def :for_loop({is_await? assign_expr iterable_expr body pos})
    let [Self Assign Iterable] = [nid() nid() nid()]
    return str(
      "for_loop(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "is_await(" is_await?.as_bool() ", " Self ").\n"
      "assign_expr(" Assign ", " Self ").\n"
      emit_node(assign_expr, Assign) "\n"
      "iterable_expr(" Iterable ", " Self ").\n"
      emit_node(iterable_expr, Iterable) "\n"
      emit_ast(body, Self)
    )
  end
  def :protocol_method({names})
    let Self = nid()
    return str(
      "protocol_method(" Self ", " Parent ").\n"
      names
        .map(|name| str("protocol_method_name(" quote(name) ", " Self ")."))
        .join("\n")
    )
  end
  def :protocol_def({name, methods})
    let Self = nid()
    return str(
      "protocol_def(" quote(name) ", " Self ", " Parent ").\n"
      methods.map(|node| emit_node(node, Self)).join("\n")
    )
  end
  def :if_let({assign_expr, expr, pass, fail, pos})
    let [Self Assign Expr Pass Fail] = [nid() nid() nid() nid() nid()]
    return str(
      "if_let(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "assign_expr(" Assign ", " Self ").\n"
      emit_node(assign_expr, Assign) "\n"
      "expr(" Expr ", " Self ").\n"
      emit_node(expr, Expr) "\n"
      "pass(" Pass ", " Self ").\n"
      emit_ast(pass, Pass) "\n"
      fail and str(
        "fail(" Fail ", " Self ").\n"
        emit_node(fail, Fail)
      )
    )
  end
  def :if({expr, pass, fail, pos})
    let [Self Expr Pass Fail] = [nid() nid() nid() nid()]
    return str(
      "if(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "expr(" Expr ", " Self ").\n"
      emit_node(expr, Expr) "\n"
      "pass(" Pass ", " Self ").\n"
      emit_ast(pass, Pass) "\n"
      fail and str(
        "fail(" Fail ", " Self ").\n"
        emit_node(fail, Fail)
      )
    )
  end
  def :else_if({expr, pass, fail, pos})
    let [Self Expr Pass Fail] = [nid() nid() nid() nid()]
    return str(
      "else_if(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "expr(" Expr ", " Self ").\n"
      emit_node(expr, Expr) "\n"
      "pass(" Pass ", " Self ").\n"
      emit_ast(pass, Pass) "\n"
      fail and str(
        "fail(" Fail ", " Self ").\n"
        emit_node(fail, Fail)
      )
    )
  end
  def :else({body pos})
    let Self = nid()
    return str(
      "else(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_ast(body, Self)
    )
  end
  def :unapplied_equality_op({op, pos})
    let Self = nid()
    return str(
      "unapplied_equality_op(" quote(op) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :unapplied_algebra_op({op, pos})
    let Self = nid()
    return str(
      "unapplied_algebra_op(" quote(op) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :anon_body_fn({args body pos})
    let [Self Body] = [nid() nid()]
    return str(
      "anon_body_fn(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_args(args, Self) "\n"
      "body(" Body ", " Self ").\n"
      emit_ast(body, Body)
    )
  end
  def :anon_fn({args return_expr pos})
    let [Self Return] = [nid() nid() nid()]
    return str(
      "anon_fn(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_args(args Self) "\n"
      "return_expr(" Return ", " Self ").\n"
      emit_node(return_expr, Return)
    )
  end
  def :prefix_exclusive_range({expr pos})
    let Self = nid()
    return str(
      "prefix_exclusive_range(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :prefix_inclusive_range({expr pos})
    let Self = nid()
    return str(
      "prefix_inclusive_range(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :not({expr pos})
    let Self = nid()
    return str(
      "not(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :spread({expr pos})
    let Self = nid()
    return str(
      "spread(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :await({expr pos})
    let Self = nid()
    return str(
      "await(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :yield({star? expr pos})
    let Self = nid()
    return str(
      "yield(" star?.as_bool() ", " Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :paren_expr({expr pos})
    let Self = nid()
    return str(
      "paren_expr(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :this_spread_assign({name pos})
    let Self = nid()
    return str(
      "this_spread_assign(" quote(name) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :this_assign({name pos})
    let Self = nid()
    return str(
      "this_assign(" quote(name) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :object_deconstruction({entries, pos})
    let Self = nid()
    return str(
      "object_deconstruction(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      entries.map(|node| emit_node(node, Self)).join("\n")
    )
  end
  def :obj_assign_expr({property, assign_expr, pos})
    let Self = nid()
    return str(
      "obj_assign_expr(" quote(property) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(assign_expr, Self)
    )
  end
  def :obj_reg_entry({name pos})
    let Self = nid()
    return str(
      "obj_reg_entry(" quote(name) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :obj_entry_rename({old_name, new_name, pos})
    let Self = nid()
    return str(
      "obj_entry_rename(" quote(old_name) ", " quote(new_name) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :spread_assign({name, pos})
    let Self = nid()
    return str(
      "spread_assign(" quote(name) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :regex_lit({value pos})
    let Self = nid()
    value = value:replaceAll("\\" "\\\\"):replaceAll("\"" "\\\"")
    return str(
      "regex_lit(\"" value "\", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :or({lhs, rhs, pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "or(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      "rhs(" Rhs ", " Self ").\n"
      emit_node(rhs, Rhs) "\n"
    )
  end
  def :and({lhs, rhs, pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "and(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      "rhs(" Rhs ", " Self ").\n"
      emit_node(rhs, Rhs) "\n"
    )
  end
  def :equality_op({op, lhs, rhs, pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "equality_op(" quote(op) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      "rhs(" Rhs ", " Self ").\n"
      emit_node(rhs, Rhs)
    )
  end
  def :algebra_op({op, lhs, rhs, pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "algebra_op(" quote(op) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      "rhs(" Rhs ", " Self ").\n"
      emit_node(rhs, Rhs)
    )
  end
  def :meta_create({lhs, entries, pos})
    let [Self Entries Lhs] = [nid() nid() nid()]
    return str(
      "meta_create(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      "entries(" Entries ", " Self ").\n"
      entries.map(|node| emit_node(node, Entries)).join("\n")
    )
  end
  def :meta_from_entries({lhs, entries, pos})
    let [Self Entries Lhs] = [nid() nid() nid()]
    return str(
      "meta_from_entries(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      "entries(" Entries ", " Self ").\n"
      entries.map(|node| emit_node(node, Entries)).join("\n")
    )
  end
  def :fn_call({lhs, args, pos})
    let [Self Args Lhs] = [nid() nid() nid()]
    return str(
      "fn_call(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      "args(" Args ", " Self ").\n"
      args.map(|node| emit_node(node, Args)).join("\n")
    )
  end
  def :exclusive_range({lhs rhs pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "exclusive_range(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      rhs and str(
        "rhs(" Rhs ", " Self ").\n"  
        emit_node(rhs, Rhs)
      )
    )
  end
  def :inclusive_range({lhs rhs pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "inclusive_range(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      rhs and str(
        "rhs(" Rhs ", " Self ").\n"  
        emit_node(rhs, Rhs)
      )
    )
  end
  def :keyword_lookup({lhs, property, pos})
    let Self = nid()
    return str(
      "keyword_lookup(" quote(property) ", " Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(lhs, Self)
    )
  end
  def :dot({lhs, rhs, pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "dot(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      "rhs(" Rhs ", " Self ").\n"
      emit_node(rhs, Rhs) "\n"
    )
  end
}).pipe(|f| {
  if f
    return f(node, Parent)
  else
    console:error("unknown", node, Error[]:stack)
  end
})

def emit_ast(ast, Parent) = ast
  .map(|node| emit_node(node, Parent))
  .flat_map(|statement| statement.:split("\n"))
  .filter(|line| line:trim():length > 0)
  .into([])
  .:sort()
  .join("\n")

let ast = tokenize(Deno:readTextFileSync("./src/emit_prolog.coil"))
  .pipe(|tokens| CollectionView[tokens 0])
  .pipe(parse)

let prelude = Deno:readTextFileSync("./prolog_prelude.pl")

let module_nid = nid()

str(prelude "module([main], " module_nid ").\n" emit_ast(ast, module_nid)):trim().log()
