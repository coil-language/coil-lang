import tokenize from "./tokenizer.mjs"
import parse from "./parser.mjs"
import emit from "./emit.mjs"
import {str, CollectionView} from "./shared.mjs"

let nid_count = 0
def nid()
  nid_count = nid_count + 1
  return str("nid_" nid_count)
end

def line_and_col(pos, Ctx) = 
  str("line_and_col(" Ctx ", " pos:line ", " pos:col ").")

def emit_assign_expr(node, Parent) = node.pipe(:type Map{
  def :id_assign({name pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "id_assign(" name ", " Self ", " Parent ").\n"
    )
  end
  def :array_deconstruction({entries}) = entries.zip(0..)
    .map(do |[node idx]|
      let Var = nid()
      return str(
        emit_assign_expr(node, Var) "\n"
        "array_deconstruction(" Var ", " idx ", " Parent ")."
      )
    end).join("\n")
})(node)

def emit_let({assign_expr, rhs, pos} Parent)
  let Self = nid()
  return str(
    "let(" Self ", " Parent ").\n"
    line_and_col(pos, Self) "\n"
    emit_assign_expr(assign_expr, Self) "\n"
    emit_node(rhs, Self)
  )
end

def emit_array({elements, pos} Parent)
  let Self = nid()
  return str(
    "line_and_col(" Self ", " pos:line ", " pos:col ").\n"
    "array_node(" Self ", " Parent ").\n"
    elements.zip(0..).map(do |[expr idx]|
      let V2 = nid()
      return str(
        emit_node(expr, V2) "\n"
        "array_element(" V2 ", " idx ", " Self ")."
      )
    end).join("\n")
  )
end

def emit_name_expr(node, Parent)
  let Self = nid()
  return str(
    "name_expr(" Self ", " Parent ").\n"
    emit_node(node, Self)
  )
end

def emit_args(args, Parent)
  let Self = nid()
  return str(
    "fn_args(" Self ", " Parent ").\n"
    args
      .map(|node| emit_assign_expr(node, Self))
      .join("\n")
  )
end

def emit_record_entry(node, Parent) = node.pipe(:type Map{
  def :regular_record_entry({key_expr value_expr, pos})
    let [Self Key Value] = [nid() nid() nid()]
    return str(
      line_and_col(pos, Self) "\n"
      "regular_record_entry(" Self ", " Parent ").\n"
      "key_expr(" Key ", " Self ").\n"
      emit_node(key_expr, Key) "\n"
      "value_expr(" Value ", " Self ").\n"
      emit_node(value_expr, Value)
    )
  end
  def :keyword_record_entry({name, expr, pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "keyword_record_entry(" name ", " Self ", " Parent ").\n"
      emit_node(expr, Self)
    )
  end
})(node, Parent)

def emit_node(node, Parent) = node.pipe(:type Map{
  :let => emit_let
  :array => emit_array
  def :id_lookup({name pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "id_lookup(" name ", " Self ", " Parent ").\n"
    )
  end
  def :num({value, pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "num(" value ", " Self ", " Parent ")."
    )
  end
  def :keyword({value, pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "keyword(" value ", " Self ", " Parent ")."
    )
  end
  def :str({value, pos})
    let Self = nid()
    return str(
      line_and_col(pos, Self) "\n"
      "str(" value ", " Self ", "Parent ")."
    )
  end
  def :object_literal({entries})
    let Self = nid()
    return str(
      "object_literal(" Self ", " Parent ").\n"
      entries.map(|node| emit_record_entry(node, Self)).join("\n")
    )
  end
  def :return({expr pos})
    let Self = nid()
    return str(
      "return(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :fn({args, name_expr, body, pos, is_async?, generator?})
    let Self = nid()
    return str(
      emit_name_expr(name_expr, Self) "\n"
      line_and_col(pos, Self) "\n"
      "fn(" Self ", " Parent ").\n"
      "is_async(" is_async?.as_bool() ", " Self ").\n"
      "generator(" generator?.as_bool() ", " Self ").\n"
      emit_args(args, Self) "\n"
      emit_ast(body, Self) "\n"
    )
  end
  def :snd_assign({lhs rhs pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "snd_assign(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs "," Self ").\n"
      emit_node(lhs, Lhs) "\n"
      "rhs(" Rhs ", " Self ").\n"
      emit_node(rhs, Rhs) "\n"
    )
  end
  def :direct_import({path pos})
    let Self = nid()
    return str(
      "direct_import(" path ", " Self ", " Parent ").\n"  
      line_and_col(pos, Self) "\n"
    )
  end
  def :export_default({expr pos})
    let Self = nid()
    return str(
      "export_default(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :export({statement pos})
    let Self = nid()
    return str(
      "export(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(statement, Self)
    )
  end
  def :import({assign_expr path pos})
    let [Self, Assign] = [nid() nid()]
    return str(
      "import(" path:value ", " Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "assign_expr(" Assign ", " Self ").\n"
      emit_assign_expr(assign_expr, Assign)
    )
  end
  def :break({pos})
    let Self = nid()
    return str(
      "break(" Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :continue({pos})
    let Self = nid()
    return str(
      "continue(" Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  -- :try
  -- :finally
  -- :catch
  -- :while_let_loop
  def :while_loop({body test_expr pos})
    let [Self TestExpr] = [nid() nid()]
    return str(
      "while_loop(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "test_expr(" TestExpr ", " Self ").\n"
      emit_node(test_expr, TestExpr) "\n"
      emit_ast(body, Self)
    )
  end
  def :loop({body pos})
    let Self = nid()
    return str(
      "loop(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_ast(body, Self)
    )
  end
  def :for_loop({is_await? assign_expr iterable_expr body pos})
    let [Self Assign Iterable] = [nid() nid() nid()]
    return str(
      "for_loop(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "is_await(" is_await?.as_bool() ", " Self ").\n"
      "assign_expr(" Assign ", " Self ").\n"
      emit_assign_expr(assign_expr, Assign) "\n"
      "iterable_expr(" Iterable ", " Self ").\n"
      emit_node(iterable_expr, Iterable) "\n"
      emit_ast(body, Self)
    )
  end
  def :protocol_method({names})
    let Self = nid()
    return str(
      "protocol_method(" Self ", " Parent ").\n"
      names
        .map(|name| str("protocol_method_name(" name ", " Self ")."))
        .join("\n")
    )
  end
  def :protocol_def({name, methods})
    let Self = nid()
    return str(
      "protocol_def(" name ", " Self ", " Parent ").\n"
      methods.map(|node| emit_node(node, Self)).join("\n")
    )
  end
  -- :if_let
  -- :if
  -- :else_if
  -- :else
  -- :unapplied_equality_op
  -- :unapplied_algebra_op
  -- :anon_body_fn
  -- :anon_fn
  def :prefix_exclusive_range({expr pos})
    let Self = nid()
    return str(
      "prefix_exclusive_range(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :prefix_inclusive_range({expr pos})
    let Self = nid()
    return str(
      "prefix_inclusive_range(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :not({expr pos})
    let Self = nid()
    return str(
      "not(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :spread({expr pos})
    let Self = nid()
    return str(
      "spread(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :await({expr pos})
    let Self = nid()
    return str(
      "await(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :yield({star? expr pos})
    let Self = nid()
    return str(
      "yield(" star?.as_bool() ", " Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :paren_expr({expr pos})
    let Self = nid()
    return str(
      "paren_expr(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(expr, Self)
    )
  end
  def :this_spread_assign({name pos})
    let Self = nid()
    return str(
      "this_spread_assign(" name ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :this_assign({name pos})
    let Self = nid()
    return str(
      "this_assign(" name ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :object_deconstruction({entries, pos})
    let Self = nid()
    return str(
      "object_deconstruction(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      entries.map(|node| emit_node(node, Self)).join("\n")
    )
  end
  def :obj_assign_expr({property, assign_expr, pos})
    let Self = nid()
    return str(
      "obj_assign_expr(" property ", " Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(assign_expr, Self)
    )
  end
  def :obj_reg_entry({name pos})
    let Self = nid()
    return str(
      "obj_reg_entry(" name ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :obj_entry_rename({old_name, new_name, pos})
    let Self = nid()
    return str(
      "obj_entry_rename(" old_name ", " new_name ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :spread_assign({name, pos})
    let Self = nid()
    return str(
      "spread_assign(" name ", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :regex_lit({value pos})
    let Self = nid()
    return str(
      "regex_lit(\"" value "\", " Self ", " Parent ").\n"
      line_and_col(pos, Self)
    )
  end
  def :or({lhs, rhs, pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "or(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      "rhs(" Rhs ", " Self ").\n"
      emit_node(rhs, Rhs) "\n"
    )
  end
  def :and({lhs, rhs, pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "and(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      "rhs(" Rhs ", " Self ").\n"
      emit_node(rhs, Rhs) "\n"
    )
  end
  -- :equality_op
  -- :algebra_op
  -- :meta_create
  -- :meta_from_entries
  -- :fn_call
  def :exclusive_range({lhs rhs pos})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "exclusive_range(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      rhs and str(
        "rhs(" Rhs ", " Self ").\n"  
        emit_node(rhs, Rhs)
      )
    )
  end
  def :inclusive_range({lhs rhs pos})
  let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "inclusive_range(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      rhs and str(
        "rhs(" Rhs ", " Self ").\n"  
        emit_node(rhs, Rhs)
      )
    )
  end
  def :keyword_lookup({lhs, property, pos})
    let Self = nid()
    return str(
      "keyword_lookup(" property ", " Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      emit_node(lhs, Self)
    )
  end
  def :dot({lhs, rhs})
    let [Self Lhs Rhs] = [nid() nid() nid()]
    return str(
      "dot(" Self ", " Parent ").\n"
      line_and_col(pos, Self) "\n"
      "lhs(" Lhs ", " Self ").\n"
      emit_node(lhs, Lhs) "\n"
      "rhs(" Rhs ", " Self ").\n"
      emit_node(rhs, Rhs) "\n"
    )
  end
}).pipe(do |f|
  if f
    return f(node, Parent)
  else
    console:error(node)
  end
end)

def emit_ast(ast, Parent) = ast
  .map(|node| emit_node(node, Parent))
  .flat_map(|statement| statement.:split("\n"))
  .into([])
  .:sort()
  .join("\n")

let ast = tokenize(Deno:readTextFileSync("./example.coil"))
  .pipe(|tokens| CollectionView[tokens 0])
  .pipe(parse)

let prelude = Deno:readTextFileSync("./prolog_prelude.pl")

let module_nid = nid()

str(prelude "module([main], " module_nid ").\n" emit_ast(ast, module_nid)):trim().log()
