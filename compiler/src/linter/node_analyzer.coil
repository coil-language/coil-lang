import {lex_and_parse} from "./dist/compiler.js"

protocol Lint

fn impl_lint(Ctor, type) {
  impl Lint for Ctor = fn(node) =
    node::at(:type) == type &&
    ::all?(fn([key, val]) = val[Lint](node::at(key)))
  return Ctor
}

fn has_node?(linter) = ::not_empty?() && ::all?(fn(node) =
  linter[Lint](node) || node::at(:body)::pipe(fn (ast) = ast::has_node?(linter))
)

fn has_no_nodes?(linter) = ::has_node?(linter)::negate()

define Lint for log = fn(other) = other::log("Lint")

impl Lint for String = fn(other) = this === other

impl Lint for Underscore = fn(other) = this::call(other)

impl Lint for Array = fn(other) =
  other is Array && this::len() == other::len() &&
  ::zip(other)::all?(fn([rule, val]) = rule[Lint](val))

@impl_lint(:decorator)
fn Decorator(@entries) {}

@impl_lint(:fn)
fn Fn(@entries) {}

@impl_lint(:fn_call)
fn FnCall(@entries) {}

@impl_lint(:id_lookup)
fn IdLookup(@entries) {}

@impl_lint(:this_assign)
fn ThisAssign(@entries) {}

fn check_rule({query, check, message}, program_str) =
  ::keep(fn(node) = query[Lint](node))
  ::reject(check)
  ::each(fn(node) = 
    node
      ::pipe(:pos :line _ - 1)
      ::pipe(fn(line) = line..=(line + 3))
      ::pipe(fn({start, end}) = program_str.split("\n").slice(start, end).join("\n> "))
      ::log(message "\n>")
  )

let example_program = "
fn do_stuff() {
  other_stuff!()
}
"

let query = ~Fn{name: _::last() != "!"}

fn check({body}) = body
  ::has_no_nodes?(~FnCall{lhs: ~IdLookup{name: _::last() == "!"}})

let message = "
Side effects must be propagated by convention of appending '!'
to the name of functions that call effectful functions.
"

let rule = {query, check, message}

fn check_program(program_str, rule) = program_str
  ::pipe(lex_and_parse)
  ::pipe(fn (ast) = ast::check_rule(rule, program_str))

check_program(example_program, rule)
