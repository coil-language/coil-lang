str.kw = fn (...args) = fn (obj) = args
  ::map(fn (arg) {
    if arg::str?() { return arg }
    else { return arg::call(obj) }
  })
  ::into("")

fn CollectionView(@collection, @idx) {}

// Its only partially implemented right now because most use-cases
// don't require the complete collections api.
impl Collection for CollectionView = {
  fn len() = this.collection::len() - this.idx
  fn empty?() = this::len() == 0
  fn at(idx) = this.collection::at(this.idx + idx)
}

impl OrderedSequence for CollectionView = {
  fn first() = this.collection::at(this.idx)
  fn last() = this.collection::last()
}

impl :skip for CollectionView = fn(n) =
  CollectionView[this.collection, this.idx + n]

impl Symbol.iterator for CollectionView = fn*() {
  for i of this.idx..=this.collection::len() {
    yield this.collection[i]
  }
}

fn Lexer(@entries) {}

fn pass() {}
fn newline() {}

impl Call for Lexer = fn(str) {
  let tokens = []  
  let index = 0
  fn rest-of-string() = str.slice(index)

  fn scan() {
    let result = rest-of-string().match(this)
    if !result || result.index != 0 { return false }
    index = index + result[0].length
    return result[0]
  }

  let line = 1
  let col = 1
  while rest-of-string() != "" {
    let found = false  
    for [pattern type] of this.entries {
      if let value = pattern::scan() {
        if type == newline {
          line = line + 1
          col = 1
        } else if type != pass {
          tokens.push({type, value, line, col})
          col = col + value::len()
        } else {
          col = col + value::len()
        }
        found = true
        break
      }
    }
    if !found { raise!(Error["No token matched."]) }
  }

  return tokens
}

let lexer = Lexer{
  /^\n/ => newline
  /^\s+/ => pass
  /^\/\/.*/ => pass
  /^\,/ => pass
  /^\;/ => pass
  /^if\b/ => :if
  /^is\b/ => :is
  /^else\b/ => :else
  /^return\b/ => :return
  /^import\b/ => :import
  /^export\b/ => :export
  /^default\b/ => :default
  /^from\b/ => :from
  /^let\b/ => :let
  /^protocol\b/ => :protocol
  /^for\b/ => :for
  /^try\b/ => :try
  /^catch\b/ => :catch
  /^finally\b/ => :finally
  /^while\b/ => :while
  /^loop\b/ => :loop
  /^continue\b/ => :continue
  /^break\b/ => :break
  /^of\b/ => :of
  /^impl\b/ => :impl
  /^define\b/ => :define
  /^yield\b/ => :yield
  /^async\b/ => :async
  /^await\b/ => :await
  /^as\b/ => :as
  /^\=\>/ => :arrow
  /^\@/ => :at
  /^\&\&/ => :and_and
  /^\|\|/ => :or_or
  /^\?\?/ => :nullish
  /^\=\=\=/ => :triple_eq
  /^\!\=\=/ => :triple_not_eq
  /^\=\=/ => :double_eq
  /^\!\=/ => :not_eq
  /^\!/ => :bang
  /^\=/ => :eq
  /^fn\b/ => :fn
  /^\{/ => :open_b
  /^\}/ => :close_b
  /^\(/ => :open_p
  /^\)/ => :close_p
  /^[\-\+]?(\d*\.)?\d+[a-zA-Z]+/ => :custom_number_literal
  /^[\-\+]?(\d*\.)?\d+/ => :num
  /^\.\.\./ => :dot_dot_dot
  /^\.\./ => :dot_dot
  /^\./ => :dot
  /^\/.*\/[a-z]?/ => :regex_lit
  /^\>\=/ => :gt_eq
  /^\<\=/ => :lt_eq
  /^\>/ => :gt
  /^\</ => :lt
  /^\+/ => :plus
  /^\%/ => :mod
  /^\-/ => :minus
  /^\*\*/ => :pow
  /^\*/ => :times
  /^\&/ => :single_and
  /^\:\:/ => :double_colon
  /^\:[a-zA-Z_\?\!\$0-9\/\.]+/ => :keyword
  /^\:/ => :colon
  /^\// => :div
  /^\[/ => :open_sq
  /^\]/ => :close_sq
  /^\"([^\\\"]|\\.)*\"/s => :string_lit
  /^[a-zA-Z_\?\!\$0-9\>\-]+/ => :id
}

fn ParseError(expected-token-type, actual-token) {
  this.stack = Error[].stack
  this.message = str(
    "Expected: " expected-token-type
    " got " actual-token::at(:type)
    " @ " actual-token::at(:line)::as_str() ":" actual-token::at(:col)::as_str()
  )
}
ParseError.prototype = Error[]

fn expect-token!(kw) {
  if this::first()::at(:type) != kw {
    raise!(ParseError[kw, this::first()])
  } else {
    return this
  }
}

fn verify-exists!(parser) {
  if this::nil?() {
    raise!(Error["Parser Failed - Expected " + parser])
  } else {
    return this
  }
}

// PARSER MACHINE IMPL

protocol ParseInstruction

fn line-and-col({line, col}) = {line, col}

fn Init(@expr) {}
impl ParseInstruction for Init = fn([_expr, tokens]) =
  [{...this.expr, pos: line-and-col(tokens::first())} tokens]

fn One(@kw, @as) {}
impl ParseInstruction for One = fn([expr tokens]) {
  let {value, type} = tokens::expect-token!(this.kw)::first()
  return [expr::merge({[this.as]: value}) tokens.skip(1)]
}

fn Optional(@set_or_kw, @parse_fn, @as) {}
impl ParseInstruction for Optional = fn([expr tokens]) {  
  if tokens::empty?() { return [expr tokens] }
  // this is getting hairy, reimplementing ParseMap here..
  fn check_set(type) =
    ::any?(fn(val) {
      if val == type {
        return true
      } else if val.[Bag] {
        return val::has?(type)
      }
    })
  let {type} = tokens::first()
  if this.set_or_kw is Keyword && type == this.set_or_kw {
    return Then[this.parse_fn, this.as]::parse_step([expr tokens])
  } else if this.set_or_kw is Set && this.set_or_kw::check_set(type) {
    return Then[this.parse_fn, this.as]::parse_step([expr tokens])
  } else {
    return [expr tokens]
  }
}

impl ParseInstruction for Function = fn([_expr tokens]) = this(tokens)

fn Chomp(...kws) { this.kws = kws }
impl ParseInstruction for Chomp = fn([expr tokens]) {
  // this.kws::zip(tokens)::all!(fn([a b]) = a == b)
  // return [expr tokens::skip(this.kws::len())]
  let i = 0
  for kw of this.kws {
    tokens.skip(i)::expect-token!(kw)
    i = i + 1
  }
  return [expr, tokens.skip(i)]
}

fn Then(@parser, @kw) {}
impl ParseInstruction for Then = fn([expr tokens]) {
  let result = this.parser::call(tokens)
  if result::nil?() { return [expr tokens] }
  let [new-expr new-tokens] = result
  if this.kw {
    return [expr::merge({[this.kw]: new-expr}) new-tokens]
  } else {
    return [new-expr new-tokens]
  }
}

fn FMap(@f) {}
impl ParseInstruction for FMap = fn([expr tokens]) = [this.f::call(expr) tokens]

fn Until(@end_kw, @parser, @kw) {}
impl ParseInstruction for Until = fn([expr tokens]) {
  let exprs = []  
  while tokens::first()::at(:type) != this.end_kw {
    let [expr new-tokens] = this.parser::call(tokens)
      ::verify_exists!(this)
    exprs.push(expr)
    tokens = new-tokens
  }
  if this.kw {
    return [expr::merge({[this.kw]: exprs}) tokens]
  } else {
    return [exprs, tokens]
  }
}

fn Case(@parse_map, @kw) {}
impl ParseInstruction for Case = fn([expr tokens]) {
  if let [new-expr, new-tokens] = this.parse_map::call(tokens) {
    if this.kw {
      return [expr::merge({[this.kw]: new-expr}), new-tokens]
    } else {
      return [new-expr new-tokens]
    }
  } else {
    console.log(this.tokens::first(), this.parse_map)
    raise!(Error["Case Parse Failed"])
  }
}

fn Either(@set, @kw) {}
impl ParseInstruction for Either = fn([expr tokens]) {
  let op = this.set::call(tokens::first()::at(:type))::verify-exists!(this.set)
  let [new-expr, rest] = [tokens::first(), tokens.skip(1)]
  return [expr::merge({[this.kw]: new-expr::at(:value)}), rest]
}

fn parse-step(result) = this[ParseInstruction](result)

fn Parser(...instructions) { this.instructions = instructions }

impl Call for Parser = fn(tokens) =
  this::parse-step([null tokens])

fn AbortIf(@cond_fn) {}

impl ParseInstruction for Parser = fn(result) {
  for instruction of this.instructions {
    if instruction is AbortIf {
      if instruction.cond_fn::call(result) {
        return
      } else {
        continue
      }
    }
    result = instruction::parse_step(result)
  }
  return result
}

fn ParseMap(@entries) {}

impl Record for ParseMap = {
  fn keys() = this.entries::map(first)::into(Set[])
}

impl Call for ParseMap = fn(tokens, ...args) {
  if tokens::empty?() { return }

  for [pattern parser] of this.entries {
    if pattern == _ {
      return parser::call(tokens, ...args)
    } else if pattern is Set && pattern::call(tokens::first()::at(:type)) {
      return parser::call(tokens, ...args)
    } else if pattern is Array && pattern::zip(tokens)::all?(fn([p, token]) {
      if let {type} = token {
        if p is Keyword { return p == type }
        if p is Set { return p::has?(type) }
      } else {
        return false
      }
    }) {
      return parser::call(tokens, ...args)
    } else if pattern is Keyword && pattern == tokens::first()::at(:type) {
      return parser::call(tokens, ...args)
    }
  }
}

// COIL PARSER START

let math-ops = Set[:mod :plus :minus :times :pow :div]
let comparison-ops = Set[:lt :gt :lt_eq :gt_eq]
let all-math-ops = math-ops::concat(comparison-ops)

fn parse-double-eq(tokens lhs) = Parser[
  Init[{type: :double_equals, lhs}]
  Chomp[:double_eq]
  Then[parse-1-2-expr :rhs]
]::call(tokens)

fn parse-not-eq(tokens lhs) = Parser[
  Init[{type: :not_equals, lhs}]
  Chomp[:not_eq]
  Then[parse-1-2-expr :rhs]
]::call(tokens)

fn parse-triple-eq(tokens lhs) = Parser[
  Init[{type: :triple_equals, lhs}]
  Chomp[:triple_eq]
  Then[parse-1-2-expr :rhs]
]::call(tokens)

fn parse-triple-not-eq(tokens lhs) = Parser[
  Init[{type: :triple_not_equals, lhs}]
  Chomp[:triple_not_eq]
  Then[parse-1-2-expr :rhs]
]::call(tokens)

fn parse-and-and(tokens lhs) = Parser[
  Init[{type: :and_and, lhs}]
  Chomp[:and_and]
  Then[parse-expr :rhs]
]::call(tokens)

fn parse-or-or(tokens lhs) = Parser[
  Init[{type: :or_or, lhs}]
  Chomp[:or_or]
  Then[parse-expr :rhs]
]::call(tokens)

fn parse-nullish(tokens lhs) = Parser[
  Init[{type: :nullish, lhs}]
  Chomp[:nullish]
  Then[parse-expr :rhs]
]::call(tokens)

fn parse-comparison-op(tokens lhs) = Parser[
  Init[{type: :math_op, lhs}]
  Either[comparison-ops :op]
  Then[parse-1-2-expr :rhs]
]::call(tokens)

fn parse-third-expr-step(tokens, lhs) = ParseMap{
  :double_eq => parse-double-eq
  :triple_eq => parse-triple-eq
  :triple_not_eq => parse-triple-not-eq
  :not_eq => parse-not-eq
  :and_and => parse-and-and
  :or_or => parse-or-or
  :nullish => parse-nullish
  comparison-ops => parse-comparison-op
}::call(tokens, lhs)

fn parse-third-expr([lhs tokens]) {  
  while let [new-lhs rest] = parse-third-expr-step(tokens, lhs) {
    lhs = new-lhs
    tokens = rest
  }
  return [lhs tokens]
}

fn parse-partial-obj-dyn-access(tokens) = Parser[
  Init[{type: :partial_obj_dyn_access}]
  Chomp[:open_sq]
  Then[parse-expr :expr]
  Chomp[:close_sq]
]::call(tokens)

fn parse-partial-fn-call(tokens) = Parser[
  Init[{type: :partial_fn_call}]
  Chomp[:open_p]
  Until[:close_p parse-expr :args]
  Chomp[:close_p]
]::call(tokens)

fn parse-and-dot(tokens, lhs) = Parser[  
  Init[{type: :and_dot, lhs}]
  Chomp[:single_and :dot]
  Case[ParseMap{
    :id => parse-id,
    :open_sq => parse-partial-obj-dyn-access
    :open_p => parse-partial-fn-call
  } :rhs]
]::call(tokens)

fn parse-dot(tokens, lhs) = Parser[
  Init[{type: :property_lookup, lhs}]
  Chomp[:dot]
  Either[Set[:id :from] :property]
]::call(tokens)

fn parse-infix-bind(tokens lhs) = Parser[
  Init[{type: :bind, lhs}]
  Chomp[:double_colon]
  Case[ParseMap{
    :id => parse-id
    :fn => parse-fn
    all-math-ops => parse-unapplied-math-op
    :open_p => parse-paren-expr
  } :expr]
]::call(tokens)

fn parse-is(tokens, lhs) = Parser[
  Init[{type: :is, lhs}]
  Chomp[:is]
  Then[parse-1-2-expr, :rhs]
]::call(tokens)

fn parse-snd-assign(tokens, lhs) = Parser[
  Init[{type: :snd_assign, lhs}]
  Chomp[:eq]
  Then[parse-expr :rhs]
]::call(tokens)

fn parse-math-op(tokens lhs) = Parser[
  Init[{type: :math_op, lhs}]
  Either[math-ops :op]
  Then[parse-1-2-expr :rhs]
]::call(tokens)

fn not-adjacent?([_expr tokens]) {
  let current = tokens::first()
  let previous = tokens.collection::at(tokens.idx - 1)
  if current.line != previous.line { return true }
  let end-of-prev-token = previous.col + previous.value.length
  return (current.col - end-of-prev-token) >= 1
}

fn parse-adjacent-1-2-expr(tokens) = Parser[
  AbortIf[not-adjacent?]
  Then[parse-1-2-expr]
]::call(tokens)

fn parse-inclusive-range(tokens lhs) = Parser[
  AbortIf[not-adjacent?]
  Init[{type: :inclusive_range, lhs}]
  Chomp[:dot_dot :eq]
  Optional[SINGLE_EXPR_PARSE_MAP::keys() parse-adjacent-1-2-expr :rhs]
]::call(tokens)

fn parse-exclusive-range(tokens lhs) = Parser[
  AbortIf[not-adjacent?]
  Init[{type: :exclusive_range, lhs}]
  Chomp[:dot_dot]
  Optional[SINGLE_EXPR_PARSE_MAP::keys() parse-adjacent-1-2-expr :rhs]
]::call(tokens)

fn parse-fn-call(tokens lhs) = Parser[
  AbortIf[not-adjacent?]
  Init[{type: :fn_call, lhs}]
  Chomp[:open_p]
  Until[:close_p parse-expr :args]
  Chomp[:close_p]
]::call(tokens)

fn parse-record-lookup(tokens lhs) = Parser[
  AbortIf[not-adjacent?]
  Init[{type: :record_lookup, lhs}]
  Chomp[:open_b]
  Until[:close_b parse-record-entry :entries]
  Chomp[:close_b]
]::call(tokens lhs)

fn parse-dynamic-access(tokens lhs) = Parser[
  AbortIf[not-adjacent?]
  Init[{type: :dynamic_access, lhs}]
  Chomp[:open_sq]
  Until[:close_sq parse-expr :exprs]
  Chomp[:close_sq]
]::call(tokens)

let assignable-ops = math_ops::concat([:or_or, :and_and])

fn parse-op-eq(tokens lhs) = Parser[
  Init[{type: :op_eq, lhs}]  
  Either[assignable-ops :op]
  Chomp[:eq]
  Then[parse-expr :rhs]
]::call(tokens)

fn parse-raw-dynamic-access(tokens lhs) = Parser[
  Init[{type: :raw_dynamic_access, lhs}]
  Chomp[:dot :open_sq]
  Then[parse-expr :expr]
  Chomp[:close_sq]
]::call(tokens)

fn parse-snd-expr-step(tokens, lhs) = ParseMap{
  :open_p => parse-fn-call
  :double_colon => parse-infix-bind
  :open_sq => parse-dynamic-access
  :open_b => parse-record-lookup
  :is => parse-is
  :eq => parse-snd-assign
  [:dot :open_sq] => parse-raw-dynamic-access
  :dot => parse-dot
  [:single_and :dot] => parse-and-dot
  [:dot_dot :eq] => parse-inclusive-range
  :dot_dot => parse-exclusive-range
  [assignable-ops :eq] => parse-op-eq
  math-ops => parse-math-op
}::call(tokens, lhs)

fn parse-snd-expr([lhs tokens]) {  
  while let [new-lhs rest] = parse-snd-expr-step(tokens, lhs) {
    lhs = new-lhs
    tokens = rest
  }
  return [lhs tokens]
}

fn parse-call-expr(tokens) = Parser[
  Chomp[:open_p]
  Until[:close_p parse-expr]
  Chomp[:close_p]
]::call(tokens)

fn parse-decorator-expr(tokens) = ParseMap{
  :id => parse-expr
}::call(tokens)

fn parse-multi-decorator(tokens) = Parser[
  Init[{type: :multi_decorator}]
  Chomp[:at :open_sq]
  Until[:close_sq parse-decorator-expr :decorators]
  Chomp[:close_sq]
  Then[parse-fn :fn_def]
]::call(tokens)

fn parse-decorator(tokens) = Parser[
  Init[{type: :decorator}]
  Chomp[:at]
  One[:id :name]
  Optional[:open_p parse-call-expr :args]
  Then[parse-fn :fn_def]
]::call(tokens)

let parse-regex = Parser[
  Init[{type: :regex_lit}]
  One[:regex_lit :value]
]

let parse-str = Parser[
  Init[{type: :str}]
  One[:string_lit :value]
]

let valid-ids-in-all-contexts = Set[:id :from :as]

let parse-id = Parser[
  Init[{type: :id_lookup}]
  Either[valid-ids-in-all-contexts::push(:import) :name]
]

fn parse-reg-obj-entry(tokens) = Parser[
  Init[{type: :reg_obj_entry}]
  Either[Set[:id :num] :key]
  Chomp[:colon]
  Then[parse-expr :value]
]::call(tokens)

let parse-obj-shorthand-entry = Parser[
  Init[{type: :obj_shorthand_entry}]
  Either[valid-ids-in-all-contexts :id]
]

fn parse-dynamic-obj-entry(tokens) = Parser[
  Init[{type: :dynamic_obj_entry}]
  Chomp[:open_sq]
  Then[parse-expr :key_expr]
  Chomp[:close_sq :colon]
  Then[parse-expr :value]
]::call(tokens)

fn parse-spread-obj-entry(tokens) = Parser[
  Init[{type: :spread_obj_entry}]
  Chomp[:dot_dot_dot]
  Then[parse-expr :expr]
]::call(tokens)

fn parse-obj-entry(tokens) = ParseMap{
  :open_sq => parse-dynamic-obj-entry
  :dot_dot_dot => parse-spread-obj-entry
  :fn => parse-fn
  [:async :fn] => parse-fn
  [:id :colon] => parse-reg-obj-entry
  [:num :colon] => parse-reg-obj-entry
  :id => parse-obj-shorthand-entry
}::call(tokens)

fn parse-obj(tokens) = Parser[
  Init[{type: :obj_lit}]
  Chomp[:open_b]
  Until[:close_b parse-obj-entry :entries]
  Chomp[:close_b]
]::call(tokens)

let parse-spread-assign = Parser[
  Init[{type: :spread_assign}]
  Chomp[:dot_dot_dot]
  Either[valid-ids-in-all-contexts :name]
]

let parse-assign-id = Parser[
  Init[{type: :id_assign}]
  Either[valid-ids-in-all-contexts :name]
]

fn parse-assign-array-entry(tokens) = ParseMap{
  :id => parse-assign-id
  :open_sq => parse-assign-array
  :dot_dot_dot => parse-spread-assign
}::call(tokens)

let parse-assign-array = Parser[
  Init[{type: :array_deconstruction}]
  Chomp[:open_sq]
  Until[:close_sq parse-assign-array-entry :entries]
  Chomp[:close_sq]
]

let parse-obj-entry-rename = Parser[
  Init[{type: :obj_entry_rename}]
  Either[valid-ids-in-all-contexts :old_name]
  Chomp[:colon]
  Either[valid-ids-in-all-contexts :new_name]
]

let parse-regular-obj-assign-entry = Parser[
  Init[{type: :obj_reg_entry}]
  Either[valid-ids-in-all-contexts :name]
]

let parse-string-obj-assign-entry = Parser[
  Init[{type: :obj_str_rename_entry}]
  One[:string_lit :old_name]
  Chomp[:colon]
  Either[valid-ids-in-all-contexts :new_name]
]

let parse-obj-assign-entry = ParseMap{
  [:id :colon] => parse-obj-entry-rename
  :id => parse-regular-obj-assign-entry
  :string_lit => parse-string-obj-assign-entry
  :dot_dot_dot => parse-spread-assign
}

let parse-assign-obj = Parser[
  Init[{type: :object_deconstruction}]
  Chomp[:open_b]
  Until[:close_b parse-obj-assign-entry :entries]
  Chomp[:close_b]
]

let parse-this-assign = Parser[
  Init[{type: :this_assign}]
  Chomp[:at]
  Either[valid-ids-in-all-contexts :name]
]

let parse-this-spread-assign = Parser[
  Init[{type: :this_spread_assign}]
  Chomp[:dot_dot_dot :at]
  One[:id :name]
]

let parse-assign-expr = ParseMap{
  :id => parse-assign-id
  :open_sq => parse-assign-array
  :open_b => parse-assign-obj
  :at => parse-this-assign
  [:dot_dot_dot :at] => parse-this-spread-assign
  :dot_dot_dot => parse-spread-assign
}

let parse-keyword = Parser[
  Init[{type: :keyword}]
  One[:keyword :value]
]

fn parse-paren-expr(tokens) = Parser[
  Init[{type: :paren_expr}]
  Chomp[:open_p]
  Then[parse-expr :expr]
  Chomp[:close_p]
]::call(tokens)

fn parse-yield(tokens) = Parser[
  Init[{type: :yield}]
  Chomp[:yield]
  Optional[:times parse-gen-modifier :star?]
  Then[parse-expr :expr]
]::call(tokens)

fn parse-await(tokens) = Parser[
  Init[{type: :await}]
  Chomp[:await]
  Then[parse-expr :expr]
]::call(tokens)

let parse-num = Parser[
  Init[{type: :num}]
  One[:num :value]
]

let parse-custom-number-literal = Parser[
  Init[{type: :custom_number_literal}]
  One[:custom_number_literal :value]
]

fn parse-array(tokens) = Parser[
  Init[{type: :array}]
  Chomp[:open_sq]
  Until[:close_sq parse-expr :elements]
  Chomp[:close_sq]
]::call(tokens)

fn parse-spread(tokens) = Parser[
  Init[{type: :spread}]
  Chomp[:dot_dot_dot]
  Then[parse-expr :expr]
]::call(tokens)

let parse-unapplied-math-op = Parser[
  Init[{type: :unapplied_math_op}]
  Either[all-math-ops :op]
]

fn parse-bind-this(tokens) = Parser[
  Init[{type: :bind_this}]
  Chomp[:double_colon]
  Case[ParseMap{
    :id => parse-id
    :fn => parse-fn
    all-math-ops => parse-unapplied-math-op
    :open_p => parse-paren-expr
  } :expr]
]::call(tokens)

fn parse-not(tokens) = Parser[
  Init[{type: :not}]
  Chomp[:bang]
  Then[parse-1-2-expr :expr]
]::call(tokens)

fn parse-num-raw(tokens) =
  parse-num::call(tokens)::pipe(fn([expr, tokens]) = [expr::at(:value)::as_num(), tokens])

let parse-adjacent-num-raw = Parser[
  AbortIf[not-adjacent?]
  Then[parse-num-raw]
]

let parse-unapplied-and-and = Parser[
  Init[{type: :unapplied_and_and}]
  Chomp[:and_and]
]

let parse-unapplied-or-or = Parser[
  Init[{type: :unapplied_or_or}]
  Chomp[:or_or]
]

let parse-async-modifier = Parser[
  Init[true]
  Chomp[:async]
]

let parse-unapplied-nullish = Parser[
  Init[{type: :unapplied_nullish}]
  Chomp[:nullish]
]

let parse-gen-modifier = Parser[
  Init[true]
  Chomp[:times]
]

fn parse-fn-expr-body(tokens) = Parser[
  Init[{type: :return}]
  Chomp[:eq]
  Then[parse-expr :expr]
  FMap[fn(node) = [node]]
]::call(tokens)

fn parse-args-def(tokens) = Parser[
  Chomp[:open_p]
  Until[:close_p parse-assign-expr]
  Chomp[:close_p]
]::call(tokens)

fn parse-fn-name(tokens) =
  parse-id::call(tokens)::pipe(fn([expr, tokens]) = [expr::at(:name) tokens])

fn parse-fn(tokens) = Parser[
  Init[{type: :fn}]
  Optional[:async parse-async-modifier :is_async?]
  Chomp[:fn]
  Optional[:times parse-gen-modifier :generator?]
  Optional[:id parse-fn-name :name]
  Optional[:open_p parse-args-def :args]
  Case[ParseMap{
    :eq => parse-fn-expr-body,
    :open_b => block()
  } :body]
]::call(tokens)

fn parse-keyword-record-entry(tokens) = Parser[
  Init[{type: :keyword_record_entry}]
  One[:id :name]
  Chomp[:colon]
  Then[parse-expr :expr]
]::call(tokens)

fn parse-regular-record-entry(tokens) = Parser[
  Init[{type: :regular_record_entry}]
  Then[parse-expr :key_expr]
  Chomp[:arrow]
  Then[parse-expr :value_expr]
]::call(tokens)

fn parse-record-entry(tokens) = ParseMap{
  :dot_dot_dot => parse-spread
  [:id :colon] => parse-keyword-record-entry
  _ => parse-regular-record-entry
}::call(tokens)

fn parse-prefix-exclusive-range(tokens) = Parser[
  Init[{type: :prefix_exclusive_range}]
  Chomp[:dot_dot]
  Then[parse-1-2-expr :expr]
]::call(tokens)

let SINGLE_EXPR_PARSE_MAP = ParseMap{
  :string_lit => parse-str
  :regex_lit => parse-regex
  :keyword => parse-keyword
  :open_p => parse-paren-expr
  :yield => parse-yield
  :await => parse-await
  :num => parse-num
  :custom_number_literal => parse-custom-number-literal
  :open_sq => parse-array
  :dot_dot_dot => parse-spread
  :double_colon => parse-bind-this
  :bang => parse-not
  :open_b => parse-obj
  :and_and => parse-unapplied-and-and
  :or_or => parse-unapplied-or-or
  :nullish => parse-unapplied-nullish
  :dot_dot => parse-prefix-exclusive-range
  valid-ids-in-all-contexts::push(:import) => parse-id
  [:at :open_sq] => parse-multi-decorator
  :at => parse-decorator
  [:async :fn] => parse-fn
  :fn => parse-fn
  all-math-ops => parse-unapplied-math-op
}

fn parse-single-expr(tokens) = SINGLE_EXPR_PARSE_MAP::call(tokens)

fn parse-1-2-expr(tokens) =
  parse-single-expr(tokens)
    ::pipe(parse-snd-expr)

fn parse-expr(tokens) =
  parse-single-expr(tokens)
    ::pipe(parse-snd-expr)
    ::pipe(parse-third-expr)

fn parse-else-branch(tokens) = Parser[
  Init[{type: :else}]  
  Chomp[:else]
  block(:body)
]::call(tokens)

fn parse-else-if-branch(tokens) = Parser[
  Init[{type: :else_if}]  
  Chomp[:else :if]
  Then[parse-expr :expr]
  block(:pass)
  Optional[:else parse-if-branch :fail]
]::call(tokens)

fn parse-if-branch(tokens) = Parser[
  Case[ParseMap{
    [:else :if] => parse-else-if-branch
    :else => parse-else-branch
  }]
]::call(tokens)

fn parse-if(tokens) = Parser[
  Init[{type: :if}]
  Chomp[:if]
  Then[parse-expr :expr]
  block(:pass)
  Optional[:else parse-if-branch :fail]
]::call(tokens)

let parse-let = Parser[
  Init[{type: :let}]
  Chomp[:let]
  Then[parse-assign-expr :assign_expr]
  Chomp[:eq]
  Then[parse-expr :rhs]
]

fn parse-if-let(tokens) = Parser[
  Init[{type: :if_let}]
  Chomp[:if :let]
  Then[parse-assign-expr :assign_expr]
  Chomp[:eq]
  Then[parse-expr :expr]
  Chomp[:open_b]
  Until[:close_b parse-statement :pass]
  Chomp[:close_b]
  Optional[:else parse-else-branch :fail]
]::call(tokens)

let parse-impl-for = Parser[
  Init[{type: :impl_for}]
  Chomp[:impl]
  Then[parse-expr :proto_expr]
  Chomp[:for]
  One[:id :constructor]
  Chomp[:eq]
  Then[parse-expr :expr]
]

let parse-define = Parser[
  Init[{type: :define_for}]
  Chomp[:define]
  Then[parse-expr :proto_expr]
  Chomp[:for]
  Then[parse-single-expr :src_expr]
  Chomp[:eq]
  Then[parse-expr :expr]
]

let parse-protocol = Parser[
  Init[{type: :protocol_def}]
  Chomp[:protocol]
  One[:id :name]
]

let parse-return = Parser[
  Init[{type: :return}]
  Chomp[:return]
  Optional[SINGLE_EXPR_PARSE_MAP::keys() parse-expr :expr]
]

let parse-await-modifier = Parser[
  Init[true]
  Chomp[:await]
]

fn parse-for-loop(tokens) = Parser[
  Init[{type: :for_loop}]
  Chomp[:for]
  Optional[:await parse-await-modifier :is_await?]
  Then[parse-assign-expr :assign_expr]
  Chomp[:of]
  Then[parse-expr :iterable_expr]
  block(:body)
]::call(tokens)

fn parse-loop(tokens) = Parser[
  Init[{type: :loop}]
  Chomp[:loop]
  block(:body)
]::call(tokens)

fn parse-while-loop(tokens) = Parser[
  Init[{type: :while_loop}]
  Chomp[:while]
  Then[parse-expr :test_expr]
  block(:body)
]::call(tokens)

fn parse-while-let-loop(tokens) = Parser[
  Init[{type: :while_let_loop}]
  Chomp[:while :let]
  Then[parse-assign-expr :assign_expr]
  Chomp[:eq]
  Then[parse-expr :test_expr]
  block(:body)
]::call(tokens)

fn parse-continue(tokens) = Parser[
  Init[{type: :continue}]
  Chomp[:continue]
]::call(tokens)

fn parse-break(tokens) = Parser[
  Init[{type: :break}]
  Chomp[:break]
]::call(tokens)

fn parse-catch(tokens) = Parser[
  Init[{type: :catch}]
  Chomp[:catch]
  One[:id :name]
  block(:body)
]::call(tokens)

fn parse-finally(tokens) = Parser[
  Init[{type: :finally}]
  Chomp[:finally]
  block(:body)
]::call(tokens)

fn parse-try(tokens) = Parser[
  Init[{type: :try}]
  Chomp[:try]
  block(:body)
  Optional[:catch parse-catch :catch]
  Optional[:finally parse-finally :finally]
]::call(tokens)

let parse-impl-object = Parser[
  Init[{type: :impl_object}]
  Chomp[:impl]
  One[:id :constructor]
  Chomp[:eq]
  Then[parse-expr :expr]
]

let parse-assign-all-as = Parser[
  Init[{type: :assign_all_as}]
  Chomp[:times :as]
  One[:id :name]
]

fn parse-import-assign-expr(tokens) = Parser[
  Case[ParseMap{
    [:times :as] => parse-assign-all-as
    _ => parse-assign-expr
  }]
]::call(tokens)

fn parse-import(tokens) = Parser[
  Init[{type: :import}]
  Chomp[:import]
  Until[:from parse-import-assign-expr :assign_exprs]
  Chomp[:from]
  Then[parse-str :path]
]::call(tokens)

fn parse-export(tokens) = Parser[
  Init[{type: :export}]
  Chomp[:export]
  Then[parse-statement :statement]
]::call(tokens)

let parse-export-all = Parser[
  Init[{type: :export_all}]
  Chomp[:export :times :from]
  One[:string_lit :path]
]

fn parse-export-default(tokens) = Parser[
  Init[{type: :export_default}]
  Chomp[:export :default]
  Then[parse-expr :expr]
]::call(tokens)

fn parse-label(tokens) = Parser[
  Init[{type: :label}]
  One[:id :label_name]
  Chomp[:colon]
  Then[parse-statement :statement]
]::call(tokens)

let parse-direct-import = Parser[
  Init[{type: :direct_import}]
  Chomp[:import]
  One[:string_lit :path]
]

fn parse-statement(tokens) = ParseMap{
  :let => parse-let
  :for => parse-for-loop
  :define => parse-define
  :try => parse-try
  :protocol => parse-protocol
  :return => parse-return
  :continue => parse-continue
  :break => parse-break
  :loop => parse-loop
  [:import :string_lit] => parse-direct-import
  :import => parse-import
  [:export :default] => parse-export-default
  [:export :times] => parse-export-all
  :export => parse-export
  [:impl :id :eq] => parse-impl-object
  :impl => parse-impl-for
  [:while :let] => parse-while-let-loop
  :while => parse-while-loop
  [:if :let] => parse-if-let
  :if => parse-if
  [:id :colon] => parse-label
  _ => parse-expr
}::call(tokens)

fn block(name) = Parser[
  Chomp[:open_b]
  Until[:close_b parse-statement name]
  Chomp[:close_b]
]

fn parse(tokens) {
  let ast = []
  while let [statement-or-expr, rest] = parse-statement::call(tokens) {
    ast.push(statement-or-expr)
    tokens = rest
  }
  return ast
}

// END OF PARSING

// START OF EVAL

fn map-join(f, separator) =
  this::map(f)::reduce(fn(acc, cur) {
    if acc::empty?() { return cur }
    else { return acc + separator + cur }
  }, "")

fn resolve-name(name) {
  if name {
    return name
      .replaceAll("?", "__q")
      .replaceAll("!", "__b")
      .replaceAll(">", "_lt_")
      .replaceAll("-", "_")
  }
  return name
}

fn eval-if-branch(branch) {
  if branch::nil?() {
    return ""
  } else if branch::at(:type) == :else {
    return str(" else {\n"
      eval-ast(branch::at(:body) || [])
    "\n}")
  } else {
    if branch::at(:type) == :else_if {
      return str(
        " else if (" eval-expr(branch::at(:expr)) ") {\n"
          eval-ast(branch::at(:pass) || [])
        "\n}" eval-if-branch(branch::at(:fail))
      )
    } else {
      raise!(Error["Expected else if"])
    }
  }
}

let eval-if = str.kw(
  "if (truthy(" _[:expr eval-expr] ")) {\n"
    _[:pass eval-ast] "\n"
  "}" _[:fail eval-if-branch]
)

fn eval-str({value}) {
  value = value.slice(1, -1)
  if value.includes("\n") {
    return str("`" value "`")
  } else {
    return str("\"" value "\"")
  }
}

let RESERVED_IDS = Set["import"]

fn eval-property-lookup({lhs property}) {
  let lhs-js = eval-expr(lhs)
  if RESERVED_IDS::has?(lhs_js) {
    return str(lhs-js "." property)
  } else {
    return str(lhs-js "['" property "']")
  }
}

fn eval-fn-call({lhs args}) =
  str(eval-expr(lhs) "(" args::map-join(eval-expr, ", ") ")")

fn eval-id-assign-name({name}) = resolve-name(name)

fn eval-spread-assign({name}) = str("..." resolve-name(name))

fn eval-array-deconstruction-entry(node) = node::at(:type)::pipe(Map{
  :id_assign => eval-id-assign-name
  :spread_assign => eval-spread-assign
  :array_deconstruction => eval-array-deconstruction-names
})::call(node)

fn eval-array-deconstruction-names({entries}) =
  str("[" entries::map-join(eval-array-deconstruction-entry ", ") "]")

fn eval-obj-reg-entry({name}) = str("'" name "': " resolve-name(name))

fn eval-obj-entry-rename({old_name, new_name}) =
  str("'" old_name "': " resolve-name(new_name))

fn eval-obj-deconstruction-entry(node) = node::at(:type)::pipe(Map{
  :obj_reg_entry => eval-obj-reg-entry
  :obj_entry_rename => eval-obj-entry-rename
  :spread_assign => eval-spread-assign
  :obj_str_rename_entry => str.kw(:old_name ": " _[:new_name resolve-name])
})::call(node)

fn eval-object-deconstruction-names({entries}) =
  str("{" entries::map-join(eval-obj-deconstruction-entry ", ") "}")

fn eval-this-assign({name}) = resolve-name(name)

fn eval-this-spread-assign({name}) = str("..." resolve-name(name))

fn eval-assign-all-as({name}) =
  str("* as " name)

fn eval-assign-expr(node) = node::at(:type)::pipe(Map{
  :id_assign => eval-id-assign-name
  :spread_assign => eval-spread-assign
  :array_deconstruction => eval-array-deconstruction-names
  :object_deconstruction => eval-object-deconstruction-names
  :this_assign => eval-this-assign
  :this_spread_assign => eval-spread-assign
})::call(node)

fn eval-while-let-loop({assign_expr test_expr body}) = str(
  "let __coil_while_let_temp = " eval-expr(test_expr) ";\n"
  "while (__coil_while_let_temp) {\n"
    "let " eval-assign-expr(assign_expr) " = __coil_while_let_temp;\n"
    eval-ast(body) "\n"
    "__coil_while_let_temp = " eval-expr(test_expr) ";\n"
  "}")

fn eval-if-let({assign_expr expr pass fail}) = str(
  "let __coil_if_let_temp = " eval_expr(expr) ";\n"
  "if (truthy(__coil_if_let_temp)) {\n"
  "let " eval-assign-expr(assign_expr) " = __coil_if_let_temp;\n"
    eval-ast(pass) "\n"
  "}" eval-if-branch(fail))

fn eval-spread({expr}) = str("..." eval-expr(expr))

fn eval-let({assign_expr rhs}) =
  str("let " eval-assign-expr(assign_expr) " = " eval-expr(rhs))

fn eval-array({elements}) =
  str("[" elements::map-join(eval-expr ", ") "]")

let math-op-to-method = Map{
  ">" => "greater_than"
  "<" => "less_than"
  ">=" => "greater_than_eq"
  "<=" => "less_than_eq"
  "*" => "times"
  "**" => "exponent"
  "/" => "divide_by"
  "+" => "plus"
  "-" => "minus"
  "%" => "mod"
}

fn eval-math-op({lhs op rhs}) = str(
  math-op-to-method::call(op) ".call("
    eval-expr(lhs) "," eval-expr(rhs)
  ")")

fn eval-this-assignments(args) = args
  ::keep(:type Set[:this_assign :this_spread_assign])
  ::map(str.kw("this['" :name "'] = " _[:name resolve-name] ";\n"))
  ::into("")

fn eval-fn({is_async? generator? name args body}) = str(
  (is_async? && "async ")
  "function "
    (generator? && "*")
    resolve-name(name)
    "(" args::map-join(eval-assign-expr ", ") ") {\n"
    eval-this-assignments(args)
    eval-ast(body)
  "}")

fn eval-bind({lhs expr}) =
  str(eval-expr(expr) ".bind(" eval-expr(lhs) ")")

fn eval-reg-obj-entry({key, value}) =
  str("'" key "': " eval-expr(value))

fn eval-obj-shorthand-entry({id}) = str("'" id "':" resolve-name(id))

fn eval-dynamic-obj-entry({key_expr value}) =
  str("[" eval-expr(key_expr)"]: " eval-expr(value))

fn eval-obj-fn({name generator? is_async? args body}) =
  str((is_async? && "async ")
      (generator? && "*")
      "['" name "'](" args::map-join(eval_assign_expr ", ") ") {\n"
      eval-ast(body) "\n}")

fn eval-obj-entry(node) = node::at(:type)::pipe(Map{
  :reg_obj_entry => eval-reg-obj-entry
  :obj_shorthand_entry => eval-obj-shorthand-entry
  :dynamic_obj_entry => eval-dynamic-obj-entry
  :spread_obj_entry => eval-spread
  :fn => eval-obj-fn
})::call(node)

fn eval-obj-lit({entries}) =
  str("new ObjectLiteral({"
      entries::map-join(eval-obj-entry ", ") "})")

fn eval-bind-this({expr}) = str(eval-expr(expr) ".bind(this)")

fn eval-id-lookup({name}) = resolve-name(name)

fn eval-num({value}) = str("(" value ")")

fn eval-custom-number-literal({value}) {
  let [num] = value.split(/[a-zA-Z]+/)
  let modifier = value.slice(num.length)
  return str("Keyword.for(\"custom_number_literal/" modifier "\")[CustomNumberLiteral](" num ")")
}

fn eval-double-equals({lhs rhs}) = str(
  resolve-name("equals?") ".call(" eval-expr(lhs) ", " eval-expr(rhs) ")")

fn eval-not-equals(node) = str("negate.call(" eval-double-equals(node) ")")

fn eval-not({expr}) = str("negate.call(" eval-expr(expr) ")")

fn eval-dynamic-access({lhs exprs}) {
  let lhs-js = eval-expr(lhs)
  return str(lhs-js "[Meta]['[]'].call(" lhs-js ", " exprs::map-join(eval-expr ", ") ")")
}

fn eval-record-lookup({lhs entries}) {
  let lhs-js = eval-expr(lhs)
  let entries-js = entries::map-join(eval-record-entry ", ")
  return str(lhs-js "[Meta]['{}'].call(" lhs-js ", [" entries-js "])")
}

fn eval-triple-equals({lhs rhs}) =
  str(eval-expr(lhs) " === " eval-expr(rhs))

fn eval-triple-not-equals({lhs rhs}) =
  str(eval-expr(lhs) " !== " eval-expr(rhs))

fn eval-is({lhs rhs}) =
  str(eval-expr(lhs) " instanceof " eval-expr(rhs))

fn eval-and-and({lhs rhs}) =
  str("and.call(" eval-expr(lhs) ", () => " eval-expr(rhs) ")")

fn eval-or-or({lhs rhs}) =
  str("or.call(" eval-expr(lhs) ", () => " eval-expr(rhs) ")")

fn eval-nullish({lhs, rhs}) = 
  str("nullish.call(" eval-expr(lhs) ", () => " eval-expr(rhs) ")")

fn eval-dynamic-access-assign({lhs, rhs}) {
  let {lhs: obj, exprs} = lhs
  let obj-js = eval-expr(obj)
  return str(obj-js "[Meta]['[]='].call(" obj-js ", [" exprs::map-join(eval-expr ", ") "], " eval-expr(rhs) ")")
}

fn eval-general-snd-assign({lhs, rhs}) = str(eval-expr(lhs) " = " eval-expr(rhs))

fn eval-snd-assign(node) = node::pipe(:lhs :type Map{
  :dynamic_access => eval-dynamic-access-assign
  :id_lookup => eval-general-snd-assign
  :property_lookup => eval-general-snd-assign
  :raw_dynamic_access => eval-general-snd-assign
})::call(node)

fn eval-await({expr}) = str("await " eval-expr(expr))

fn eval-yield({star? expr}) =
  str("yield" (star? && "*") " " eval-expr(expr))

fn eval-paren-expr({expr}) = str("(" eval-expr(expr) ")")

fn eval-unapplied-math-op({op}) = math-op-to-method::call(op)

fn eval-unapplied-and-and() = "and"

fn eval-unapplied-or-or() = "or"

fn eval-unapplied-nullish() = "nullish"

fn eval-keyword({value}) = str("Keyword.for(\"" value.slice(1) "\")")

fn eval-regular-record_entry({key_expr value_expr}) =
  str("[" eval-expr(key_expr) ", " eval-expr(value_expr) "]")

fn eval-keyword-record-entry({name expr}) =
  str("[" eval-keyword({value: str(":" name)}) ", " eval-expr(expr) "]")

fn eval-record-entry(node) = node::at(:type)::pipe(Map{
  :regular_record_entry => eval-regular-record-entry
  :keyword_record_entry => eval-keyword-record-entry
  :spread => eval-spread
})::call(node)

fn eval-inclusive-range({lhs, rhs}) {
  if rhs {
    return str("new IRange(" eval-expr(lhs) ", " eval-expr(rhs) ")")
  } else {
    return str("new IRangeNoMax(" eval-expr(lhs) ")")
  }
}

fn eval-exclusive-range({lhs, rhs}) {
  if rhs {
    return str("new ERange(" eval-expr(lhs) ", " eval-expr(rhs) ")")
  } else {
    return str("new ERangeNoMax(" eval-expr(lhs) ")")
  }
}

fn eval-multi-decorator({decorators fn_def}) {
  let fn_name = fn_def::pipe(:name resolve_name)
  let decorator_fn_js = decorators
    ::map(fn (node) {
      if node::pipe(:type Set[:id_lookup]) {
        return node::pipe(:name resolve_name)
      } else {
        let {lhs args} = node
        return str("F => "
          eval_expr(lhs)
          "(F"
          args::len()::pipe(Map{0 => ""} _ || ", ")
          args::map_join(eval_expr ", ") ")")
      }
    })
    ::join(", ")
    ::pipe(fn(decorators) = str("compose(" decorators ")"))

  return str("let " fn_name " = " decorator_fn_js "(" eval_expr(fn_def) ")")
}

fn eval-decorator({name: decorator_name, fn_def args}) {
  let fn_name = fn_def::pipe(:name resolve_name)
  decorator_name = resolve-name(decorator_name)
  let fn_def_js = eval_fn(fn_def)
  if args::empty?() {
    return str("let " fn_name " = " decorator_name "(" fn_def_js ");")
  } else {
    return str("let " fn_name " = "
      decorator_name "("
        fn_def_js ", "
        args::map_join(eval_expr ", ")
      ");")
  }
}

fn eval-and-dot({lhs rhs}) = str(eval-expr(lhs) "?." eval-expr(rhs))

fn eval-partial-fn-call({args}) = str("(" args::map-join(eval-expr ", ") ")")

fn eval-partial-obj-dyn-access({expr}) = str("[" eval-expr(expr) "]")

fn eval-regex-lit({value}) = value

let logic-ops = Map{
  "||" => "or",
  "&&" => "and"
}

let all-ops-to-method = math-op-to-method::merge(logic-ops)

fn eval-rhs-based-on-op(op, rhs) {
  if logic-ops::has?(op) {
    return str("() => " eval-expr(rhs))
  } else {
    return eval-expr(rhs)
  }
}

fn eval-op-eq({ lhs, op, rhs }) = 
  str(eval-expr(lhs) " = "
    all-ops-to-method::call(op) ".call("
      eval-expr(lhs) ", "
      eval-rhs-based-on-op(op rhs) ")")

fn eval-prefix-exclusive-range({ expr }) =
  str("new ERangeNoMin(" eval-expr(expr) ")") 

fn eval-raw-dynamic-access({lhs expr}) =
  str(eval-expr(lhs) "[" eval-expr(expr) "]")

fn eval-expr(node) = node::at(:type)::pipe(Map{
  :str => eval-str
  :regex_lit => eval-regex-lit
  :decorator => eval-decorator
  :multi_decorator => eval-multi-decorator
  :keyword => eval-keyword
  :and_dot => eval-and-dot
  :raw_dynamic_access => eval-raw-dynamic-access
  :prefix_exclusive_range => eval-prefix-exclusive-range
  :partial_fn_call => eval-partial-fn-call
  :partial_obj_dyn_access => eval-partial-obj-dyn-access
  :property_lookup => eval-property-lookup
  :id_lookup => eval-id-lookup
  :fn_call => eval-fn-call
  :num => eval_num
  :custom_number_literal => eval-custom-number-literal
  :array => eval-array
  :math_op => eval-math-op
  :double_equals => eval-double-equals
  :not_equals => eval-not-equals
  :not => eval-not
  :fn => eval-fn
  :bind => eval-bind
  :obj_lit => eval-obj-lit
  :bind_this => eval-bind-this
  :dynamic_access => eval-dynamic-access
  :record_lookup => eval-record-lookup
  :triple_equals => eval-triple-equals
  :triple_not_equals => eval-triple-not-equals
  :spread => eval-spread
  :is => eval-is
  :and_and => eval-and-and
  :or_or => eval-or-or
  :nullish => eval-nullish
  :snd_assign => eval-snd-assign
  :await => eval-await
  :yield => eval-yield
  :paren_expr => eval-paren-expr
  :unapplied_math_op => eval-unapplied-math-op
  :unapplied_and_and => eval-unapplied-and-and
  :unapplied_or_or => eval-unapplied-or-or
  :unapplied_nullish => eval-unapplied-nullish
  :inclusive_range => eval-inclusive-range
  :exclusive_range => eval-exclusive-range
  :op_eq => eval-op-eq
})::call(node)

fn eval-return({expr}) {
  if expr {  
    return str("return " eval-expr(expr))
  } else {
    return "return"
  }
}

fn eval-protocol({name}) = str("const " resolve-name(name) " = Symbol(\"" name "\")")

fn eval-impl-for({proto_expr constructor expr}) =
  str(constructor ".prototype[" eval-expr(proto_expr) "] = " eval_expr(expr))

fn eval-impl-object({constructor expr}) = str(constructor ".prototype = " eval-expr(expr))

fn eval-define-for({proto_expr src_expr expr}) =
  str(eval-expr(src_expr) "[" eval-expr(proto_expr) "] = " eval-expr(expr))

fn eval-for-loop({is_await? assign_expr iterable_expr body}) = 
  str("for "
      (is_await? && "await ")
      " (let " eval-assign-expr(assign_expr) " of "
      eval-expr(iterable_expr) ") {\n"
        eval-ast(body) "\n"
      "}")

fn eval-id-assign({name, expr}) =
  str(resolve-name(name) " = " eval-expr(expr))

fn eval-while-loop({test_expr body}) =
  str("while (" eval-expr(test_expr) ") {\n"
      eval-ast(body) "\n"
      "}")

fn eval-loop({body}) =
  str("while (true) {\n"
      eval-ast(body) "\n"
      "}")

fn eval-continue() = "continue"

fn eval-break() = "break"

fn eval-try(node) {
  let body_js = node::at(:body)::pipe(eval_ast)
  let catch_js = ""
  let finally_js = ""
  if node::has?(:catch) {
    let {name, body} = node::at(:catch)
    catch_js = str(" catch (" name ") {\n" eval_ast(body) "\n}")
  }
  if node::has?(:finally) {
    let {body} = node::at(:finally)
    finally_js = str(" finally {\n" eval_ast(body) "\n}")
  }
  return str("try {\n" body_js "\n" "}" catch_js finally_js)
}

fn get-deconstructed-obj-entry-name(node) =
  Map{:obj_reg_entry => :name
      :obj_entry_rename => :old_name}
    ::at(node::at(:type))
    ::pipe(node)

fn get-deconstructed-array-entry-name(node) =
  Map{:id_assign => :name}
    ::at(node::at(:type))
    ::pipe(node)

fn eval-import-deconstruction-entry(node) = node::pipe(:type Map{
  :obj_reg_entry => _::pipe(:name resolve-name)
  :obj_entry_rename => fn ({old_name new_name}) =
    str(resolve-name(old_name) " as " resolve-name(new_name))
})::call(node)

fn eval-import-deconstruction-expr({entries}) =
  str("{" entries::map-join(eval-import-deconstruction-entry ", ") "}")

fn eval-import-assign-exprs(node) = node::pipe(:type Map{
  :id_assign => eval-id-assign-name
  :object_deconstruction => eval-import-deconstruction-expr
  :assign_all_as => eval-assign-all-as
})::call(node)

fn eval-import({assign_exprs, path}) =
  str("import "
    assign_exprs::map-join(eval-import-assign-exprs, ", ")
    " from \"" path.value.slice(1, -1) "\"")

fn eval-export({statement}) =
  str("export " eval-statement(statement))

fn eval-export-default({expr}) =
  str("export default " eval-expr(expr))

fn eval-export-all({path}) =
  str("export * from " path)

fn eval-label({label_name, statement}) =
  str(label_name ": " eval-statement(statement))

fn eval-direct-import({path}) =
  str("import " path)

fn eval-statement(node) = node::at(:type)::pipe(Map{
  :label => eval-label  
  :if => eval-if
  :direct_import => eval-direct-import
  :import => eval-import
  :export => eval-export
  :export_default => eval-export-default
  :export_all => eval-export-all
  :let => eval-let
  :if_let => eval-if-let
  :return => eval-return
  :protocol_def => eval-protocol
  :impl_for => eval-impl-for
  :impl_object => eval-impl-object
  :define_for => eval-define-for
  :for_loop => eval-for-loop
  :id_assign => eval_id_assign
  :while_loop => eval-while-loop
  :loop => eval-loop
  :while_let_loop => eval-while-let-loop
  :continue => eval-continue
  :break => eval-break
  :try => eval-try
})
  ::pipe(fn(f) {
    if f { return compose(f _ + ";") }
    else { return eval-expr }
  })::call(node)

export fn eval-ast(ast) = ast::map-join(eval-statement "\n")

export fn lex-and-parse(string) = lexer::call(string)
  ::pipe(fn(tokens) = CollectionView[tokens, 0])
  ::pipe(parse)

export fn compile(string) = lexer::call(string)
  ::pipe(fn(tokens) = CollectionView[tokens, 0])
  ::pipe(parse)
  ::pipe(eval-ast)

fn compile-file(src-file-name, out-name) {
  let src = Deno.readTextFileSync(src-file-name)
  Deno.writeTextFile(out-name, compile(src))
}

fn compile-file-and-prelude(src-file-name, out-name, prelude-src) {
  let prelude = Deno.readTextFileSync("./src/std/js_prelude.js")
  prelude = prelude + compile(Deno.readTextFileSync(prelude_src))
  let src = Deno.readTextFileSync(src_file_name)
  Deno.writeTextFile(out_name, prelude + compile(src))
}

if globalThis.Deno && Deno.args::not_empty?() {
  let src_file_name = Deno.args[0]
  let out_name = Deno.args[1]
  let prelude_src = "./src/std/prelude.coil"

  if Deno.args[2] == "-w" {
    let watcher = Deno.watchFs([src_file_name, prelude_src])
    for await event of watcher {
      if event.kind != "modify" { continue }
      console.log("Rebuilding...")
      try {
        compile_file_and_prelude(src_file_name, out_name, prelude_src)
      } catch e {
        console.error("Compile Failed", e)
      }
    }
  } else if Deno.args[2] == "-no-prelude" {
    compile_file(src_file_name, out_name)
  } else {
    compile_file_and_prelude(src_file_name, out_name, prelude_src)
  } 
}
