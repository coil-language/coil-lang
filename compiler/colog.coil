def str(...args) =
  args.map(|arg| arg:toString()).join("")

protocol lex
def pass() end

def String:prototype.lex(string)
  if string:startsWith(this)
    return this
  end
end

def RegExp:prototype.lex(string)
  if let [value] = string:match(this)
    return value
  end
end

def Lexer(@patterns) end

def Lexer:prototype.invoke(string)
  let idx = 0
  def rest_of_string() = string:slice(idx)
  let tokens = []
  while rest_of_string():trim() != ""
    idx = idx + rest_of_string().until(Set[" " "\n"] !_).count()
    let found = false
    for [pattern kind] of this:patterns
      if let value = pattern.lex(rest_of_string())
        idx = idx + value.len()
        if kind != pass
          tokens:push({kind: kind, value: value})
        end
        found = true
        break
      end
    end
    if !found and rest_of_string():trim():length > 0
      tokens.log()
      return console:error("NONE FOUND")
    end
  end
  return tokens
end

let lexer = Lexer{
  "fact" => :fact
  "?" => :question_mark
  "." => :dot
  "," => pass
  "(" => :open_p
  ")" => :close_p
  "{" => :open_b
  "}" => :close_b
  "=" => :equal_sign
  /^\"(.*)\"/ => :string
  /^[0-9]+/ => :number
  /^[a-zA-Z_0-9]+/ => :id
  /^:[a-zA-Z_0-9\+\-\*\!\@\#\$\%\^\&\<\>\=]+/ => :id
}

protocol parse

def Parser(...@instructions) end
def Parser:prototype.parse(parse_result) = 
  this:instructions.reduce(
    |result parser| parser.parse(result),
    parse_result
  )

def DefKind(@kind) end
def DefKind:prototype.parse([tokens _result]) =
  [tokens {kind: this:kind}]

def Then(@parser @name) end
def Then:prototype.parse([tokens result])
  let [new_tokens, new_result] = this:parser.parse([tokens nil])
  return [new_tokens {...result, this:name => new_result}]
end

def One(@kind @name) end
def One:prototype.parse([tokens result])
  if let token = tokens.first()
    if token:kind != this:kind
      panic!("Expected :" this:kind " got :" token:kind)
    else
      return [tokens:slice(1)
       {...result, this:name => token:value}]
    end
  end
end

def Chomp(...@kinds) end
def Chomp:prototype.parse([tokens result])
  for [token kind i] of tokens.zip(this:kinds 0..)
    if token:kind != kind
      panic!("Expected :" kind " got :" token:kind)
    end
  end
  return [tokens:slice(this:kinds:length) result]
end

def Until(@end_token @parser @kind) end
def Until:prototype.parse([tokens result])
  let exprs = []
  while tokens.first():kind != this:end_token
    if let [new_tokens expr] = this:parser.parse([tokens nil])
      tokens = new_tokens
      exprs:push(expr)
    else
      break
    end
  end
  return [tokens {...result, this:kind => exprs}]
end

def Function:prototype.parse([tokens result]) = this(tokens)

protocol can_parse?

def Keyword:prototype.can_parse?([{kind}]) = this == kind

def Set:prototype.can_parse?(tokens) =
  this.any?(|cond| cond.can_parse?(tokens))

def _.can_parse?([]) = true

def Array:prototype.can_parse?(tokens)
  if this.len() > tokens.len()
    return false
  else
    return this.zip(tokens).all?(|[pattern token]| pattern.can_parse?([token]))
  end
end

def ParseMap(@entries) end
def ParseMap:prototype.(Symbol:iterator) =
  this:entries.(Symbol:iterator)()

def ParseMap:prototype.parse([tokens result])
  if tokens.empty?()
    return
  else
    for [pattern parser] of this:entries
      if pattern.can_parse?(tokens)
        return parser.parse([tokens nil])
      end
    end
  end
end

let parse_keyword = Parser[
  DefKind[:keyword]
  One[:id :name]
]

let parse_string = Parser[
  DefKind[:string]  
  One[:string :value]
]

let parse_number = Parser[
  DefKind[:number]  
  One[:number :value]
]

let parse_variable = Parser[
  DefKind[:variable]
  Chomp[:question_mark]
  One[:id :name]
]

def parse_key_value_entry(tokens) = Parser[
  DefKind[:key_value_entry]
  One[:id :key_name]
  Chomp[:equal_sign]
  Then[parse_datum :value]
].parse([tokens nil])

let parse_record_entry = ParseMap{
  :id => parse_key_value_entry
  :question_mark => parse_variable
}

let parse_record = Parser[
  DefKind[:record]
  Chomp[:open_b]
  Until[:close_b parse_record_entry :entries]
  Chomp[:close_b]
]

let parse_datum = ParseMap{
  :id => parse_keyword
  :string => parse_string
  :number => parse_number
  :question_mark => parse_variable
  :open_b => parse_record
}

let parse_fact = Parser[
  DefKind[:fact]
  Chomp[:fact]
  One[:id :name]
  Chomp[:open_p]
  Until[:close_p parse_datum :args]
  Chomp[:close_p :dot]
]

let parse_query = Parser[
  DefKind[:query]
  Chomp[:question_mark]
  One[:id :fact_name]
  Chomp[:open_p]
  Until[:close_p parse_datum :args]
  Chomp[:close_p :dot]
]

let parse_statement = ParseMap{
  :fact => parse_fact
  :question_mark => parse_query
}

def parse_ast(tokens)
  let ast = []
  while !tokens.empty?()
    let [new_tokens node] = parse_statement.parse([tokens nil])
    tokens = new_tokens
    ast:push(node)
  end
  return ast
end

def Var(@name) end

let ? = Proxy[{} {def :get(_ name) = Var[name]}]

protocol encode_type

def ObjectLiteral:prototype.encode_type() =
  this:kind.encode_type(this)

def :key_value_entry.encode_type({key_name, value}) =
  str("[" key_name "=" value.encode_type() "]")

def :string.encode_type() = "string"

def :number.encode_type() = "number"

def :record.encode_type({entries}) =
  str("record"
    entries
      .:sort(|a b| a:key_name:localeCompare(b:key_name))
      .map(|item| item.encode_type()).join(""))

def Array:prototype.encode_type() =
  str("array["
    this.map(|item| item.encode_type())
      .join(",")
      "]")

protocol run
protocol val

def ObjectLiteral:prototype.run(db) =
  this:kind.run(db this)

def Array:prototype.run(db)
  for node of this
    db = node.run(db)
  end
  return db
end

def :fact.run(db {name args})
  if !db(name)
    db:set(name, Map{})
  end
  let name_table = db(name)
  let args_type = args.encode_type()
  if let coll = name_table(args_type)
    coll:push(args:map(|item| item.val()))
  else
    name_table:set(
      args_type,
      [args:map(|item| item.val())]
    )
  end
  return db
end
  -- [...db {name: name, args: args:map(|item| item.val())}]

protocol match?

def ObjectLiteral:prototype.match?(fact) =
  this:kind.match?(this fact)

def :variable.match?(self fact) = true

def :record.match?({entries} fact)
  if entries.len() != fact.len()
    return false
  else
    -- TODO: order entries
    for [left [key val]] of entries.zip(fact)
      if left:kind == :variable
        if left:name != key
          return false
        end
      else if left:kind == :key_value_entry
        if left:key_name != key
          return false
        else if !left:value.match?(val)
          return false
        end
      end
    end
  end
end

def :number.match?({value} fact) =
  Number(value) == fact

protocol unify

def ObjectLiteral:prototype.unify(fact) =
  this:kind.unify(this fact)

def :variable.unify({name}, fact) =
  [name fact]

def :number.unify(self fact) = nil

def :string.unify(self fact) = nil

def :record.unify({entries} fact)
  let out = []
  for [entry [key val]] of entries.zip(fact)
    -- TODO: do something here
  end
  return out
end

def :query.run(db {fact_name args}) =
  db.filter(:name Set[fact_name])
    .filter(|tuple| args
      .zip(tuple:args)
      .all?(|[query found]| query.match?(found))
    )
    .map(|tuple| args
      .zip(tuple:args)
      .flat_map(|[query found]| {
        if query:kind == :variable
          return Map{query:name => found}
        end
      })
      .compact()
      .into(Map{})
    )

def ObjectLiteral:prototype.val(db) =
  this:kind.val(this)

def :string.val({value}) = value:slice(1, -1)

def :number.val({value}) = Number(value)

def :key_value_entry.val({key_name value}) =
  [key_name, value.val()]

def :record.val({entries}) =
  entries.map(|item| item.val()).into(Map[])

Deno:readTextFileSync("./test.logi")
  .pipe(lexer parse_ast)
  .run(Map{})
  -- .into([])
  -- .log()

def CallMap(@entries) end
def CallMap:prototype.(Symbol:iterator) = this:entries.(Symbol:iterator)()
def CallMap:prototype.invoke(item) = this:entries
  .find(|[invokable]| invokable(item))
  .pipe(1)

let db = {
  "person" => {
    "[{age,name}]" => CallMap{
      0..50 => CallMap{
        _.pipe(:length 0..50) => [{name: "marcelle", age: 10} {name: "jack", age: 11}]
        _.pipe(:length 50..100) => []
        _.pipe(:length 100..) => []
      }
      50..100 => CallMap{
        _.pipe(:length 10..50) => []
        _.pipe(:length 50..100) => []
        _.pipe(:length 100..) => []
      }
      100.. => CallMap{}
    }
  }
}

def QueryImpl(@tbl_name @entries) end
let Query = Proxy[{} {
  def :get(_ tbl_name) = {
    def Meta:from_entries(entries) = QueryImpl[tbl_name entries
      .:sort(|[a] [b]| a:toString():localeCompare(b:toString()))]
  }
}]

protocol match_extract

def CallMap:prototype.+(call_map) = CallMap{...this, ...call_map}

def CallMap:prototype.match_extract(item)
  if item instanceof Var
    return this.map(1)
      .skip(1)
      .reduce(|acc, item| acc + item, this:entries(0)(1))
  else
    return this(item)
  end
end

def QueryImpl:prototype:shape() =
  this:entries
    .map(0 |item| item:toString())
    .join(",")
    .pipe(|csv| str("[{" csv "}]"))

def Number:prototype.match?(query) =
  query instanceof Var or query == this

def ObjectLiteral:prototype.match?(query)
  for [key, sub_query] of query:entries
    if !this.has?(key)
      return false
    else if sub_query instanceof Var
      continue
    else if !this.key.match?(sub_query)
      return false
    end
  end
  return true
end

let query = Query:person{name: ?:name, age: 11}

let tbl = db(query:tbl_name)(query:shape())
let bucket = query:entries
  .reduce(|acc [_k val]| acc.match_extract(val) tbl)

bucket.find(|item| item.match?(query))
  .log()
