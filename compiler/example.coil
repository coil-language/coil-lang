fn str(...args) =
  args.map(|arg| arg:toString()).join("")

protocol lex

fn String:prototype.lex(string)
  if string:startsWith(this)
    return this
  end
end

fn RegExp:prototype.lex(string)
  if let [value] = string:match(this)
    return value
  end
end

fn Lexer(@patterns) end

fn Lexer:prototype.invoke(string)
  let idx = 0
  fn rest_of_string() = string:slice(idx)
  let tokens = []
  while rest_of_string():trim() != ""
    idx = idx + rest_of_string().until(Set[" " "\n"] !_).count()
    let found = false
    for [pattern kind] of this:patterns
      if let value = pattern.lex(rest_of_string())
        idx = idx + value.len()
        tokens:push({kind: kind, value: value})
        found = true
        break
      end
    end
    if !found and rest_of_string():trim():length > 0
      tokens.log()
      return console:error("NONE FOUND")
    end
  end
  return tokens
end

let lexer = Lexer{
  "fact" => :fact
  "?" => :question_mark
  "." => :dot
  "," => :comma
  "(" => :open_p
  ")" => :close_p
  /^\"(.*)\"/ => :string
  /^[0-9]+/ => :number
  /^[a-zA-Z_0-9]+/ => :id
  /^:[a-zA-Z_0-9\+\-\*\!\@\#\$\%\^\&\<\>\=]+/ => :id
}

protocol parse

fn Parser(...@instructions) end
fn Parser:prototype.parse(parse_result) = 
  this:instructions.reduce(
    |result parser| parser.parse(result),
    parse_result
  )

fn DefKind(@kind) end
fn DefKind:prototype.parse([tokens _result]) =
  [tokens {kind: this:kind}]

fn One(@kind @name) end
fn One:prototype.parse([tokens result])
  if let token = tokens.first()
    if token:kind != this:kind
      panic!("Expected :" this:kind " got :" token:kind)
    else
      return [tokens:slice(1)
       {...result, this:name => token:value}]
    end
  end
end

fn Chomp(...@kinds) end
fn Chomp:prototype.parse([tokens result])
  for [token kind i] of tokens.zip(this:kinds 0..)
    if token:kind != kind
      panic!("Expected :" kind " got :" token:kind)
    end
  end
  return [tokens:slice(this:kinds:length) result]
end

fn Chomp:optional(@kind) end
fn Chomp:optional:prototype.parse([tokens result])
  if tokens.first():kind != this:kind
    return [tokens result]
  else
    return [tokens:slice(1) result]
  end
end

fn Until(@end_token @parser @kind) end
fn Until:prototype.parse([tokens result])
  let exprs = []
  while tokens.first():kind != this:end_token
    if let [new_tokens expr] = this:parser.parse([tokens nil])
      tokens = new_tokens
      exprs:push(expr)
    else
      break
    end
  end
  return [tokens {...result, this:kind => exprs}]
end

protocol can_parse?

fn Keyword:prototype.can_parse?([{kind}]) = this == kind

fn Set:prototype.can_parse?(tokens) =
  this.any?(|cond| cond.can_parse?(tokens))

fn _.can_parse?([]) = true

fn Array:prototype.can_parse?(tokens)
  if this.len() > tokens.len()
    return false
  else
    return this.zip(tokens).all?(|[pattern token]| pattern.can_parse?([token]))
  end
end

fn ParseMap(@entries) end
fn ParseMap:prototype.(Symbol:iterator) =
  this:entries.(Symbol:iterator)()

fn ParseMap:prototype.parse([tokens result])
  if tokens.empty?()
    return
  else
    for [pattern parser] of this:entries
      if pattern.can_parse?(tokens)
        return parser.parse([tokens nil])
      end
    end
  end
end

let parse_keyword = Parser[
  DefKind[:keyword]
  One[:id :name]
]

let parse_string = Parser[
  DefKind[:string]  
  One[:string :value]
]

let parse_number = Parser[
  DefKind[:number]  
  One[:number :value]
]

let parse_datum = ParseMap{
  :id => parse_keyword
  :string => parse_string
  :number => parse_number
}

let parse_fact = Parser[
  DefKind[:fact]
  Chomp[:fact]
  One[:id :name]
  Chomp[:open_p]
  Until[:close_p
        Parser[parse_datum Chomp:optional[:comma]]
        :args]
  Chomp[:close_p :dot]
]

let parse_variable = Parser[
  DefKind[:variable]
  Chomp[:question_mark]
  One[:id :name]
]

let parse_query_arg = ParseMap{
  ...parse_datum
  :question_mark => parse_variable
}

let parse_query = Parser[
  DefKind[:query]
  Chomp[:question_mark]
  One[:id :fact_name]
  Chomp[:open_p]
  Until[:close_p
        Parser[parse_query_arg Chomp:optional[:comma]]
        :args]
  Chomp[:close_p :dot]
]

let parse_statement = ParseMap{
  :fact => parse_fact
  :question_mark => parse_query
}

fn parse_ast(tokens)
  let ast = []
  while !tokens.empty?()
    let [new_tokens node] = parse_statement.parse([tokens nil])
    tokens = new_tokens
    ast:push(node)
  end
  return ast
end

let tokens = Deno:readTextFileSync("./test.logi")
  .pipe(lexer parse_ast)

protocol run
protocol val

fn ObjectLiteral:prototype.run(db) =
  this:kind.run(db this)

fn Array:prototype.run(db)
  for node of this
    db = node.run(db)
  end
  return db
end

fn :fact.run(db {name args}) =
  [...db {name: name, args: args:map(|item| item.val())}]

fn* :query.run(db {fact_name args})
  for tuple of db.filter(:name Set[fact_name])
    let obj = {}
    for [arg i] of args.zip(0..)
      obj.(arg:name) = tuple:args.i
    end
    yield obj
  end
end

fn ObjectLiteral:prototype.val(db) =
  this:kind.val(this)

fn :string.val({value}) = value:slice(1, -1)

fn :number.val({value}) = Number(value)

tokens
  .run([])
  .take(2).into([])
  .log()
