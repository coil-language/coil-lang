// CollectionView is an efficent data structure to use
// the same old Collection protocol methods, without
// copying the entire array each time you ::skip(1)
// which happens a lot during parsing.
let CollectionView = ~Struct["CollectionView" :collection :idx]

// Its only partially implemented right now because most use-cases
// don't require the complete collections api.
impl OrderedCollection for CollectionView = {
  fn first() = this.collection::at(this.idx)
  fn last() = this.collection::last()
  fn skip(n) = new CollectionView(this.collection, this.idx + n)
}

impl Symbol.iterator for CollectionView = fn*() {
  for elem of this.collection {
    yield elem
  }
}

impl Collection for CollectionView = {
  fn at(idx) = this.collection::at(this.idx + idx)
  fn len() = this.collection::len() - this.idx
  fn empty?() = this::len() == 0
}

impl Printable for CollectionView = fn() = this.collection::skip(this.idx)

let Lexer = ~DefRecord[:entries]

fn pass() {}
fn newline() {}

impl Call for Lexer = fn(str) {
  let tokens = []  
  let index = 0
  fn rest_of_string() = str.slice(index)

  fn scan() {
    let result = rest_of_string()["match"](this)
    if !result || result.index != 0 { return false }
    index = index + result[0].length
    return result[0]
  }

  let line = 1
  let col = 1
  while rest_of_string() != "" {
    let found = false  
    for [pattern type] of this.entries {
      if let value = pattern::scan() {
        if type == newline {
          line = line + 1
          col = 1
          found = true
          break
        }
        if type != pass {
          tokens.push({type, value, line, col})
          col = col + value::len()
          found = true
          break
        } else {
          col = col + value::len()
          found = true
          break
        }
      }
    }
    assert! found
  }

  return tokens
}

let lexer = ~Lexer{
  /^\n/ => newline
  /^\s+/ => pass
  /^\/\/.*/ => pass
  /^\,/ => pass
  /^\;/ => pass
  /^#/ => :hash
  /^\~/ => :tilde
  /^if\b/ => :if
  /^match\b/ => :match
  /^is\b/ => :is
  /^unless\b/ => :unless
  /^else\b/ => :else
  /^return\b/ => :return
  /^import\b/ => :import
  /^export\b/ => :export
  /^default\b/ => :default
  /^from\b/ => :from
  /^let\b/ => :let
  /^protocol\b/ => :protocol
  /^for\b/ => :for
  /^try\b/ => :try
  /^catch\b/ => :catch
  /^finally\b/ => :finally
  /^while\b/ => :while
  /^loop\b/ => :loop
  /^continue\b/ => :continue
  /^break\b/ => :break
  /^of\b/ => :of
  /^impl\b/ => :impl
  /^define\b/ => :define
  /^yield\b/ => :yield
  /^async\b/ => :async
  /^await\b/ => :await
  /^assert\!/ => :assert!
  /^new\b/ => :new
  /^keyof\b/ => :keyof
  /^\=\>/ => :arrow
  /^\@/ => :at
  /^\&\&/ => :and_and
  /^\|\|/ => :or_or
  /^\=\=\=/ => :triple_eq
  /^\!\=\=/ => :triple_not_eq
  /^\=\=/ => :double_eq
  /^\!\=/ => :not_eq
  /^\!/ => :bang
  /^\=/ => :eq
  /^fn\b/ => :fn
  /^\{/ => :open_b
  /^\}/ => :close_b
  /^\(/ => :open_p
  /^\)/ => :close_p
  /^[\-\+]?\d+n/ => :big_int
  /^[\-\+]?(\d*\.)?\d+/ => :num
  /^\.\.\./ => :dot_dot_dot
  /^\.\./ => :dot_dot
  /^\./ => :dot
  /^\/.*\/[a-z]?/ => :regex_lit
  /^\>\=/ => :gt_eq
  /^\<\=/ => :lt_eq
  /^\>/ => :gt
  /^\</ => :lt
  /^\+/ => :plus
  /^\%/ => :mod
  /^\-/ => :minus
  /^\*\*/ => :pow
  /^\*/ => :times
  /^\&/ => :single_and
  /^\:\:/ => :double_colon
  /^\:[a-zA-Z_\?\!\$0-9]+/ => :keyword
  /^\:/ => :colon
  /^\// => :div
  /^\[/ => :open_sq
  /^\]/ => :close_sq
  /^\"([^\\\"]|\\.)*\"/s => :string_lit
  /^[a-zA-Z_\?\!\$0-9]+/ => :id
}

fn ParseError(expected_token_type, actual_token) {
  this.stack = (new Error()).stack
  this.message = str(
    "Expected: " expected_token_type::printable()
    " got " actual_token::at(:type)::printable()
    " @ " actual_token::at(:line)::as_str() ":" actual_token::at(:col)::as_str()
  )
}
ParseError.prototype = new Error()

fn expect_token!(kw) {
  if this::first()::at(:type) != kw {
    raise!(new ParseError(kw, this::first()))
  } else {
    return this
  }
}

fn verify_exists!(parser) {
  if this::nil?() {
    raise!(new Error("Parser Failed - Expected " + parser::printable()))
  } else {
    return this
  }
}

// PARSER MACHINE IMPL

protocol ParseInstruction

let Init = ~DefVector[:expr]
impl ParseInstruction for Init = fn([_expr, tokens]) =
  [this.expr tokens]
impl Printable for Init = fn() = str("Init(" this.expr::printable() ")")

let One = ~DefVector[:kw :as]
impl ParseInstruction for One = fn([expr tokens]) {
  let {value, type} = tokens::expect_token!(this.kw)::first()
  return [expr::merge({[this.as]: value}) tokens::skip(1)]
}
impl Printable for One = fn() = "One(kw: " + this.kw::printable() + ", as: " + this.as::printable() +  ")"

// this is starting to get complex
// maybe we want OptionalOneOf? or something similar.
// OR could take a note from the pattern matching algorithm
// and use ~DefVector[:pattern :parse_fn :as] 
// then for checking this.pattern::matches?(tokens::first()::at(:type))
// not sure at this moment.
let Optional = ~DefVector[:set_or_kw :parse_fn :as]
impl ParseInstruction for Optional = fn([expr tokens]) {  
  if tokens::empty?() { return [expr tokens] }
  let {type} = tokens::first()
  if this.set_or_kw is Keyword && type == this.set_or_kw {
    return ~Then[this.parse_fn, this.as]::parse_step([expr tokens])
  }
  if this.set_or_kw is Set && this.set_or_kw::call(type) {
    return ~Then[this.parse_fn, this.as]::parse_step([expr tokens])
  } else {
    return [expr tokens]
  }
}
impl Printable for Optional = fn() = "Optional(kw: " + this.kw::printable() + ", as: " + this.as::printable() +  ")"

impl ParseInstruction for Function = fn([_expr tokens]) = this(tokens)

let Chomp = ~DefVector[_ :kws]
impl ParseInstruction for Chomp = fn([expr tokens]) {
  // this.kws::zip(tokens)::all!(fn([a b]) = a == b)
  // return [expr tokens::skip(this.kws::len())]
  let i = 0
  for kw of this.kws {
    tokens::skip(i)::expect_token!(kw)
    i = i + 1
  }
  return [expr, tokens::skip(i)]
}
impl Printable for Chomp = fn() = "Chomp(" + this.kws::printable().join(", ") + ")"

let Then = ~DefVector[:parser :kw]
impl ParseInstruction for Then = fn([expr tokens]) {
  let result = this.parser::call(tokens)
  if result::nil?() { return [expr tokens] }
  let [new_expr new_tokens] = result
  if this.kw {
    return [expr::merge({[this.kw]: new_expr}) new_tokens]
  } else {
    return [new_expr new_tokens]
  }
}
impl Printable for Then = fn() = str("Then(" this.parser.name ", " this.kw::printable() ")")

let FMap = ~DefVector[:f]
impl ParseInstruction for FMap = fn([expr tokens]) = [this.f::call(expr) tokens]
impl Printable for FMap = fn() = "Fmap(" + this.f.name + ")"

let Until = ~DefVector[:end_kw :parser :kw]
impl ParseInstruction for Until = fn([expr tokens]) {
  let exprs = []  
  while tokens::first()::at(:type) != this.end_kw {
    let [expr new_tokens] = this.parser::call(tokens)
      ::verify_exists!(this)
    exprs.push(expr)
    tokens = new_tokens
  }
  if this.kw {
    return [expr::merge({[this.kw]: exprs}) tokens]
  } else {
    return [exprs, tokens]
  }
}
impl Printable for Until = fn() = str("Until(end: " this.end_kw::printable() ", f: " this.parser.name ", as: " this.kw::printable() ")")

let Case = ~DefVector[:parse_map :kw]
impl ParseInstruction for Case = fn([expr tokens]) {
  if let [new_expr, new_tokens] = this.parse_map::call(tokens) {
    if this.kw {
      return [expr::merge({[this.kw]: new_expr}), new_tokens]
    } else {
      return [new_expr new_tokens]
    }
  } else {
    console.log(this.tokens::first(), this.parse_map)
    raise!(new Error("Case Parse Failed"))
  }
}
impl Printable for Case = fn() = "Case(" + this.parse_map::printable() + ", as: " + this.kw::printable() + ")"

let Either = ~DefVector[:set :kw]
impl ParseInstruction for Either = fn([expr tokens]) {
  let op = this.set::at(tokens::first()::at(:type))::verify_exists!(this.set)
  let [new_expr, rest] = [tokens::first(), tokens::skip(1)]
  return [expr::merge({[this.kw]: new_expr::at(:value)}), rest]
}
impl Printable for Either = fn() = "Either(" + this.set::printable() + ", as: " + this.kw::printable() + ")"

fn parse_step(result) {
  if !(ParseInstruction keyof this) {
    console.log("This is not parsable:", this::printable())
  }
  return this[ParseInstruction](result)
}

let Parser = ~DefVector[_ :instructions]
impl Printable for Parser = fn() = "~Parser[" + this.instructions::printable().join(", ") + "]"
impl Call for Parser = fn(tokens) =
  this::parse_step([null tokens])

let AbortIf = ~DefVector[:cond_fn]
impl Printable for AbortIf = fn() = "~AbortIf[" + _resolve_keyword_str(this.cond_fn.name) + "]"

impl ParseInstruction for Parser = fn(result) {
  for instruction of this.instructions {
    if instruction is AbortIf {
      if instruction.cond_fn::call(result) {
        return null
      } else {
        continue
      }
    }
    result = instruction::parse_step(result)
  }
  return result
}

let ParseMap = ~DefRecord[:entries]

impl Collection for ParseMap = {
  fn keys() = this.entries::map(first)::as_set()
}

impl Call for ParseMap = fn(tokens, ...args) {
  if tokens::empty?() { return null }

  for [pattern parser] of this.entries {
    if pattern == _ {
      return parser::call(tokens, ...args)
    }
    if pattern is Set && pattern::call(tokens::first()::at(:type)) {
      return parser::call(tokens, ...args)
    }
    if pattern is Array && pattern::all_with_index?(fn(p, i) {
      if i >= tokens::len() { return false }
      let type = tokens::at(i)::at(:type)
      if p is Keyword { return p == type }
      if p is Set { return p::has?(type) }
      return false
    }) {
      return parser::call(tokens, ...args)
    }
    if pattern is Keyword && pattern == tokens::first()::at(:type) {
      return parser::call(tokens, ...args)
    }
  }
}

// COIL PARSER START

let math_ops = #{:mod :plus :minus :times :pow :div}
let comparison_ops = #{:lt :gt :lt_eq :gt_eq}
let all_math_ops = math_ops::merge(comparison_ops)

fn parse_double_eq(tokens lhs) = ~Parser[
  ~Init[{type: :double_equals, lhs}]
  ~Chomp[:double_eq]
  ~Then[parse_1_2_expr :rhs]
]::call(tokens)

fn parse_not_eq(tokens lhs) = ~Parser[
  ~Init[{type: :not_equals, lhs}]
  ~Chomp[:not_eq]
  ~Then[parse_1_2_expr :rhs]
]::call(tokens)

fn parse_triple_eq(tokens lhs) = ~Parser[
  ~Init[{type: :triple_equals, lhs}]
  ~Chomp[:triple_eq]
  ~Then[parse_1_2_expr :rhs]
]::call(tokens)

fn parse_triple_not_eq(tokens lhs) = ~Parser[
  ~Init[{type: :triple_not_equals, lhs}]
  ~Chomp[:triple_not_eq]
  ~Then[parse_1_2_expr :rhs]
]::call(tokens)

fn parse_and_and(tokens lhs) = ~Parser[
  ~Init[{type: :and_and, lhs}]
  ~Chomp[:and_and]
  ~Then[parse_expr :rhs]
]::call(tokens)

fn parse_or_or(tokens lhs) = ~Parser[
  ~Init[{type: :or_or, lhs}]
  ~Chomp[:or_or]
  ~Then[parse_expr :rhs]
]::call(tokens)

fn parse_keyof(tokens lhs) = ~Parser[
  ~Init[{type: :keyof, lhs}]
  ~Chomp[:keyof]
  ~Then[parse_expr :rhs]
]::call(tokens)

fn parse_comparison_op(tokens lhs) = ~Parser[
  ~Init[{type: :math_op, lhs}]
  ~Either[comparison_ops :op]
  ~Then[parse_1_2_expr :rhs]
]::call(tokens)

fn parse_third_expr_step(tokens, lhs) = ~ParseMap{
  :double_eq => parse_double_eq
  :triple_eq => parse_triple_eq
  :triple_not_eq => parse_triple_not_eq
  :not_eq => parse_not_eq
  :and_and => parse_and_and
  :or_or => parse_or_or
  :keyof => parse_keyof
  comparison_ops => parse_comparison_op
}::call(tokens, lhs)

fn parse_third_expr([lhs tokens]) {  
  while let [new_lhs rest] = parse_third_expr_step(tokens, lhs) {
    lhs = new_lhs
    tokens = rest
  }
  return [lhs tokens]
}

fn parse_partial_obj_dyn_access(tokens) = ~Parser[
  ~Init[{type: :partial_obj_dyn_access}]
  ~Chomp[:open_sq]
  ~Then[parse_expr :expr]
  ~Chomp[:close_sq]
]::call(tokens)

fn parse_partial_fn_call(tokens) = ~Parser[
  ~Init[{type: :partial_fn_call}]
  ~Chomp[:open_p]
  ~Until[:close_p parse_expr :args]
  ~Chomp[:close_p]
]::call(tokens)

fn parse_and_dot(tokens, lhs) = ~Parser[  
  ~Init[{type: :and_dot, lhs}]
  ~Chomp[:single_and :dot]
  ~Case[~ParseMap{
    :id => parse_id,
    :open_sq => parse_partial_obj_dyn_access
    :open_p => parse_partial_fn_call
  } :rhs]
]::call(tokens)

fn parse_dot(tokens, lhs) = ~Parser[
  ~Init[{type: :property_lookup, lhs}]
  ~Chomp[:dot]
  ~One[:id :property]
]::call(tokens)

fn parse_infix_bind(tokens lhs) = ~Parser[
  ~Init[{type: :bind, lhs}]
  ~Chomp[:double_colon]
  ~Case[~ParseMap{
    :id => parse_id
    :fn => parse_fn
    [:tilde :id :open_b] => parse_record_syntax
    all_math_ops => parse_unapplied_math_op
    :open_p => parse_paren_expr
  } :expr]
]::call(tokens)

fn parse_is(tokens, lhs) = ~Parser[
  ~Init[{type: :is, lhs}]
  ~Chomp[:is]
  ~Then[parse_1_2_expr, :rhs]
]::call(tokens)

fn parse_snd_assign(tokens, lhs) = ~Parser[
  ~Init[{type: :snd_assign, lhs}]
  ~Chomp[:eq]
  ~Then[parse_expr :rhs]
]::call(tokens)

fn parse_math_op(tokens lhs) = ~Parser[
  ~Init[{type: :math_op, lhs}]
  ~Either[math_ops :op]
  ~Then[parse_1_2_expr :rhs]
]::call(tokens)

fn not_adjacent?([_expr tokens]) {
  let current = tokens::first()
  let previous = tokens.collection::at(tokens.idx - 1)
  if current.line != previous.line { return true }
  let end_of_prev_token = previous.col + previous.value.length
  return (current.col - end_of_prev_token) >= 1
}

fn parse_adjacent_1_2_expr(tokens) = ~Parser[
  ~AbortIf[not_adjacent?]
  ~Then[parse_1_2_expr]
]::call(tokens)

fn parse_inclusive_range(tokens lhs) = ~Parser[
  ~AbortIf[not_adjacent?]
  ~Init[{type: :inclusive_range, lhs}]
  ~Chomp[:dot_dot]
  ~Optional[SINGLE_EXPR_PARSE_MAP::keys() parse_adjacent_1_2_expr :rhs]
]::call(tokens)

fn parse_exclusive_range(tokens lhs) = ~Parser[
  ~AbortIf[not_adjacent?]
  ~Init[{type: :exclusive_range, lhs}]
  ~Chomp[:dot_dot_dot]
  ~Optional[SINGLE_EXPR_PARSE_MAP::keys() parse_adjacent_1_2_expr :rhs]
]::call(tokens)

fn parse_fn_call(tokens lhs) = ~Parser[
  ~AbortIf[not_adjacent?]
  ~Init[{type: :fn_call, lhs}]
  ~Chomp[:open_p]
  ~Until[:close_p parse_expr :args]
  ~Chomp[:close_p]
]::call(tokens)

fn parse_object_dynamic_access(tokens lhs) = ~Parser[
  ~AbortIf[not_adjacent?]
  ~Init[{type: :dynamic_access, lhs}]
  ~Chomp[:open_sq]
  ~Then[parse_expr :expr]
  ~Chomp[:close_sq]
]::call(tokens)

let assignable_ops = math_ops::concat([:or_or, :and_and])

fn parse_op_eq(tokens lhs) = ~Parser[
  ~Init[{type: :op_eq, lhs}]  
  ~Either[assignable_ops :op]
  ~Chomp[:eq]
  ~Then[parse_expr :rhs]
]::call(tokens)

fn parse_snd_expr_step(tokens, lhs) = ~ParseMap{
  :single_and => parse_and_dot
  :dot => parse_dot
  :dot_dot => parse_inclusive_range
  :dot_dot_dot => parse_exclusive_range
  :open_p => parse_fn_call
  :double_colon => parse_infix_bind
  :open_sq => parse_object_dynamic_access
  :is => parse_is
  :eq => parse_snd_assign
  [assignable_ops :eq] => parse_op_eq
  math_ops => parse_math_op
}::call(tokens, lhs)

fn parse_snd_expr([lhs tokens]) {  
  while let [new_lhs rest] = parse_snd_expr_step(tokens, lhs) {
    lhs = new_lhs
    tokens = rest
  }
  return [lhs tokens]
}

fn parse_call_expr(tokens) = ~Parser[
  ~Chomp[:open_p]
  ~Until[:close_p parse_expr]
  ~Chomp[:close_p]
]::call(tokens)

fn parse_decorator(tokens) = ~Parser[
  ~Init[{type: :decorator}]
  ~Chomp[:at]
  ~One[:id :name]
  ~Optional[:open_p parse_call_expr :args]
  ~Then[parse_fn :fn_def]
]::call(tokens)

let parse_regex = ~Parser[
  ~Init[{type: :regex_lit}]
  ~One[:regex_lit :value]
]

let parse_str = ~Parser[
  ~Init[{type: :str}]
  ~One[:string_lit :value]
]

let parse_id = ~Parser[
  ~Init[{type: :id_lookup}]
  ~One[:id :name]
]

fn parse_reg_obj_entry(tokens) = ~Parser[
  ~Init[{type: :reg_obj_entry}]
  ~Either[#{:id :num} :key]
  ~Chomp[:colon]
  ~Then[parse_expr :value]
]::call(tokens)

let parse_obj_shorthand_entry = ~Parser[
  ~Init[{type: :obj_shorthand_entry}]
  ~One[:id :id]
]

fn parse_dynamic_obj_entry(tokens) = ~Parser[
  ~Init[{type: :dynamic_obj_entry}]
  ~Chomp[:open_sq]
  ~Then[parse_expr :key_expr]
  ~Chomp[:close_sq :colon]
  ~Then[parse_expr :value]
]::call(tokens)

fn parse_spread_obj_entry(tokens) = ~Parser[
  ~Init[{type: :spread_obj_entry}]
  ~Chomp[:dot_dot_dot]
  ~Then[parse_expr :expr]
]::call(tokens)

fn parse_obj_entry(tokens) = ~ParseMap{
  :open_sq => parse_dynamic_obj_entry
  :dot_dot_dot => parse_spread_obj_entry
  :fn => parse_fn
  [:async :fn] => parse_fn
  [:id :colon] => parse_reg_obj_entry
  [:num :colon] => parse_reg_obj_entry
  :id => parse_obj_shorthand_entry
}::call(tokens)

fn parse_obj(tokens) = ~Parser[
  ~Init[{type: :obj_lit}]
  ~Chomp[:open_b]
  ~Until[:close_b parse_obj_entry :entries]
  ~Chomp[:close_b]
]::call(tokens)

let parse_spread_assign = ~Parser[
  ~Init[{type: :spread_assign}]
  ~Chomp[:dot_dot_dot]
  ~One[:id :name]
]

let parse_assign_id = ~Parser[
  ~Init[{type: :id_assign}]
  ~One[:id :name]
]

let parse_assign_array_entry = ~ParseMap{
  :id => parse_assign_id
  :dot_dot_dot => parse_spread_assign
}

let parse_assign_array = ~Parser[
  ~Init[{type: :array_deconstruction}]
  ~Chomp[:open_sq]
  ~Until[:close_sq parse_assign_array_entry :entries]
  ~Chomp[:close_sq]
]

let parse_obj_entry_rename = ~Parser[
  ~Init[{type: :obj_entry_rename}]
  ~One[:id :old_name]
  ~Chomp[:colon]
  ~One[:id :new_name]
]

let parse_regular_obj_assign_entry = ~Parser[
  ~Init[{type: :obj_reg_entry}]
  ~One[:id :name]
]

let parse_obj_assign_entry = ~ParseMap{
  [:id :colon] => parse_obj_entry_rename
  :id => parse_regular_obj_assign_entry
  :dot_dot_dot => parse_spread_assign
}

let parse_assign_obj = ~Parser[
  ~Init[{type: :object_deconstruction}]
  ~Chomp[:open_b]
  ~Until[:close_b parse_obj_assign_entry :entries]
  ~Chomp[:close_b]
]

let parse_assign_expr = ~ParseMap{
  :id => parse_assign_id
  :open_sq => parse_assign_array
  :open_b => parse_assign_obj
  :dot_dot_dot => parse_spread_assign
}

let parse_keyword = ~Parser[
  ~Init[{type: :keyword}]
  ~One[:keyword :value]
]

fn parse_paren_expr(tokens) = ~Parser[
  ~Init[{type: :paren_expr}]
  ~Chomp[:open_p]
  ~Then[parse_expr :expr]
  ~Chomp[:close_p]
]::call(tokens)

fn parse_yield(tokens) = ~Parser[
  ~Init[{type: :yield}]
  ~Chomp[:yield]
  ~Optional[:times parse_gen_modifier :star?]
  ~Then[parse_expr :expr]
]::call(tokens)

fn parse_await(tokens) = ~Parser[
  ~Init[{type: :await}]
  ~Chomp[:await]
  ~Then[parse_expr :expr]
]::call(tokens)

let parse_num = ~Parser[
  ~Init[{type: :num}]
  ~One[:num :value]
]

let parse_big_int = ~Parser[
  ~Init[{type: :big_int}]
  ~One[:big_int :value]
]

fn parse_array(tokens) = ~Parser[
  ~Init[{type: :array}]
  ~Chomp[:open_sq]
  ~Until[:close_sq parse_expr :elements]
  ~Chomp[:close_sq]
]::call(tokens)

fn parse_spread(tokens) = ~Parser[
  ~Init[{type: :spread}]
  ~Chomp[:dot_dot_dot]
  ~Then[parse_expr :expr]
]::call(tokens)

let parse_unapplied_math_op = ~Parser[
  ~Init[{type: :unapplied_math_op}]
  ~Either[all_math_ops :op]
]

fn parse_bind_this(tokens) = ~Parser[
  ~Init[{type: :bind_this}]
  ~Chomp[:double_colon]
  ~Case[~ParseMap{
    :id => parse_id
    :fn => parse_fn
    all_math_ops => parse_unapplied_math_op
    :open_p => parse_paren_expr
  } :expr]
]::call(tokens)

fn parse_not(tokens) = ~Parser[
  ~Init[{type: :not}]
  ~Chomp[:bang]
  ~Then[parse_1_2_expr :expr]
]::call(tokens)

fn parse_new(tokens) = ~Parser[
  ~Init[{type: :new}]
  ~Chomp[:new]
  ~One[:id :constructor_name]
  ~Chomp[:open_p]
  ~Until[:close_p parse_expr :args]
  ~Chomp[:close_p]
]::call(tokens)

fn parse_num_raw(tokens) =
  parse_num::call(tokens)::pipe(fn([expr, tokens]) = [expr::at(:value)::to_i(), tokens])

let parse_anon_arg_id = ~Parser[
  ~Init[{type: :anon_arg_id}]
  ~Chomp[:single_and]
  ~Optional[:num parse_num_raw :arg_num]
]

let parse_unapplied_and_and = ~Parser[
  ~Init[{type: :unapplied_and_and}]
  ~Chomp[:and_and]
]

let parse_unapplied_or_or = ~Parser[
  ~Init[{type: :unapplied_or_or}]
  ~Chomp[:or_or]
]

fn parse_shorthand_anon_fn(tokens) = ~Parser[
  ~Init[{type: :shorthand_anon_fn}]
  ~Chomp[:hash :open_p]
  ~Then[parse_expr :expr]
  ~Chomp[:close_p]
]::call(tokens)

let parse_async_modifier = ~Parser[
  ~Init[true]
  ~Chomp[:async]
]

let parse_gen_modifier = ~Parser[
  ~Init[true]
  ~Chomp[:times]
]

fn parse_fn_expr_body(tokens) = ~Parser[
  ~Init[{type: :return}]
  ~Chomp[:eq]
  ~Then[parse_expr :expr]
  ~FMap[fn(node) = [node]]
]::call(tokens)

fn parse_args_def(tokens) = ~Parser[
  ~Chomp[:open_p]
  ~Until[:close_p parse_assign_expr]
  ~Chomp[:close_p]
]::call(tokens)

fn parse_fn_name(tokens) = parse_id::call(tokens)::pipe(fn([expr, tokens]) = [expr::at(:name) tokens])

fn parse_fn(tokens) = ~Parser[
  ~Init[{type: :fn}]
  ~Optional[:async parse_async_modifier :is_async?]
  ~Chomp[:fn]
  ~Optional[:times parse_gen_modifier :generator?]
  ~Optional[:id parse_fn_name :name]
  ~Optional[:open_p parse_args_def :args]
  ~Case[~ParseMap{
    :eq => parse_fn_expr_body,
    :open_b => block()
  } :body]
]::call(tokens)

fn parse_keyword_record_entry(tokens) = ~Parser[
  ~Init[{type: :keyword_record_entry}]
  ~One[:id :name]
  ~Chomp[:colon]
  ~Then[parse_expr :expr]
]::call(tokens)

fn parse_regular_record_entry(tokens) = ~Parser[
  ~Init[{type: :regular_record_entry}]
  ~Then[parse_expr :key_expr]
  ~Chomp[:arrow]
  ~Then[parse_expr :value_expr]
]::call(tokens)

fn parse_record_entry(tokens) = ~ParseMap{
  [:id :colon] => parse_keyword_record_entry
  _ => parse_regular_record_entry
}::call(tokens)

fn parse_record_syntax(tokens) = ~Parser[
  ~Init[{type: :record_syntax}]
  ~Chomp[:tilde]
  ~One[:id :constructor_name]
  ~Chomp[:open_b]
  ~Until[:close_b parse_record_entry :entries]
  ~Chomp[:close_b]
]::call(tokens)

fn parse_vector_syntax(tokens) = ~Parser[
  ~Init[{type: :vector_syntax}]
  ~Chomp[:tilde]
  ~One[:id :constructor_name]
  ~Chomp[:open_sq]
  ~Until[:close_sq parse_expr :entries]
  ~Chomp[:close_sq]
]::call(tokens)

fn parse_set(tokens) = ~Parser[
  ~Init[{type: :set}]
  ~Chomp[:hash :open_b]
  ~Until[:close_b parse_expr :elements]
  ~Chomp[:close_b]
]::call(tokens)

fn parse_prefix_inclusive_range(tokens) = ~Parser[
  ~Init[{type: :prefix_inclusive_range}]
  ~Chomp[:dot_dot]
  ~Then[parse_expr :expr]
]::call(tokens)

let SINGLE_EXPR_PARSE_MAP = ~ParseMap{
  :string_lit => parse_str
  :regex_lit => parse_regex
  :keyword => parse_keyword
  :open_p => parse_paren_expr
  :yield => parse_yield
  :await => parse_await
  :id => parse_id
  :at => parse_decorator
  :num => parse_num
  :big_int => parse_big_int
  :open_sq => parse_array
  :dot_dot => parse_prefix_inclusive_range
  :dot_dot_dot => parse_spread
  :double_colon => parse_bind_this
  :bang => parse_not
  :new => parse_new
  :single_and => parse_anon_arg_id
  :open_b => parse_obj
  :and_and => parse_unapplied_and_and
  :or_or => parse_unapplied_or_or
  all_math_ops => parse_unapplied_math_op
  [:hash :open_p] => parse_shorthand_anon_fn
  [:hash :open_b] => parse_set
  [:async :fn] => parse_fn
  :fn => parse_fn
  [:tilde :id :open_b] => parse_record_syntax
  [:tilde :id :open_sq] => parse_vector_syntax
}

fn parse_single_expr(tokens) = SINGLE_EXPR_PARSE_MAP::call(tokens)

fn parse_1_2_expr(tokens) =
  parse_single_expr(tokens)
    ::pipe(parse_snd_expr)

fn parse_expr(tokens) =
  parse_single_expr(tokens)
    ::pipe(parse_snd_expr)
    ::pipe(parse_third_expr)

fn parse_else_branch(tokens) = ~Parser[
  ~Init[{type: :else}]  
  ~Chomp[:else]
  block(:body)
]::call(tokens)

fn parse_else_if_branch(tokens) = ~Parser[
  ~Init[{type: :else_if}]  
  ~Chomp[:else :if]
  ~Then[parse_expr :expr]
  block(:pass)
  ~Optional[:else parse_if_branch :fail]
]::call(tokens)

fn parse_if_branch(tokens) = ~Parser[
  ~Case[~ParseMap{
    [:else :if] => parse_else_if_branch
    :else => parse_else_branch
  }]
]::call(tokens)

fn parse_if(tokens) = ~Parser[
  ~Init[{type: :if}]
  ~Chomp[:if]
  ~Then[parse_expr :expr]
  block(:pass)
  ~Optional[:else parse_if_branch :fail]
]::call(tokens)

fn parse_unless(tokens) = ~Parser[
  ~Init[{type: :unless}]
  ~Chomp[:unless]
  ~Then[parse_expr :expr]
  block(:body)
]::call(tokens)

let parse_let = ~Parser[
  ~Init[{type: :let}]
  ~Chomp[:let]
  ~Then[parse_assign_expr :assign_expr]
  ~Chomp[:eq]
  ~Then[parse_expr :rhs]
]

fn parse_if_let(tokens) = ~Parser[
  ~Init[{type: :if_let}]
  ~Chomp[:if :let]
  ~Then[parse_assign_expr :assign_expr]
  ~Chomp[:eq]
  ~Then[parse_expr :expr]
  ~Chomp[:open_b]
  ~Until[:close_b parse_statement :pass]
  ~Chomp[:close_b]
  ~Optional[:else parse_else_branch :fail]
]::call(tokens)

let parse_impl_for = ~Parser[
  ~Init[{type: :impl_for}]
  ~Chomp[:impl]
  ~Then[parse_expr :proto_expr]
  ~Chomp[:for]
  ~One[:id :constructor]
  ~Chomp[:eq]
  ~Then[parse_expr :expr]
]

let parse_define = ~Parser[
  ~Init[{type: :define_for}]
  ~Chomp[:define]
  ~Then[parse_expr :proto_expr]
  ~Chomp[:for]
  ~Then[parse_single_expr :src_expr]
  ~Chomp[:eq]
  ~Then[parse_expr :expr]
]

let parse_protocol = ~Parser[
  ~Init[{type: :protocol_def}]
  ~Chomp[:protocol]
  ~One[:id :name]
]

let parse_return = ~Parser[
  ~Init[{type: :return}]
  ~Chomp[:return]
  ~Then[parse_expr :expr]
]

let parse_await_modifier = ~Parser[
  ~Init[true]
  ~Chomp[:await]
]

fn parse_for_loop(tokens) = ~Parser[
  ~Init[{type: :for_loop}]
  ~Chomp[:for]
  ~Optional[:await parse_await_modifier :is_await?]
  ~Then[parse_assign_expr :assign_expr]
  ~Chomp[:of]
  ~Then[parse_expr :iterable_expr]
  block(:body)
]::call(tokens)

fn parse_assert(tokens) = ~Parser[
  ~Init[{type: :assert}]
  ~Chomp[:assert!]
  ~Then[fn(tokens) = [tokens::first() tokens] :token]
  ~Then[parse_expr :expr]
  ~Optional[:string_lit parse_str :msg]
]::call(tokens)

fn parse_loop(tokens) = ~Parser[
  ~Init[{type: :loop}]
  ~Chomp[:loop]
  block(:body)
]::call(tokens)

fn parse_while_loop(tokens) = ~Parser[
  ~Init[{type: :while_loop}]
  ~Chomp[:while]
  ~Then[parse_expr :test_expr]
  block(:body)
]::call(tokens)

fn parse_while_let_loop(tokens) = ~Parser[
  ~Init[{type: :while_let_loop}]
  ~Chomp[:while :let]
  ~Then[parse_assign_expr :assign_expr]
  ~Chomp[:eq]
  ~Then[parse_expr :test_expr]
  block(:body)
]::call(tokens)

fn parse_continue(tokens) = ~Parser[
  ~Init[{type: :continue}]
  ~Chomp[:continue]
]::call(tokens)

fn parse_break(tokens) = ~Parser[
  ~Init[{type: :break}]
  ~Chomp[:break]
]::call(tokens)

fn parse_catch(tokens) = ~Parser[
  ~Init[{type: :catch}]
  ~Chomp[:catch]
  ~One[:id :name]
  block(:body)
]::call(tokens)

fn parse_finally(tokens) = ~Parser[
  ~Init[{type: :finally}]
  ~Chomp[:finally]
  block(:body)
]::call(tokens)

fn parse_try(tokens) = ~Parser[
  ~Init[{type: :try}]
  ~Chomp[:try]
  block(:body)
  ~Optional[:catch parse_catch :catch]
  ~Optional[:finally parse_finally :finally]
]::call(tokens)

let parse_impl_object = ~Parser[
  ~Init[{type: :impl_object}]
  ~Chomp[:impl]
  ~One[:id :constructor]
  ~Chomp[:eq]
  ~Then[parse_expr :expr]
]

fn parse_match_entry(tokens) = ~Parser[
  ~Init[{type: :match_entry}]
  ~Case[~ParseMap{
    :open_b => parse_assign_obj
    :open_sq => parse_assign_array
    _ => parse_expr
  } :pattern]
  ~Chomp[:arrow]
  ~Case[~ParseMap{
    :open_b => block()
    _ => parse_statement
  } :body]
]::call(tokens)

fn parse_match(tokens) = ~Parser[
  ~Init[{type: :match}]
  ~Chomp[:match]
  ~Then[parse_expr :expr]
  ~Chomp[:open_b]
  ~Until[:close_b parse_match_entry :entries]
  ~Chomp[:close_b]
]::call(tokens)

fn parse_import(tokens) = ~Parser[
  ~Init[{type: :import}]
  ~Chomp[:import]
  ~Then[parse_assign_expr :assign_expr]
  ~Chomp[:from]
  ~Then[parse_str :path]
]::call(tokens)

fn parse_export(tokens) = ~Parser[
  ~Init[{type: :export}]
  ~Chomp[:export]
  ~Then[parse_statement :statement]
]::call(tokens)

fn parse_export_default(tokens) = ~Parser[
  ~Init[{type: :export_default}]
  ~Chomp[:export :default]
  ~Then[parse_expr :expr]
]::call(tokens)

fn parse_label(tokens) = ~Parser[
  ~Init[{type: :label}]
  ~One[:id :label_name]
  ~Chomp[:colon]
  ~Then[parse_statement :statement]
]::call(tokens)

fn parse_statement(tokens) = ~ParseMap{
  :let => parse_let
  :for => parse_for_loop
  :unless => parse_unless
  :assert! => parse_assert
  :define => parse_define
  :try => parse_try
  :protocol => parse_protocol
  :return => parse_return
  :continue => parse_continue
  :break => parse_break
  :match => parse_match
  :loop => parse_loop
  :import => parse_import
  [:export :default] => parse_export_default
  :export => parse_export
  [:impl :id :eq] => parse_impl_object
  :impl => parse_impl_for
  [:while :let] => parse_while_let_loop
  :while => parse_while_loop
  [:if :let] => parse_if_let
  :if => parse_if
  [:id :colon] => parse_label
  _ => parse_expr
}::call(tokens)

fn block(name) = ~Parser[
  ~Chomp[:open_b]
  ~Until[:close_b parse_statement name]
  ~Chomp[:close_b]
]

fn parse(tokens) {
  let ast = []
  while let [statement_or_expr, rest] = parse_statement::call(tokens) {
    ast.push(statement_or_expr)
    tokens = rest
  }
  return ast
}

// END OF PARSING

// START OF EVAL

fn resolve_name(name) {
  if name == "with" { return "__coil_with" }
  if name == "case" { return "__coil_case" }
  if name {
    return name.replaceAll("?", "__q").replaceAll("!", "__b")
  }
  return name
}

fn eval_if_branch(branch) {
  if branch::nil?() {
    return ""
  } else if branch::at(:type) == :else {
    return str(" else {\n"
      eval_ast(branch::at(:body) || [])
    "\n}")
  } else {
    assert! branch::at(:type) == :else_if
    return str(
      " else if (" eval_expr(branch::at(:expr)) ") {\n"
        eval_ast(branch::at(:pass) || [])
      "\n}" eval_if_branch(branch::at(:fail))
    )
  }
}

fn eval_if({expr pass fail}) = str(
  "if (truthy(" eval_expr(expr) ")) {\n"
    eval_ast(pass) "\n"
  "}" eval_if_branch(fail))

fn eval_unless({expr body}) = str(
  "if (negate.call(" eval_expr(expr) ")) {\n"
    eval_ast(body) "\n"
  "}")

fn eval_str({value}) {
  value = value.slice(1, -1)    
  if value.includes("\n") {
    return str("`" value "`")
  } else {
    return str("\"" value "\"")
  }
}

fn eval_property_lookup({lhs property}) =
  str(eval_expr(lhs) "." resolve_name(property))

fn eval_fn_call({lhs args}) =
  str(eval_expr(lhs) "(" args::map(eval_expr).join(", ") ")")

fn eval_id_assign_name({name}) = resolve_name(name)

fn eval_spread_assign({name}) = str("..." resolve_name(name))

fn eval_array_deconstruction_entry(node) = node::at(:type)::pipe(~Map{
  :id_assign => eval_id_assign_name
  :spread_assign => eval_spread_assign
})::call(node)

fn eval_array_deconstruction_names({entries}) =
  str("[" entries::map(eval_array_deconstruction_entry).join(", ") "]")

fn eval_obj_deconstruction_entry(node) = node::at(:type)::pipe(~Map{
  :obj_reg_entry => #(resolve_name(&::at(:name)))
  :obj_entry_rename => #(str(
    resolve_name(&::at(:old_name))
    ": "
    resolve_name(&::at(:new_name))))
  :spread_assign => eval_spread_assign
})::call(node)

fn eval_object_deconstruction_names({entries}) =
  str("{" entries::map(eval_obj_deconstruction_entry).join(", ") "}")

fn eval_assign_expr(node) = node::at(:type)::pipe(~Map{
  :id_assign => eval_id_assign_name
  :spread_assign => eval_spread_assign
  :array_deconstruction => eval_array_deconstruction_names
  :object_deconstruction => eval_object_deconstruction_names
})::call(node)

fn eval_while_let_loop({assign_expr test_expr body}) = str(
  "let __coil_while_let_temp = " eval_expr(test_expr) ";\n"
  "while (__coil_while_let_temp) {\n"
    "let " eval_assign_expr(assign_expr) " = __coil_while_let_temp;\n"
    eval_ast(body) "\n"
    "__coil_while_let_temp = " eval_expr(test_expr) ";\n"
  "}")

fn eval_if_let({assign_expr expr pass fail}) = str(
  "let __coil_if_let_temp = " eval_expr(expr) ";\n"
  "if (truthy(__coil_if_let_temp)) {\n"
  "let " eval_assign_expr(assign_expr) " = __coil_if_let_temp;\n"
    eval_ast(pass) "\n"
  "}" eval_if_branch(fail))

fn eval_spread({expr}) = str("..." eval_expr(expr))

fn eval_let({assign_expr rhs}) =
  str("let " eval_assign_expr(assign_expr) " = " eval_expr(rhs))

fn eval_array({elements}) =
  str("[" elements::map(eval_expr).join(", ") "]")

let math_op_to_method = ~Map{
  ">" => "greater_than"
  "<" => "less_than"
  ">=" => "greater_than_eq"
  "<=" => "less_than_eq"
  "*" => "times"
  "**" => "exponent"
  "/" => "divide_by"
  "+" => "plus"
  "-" => "minus"
  "%" => "mod"
}

fn if_truthy?(f) {
  if this {
    return f(this)
  } else {
    return this
  }
}

fn eval_math_op({lhs op rhs}) = str(
  math_op_to_method::call(op) ".call("
    eval_expr(lhs) "," eval_expr(rhs)
  ")")

fn eval_fn({is_async? generator? name args body}) = str(
  is_async?::if_truthy?(#("async "))
  "function "
    generator?::if_truthy?(#("*"))
    resolve_name(name)
    "(" args::map(eval_assign_expr).join(", ") ") {\n"
    eval_ast(body)
  "}")

fn eval_set({elements}) =
  str("new Set([" elements::map(eval_expr).join(", ") "])")

fn eval_bind({lhs expr}) =
  str(eval_expr(expr) ".bind(" eval_expr(lhs) ")")

fn eval_reg_obj_entry({key, value}) =
  str(resolve_name(key) ": " eval_expr(value))

fn eval_obj_shorthand_entry({id}) = resolve_name(id)

fn eval_dynamic_obj_entry({key_expr value}) =
  str("[" eval_expr(key_expr)"]: " eval_expr(value))

fn eval_obj_fn({name generator? is_async? args body}) =
  str(is_async?::if_truthy?(#("async"))
      generator?::if_truthy?(#("*"))
      resolve_name(name) "(" args::map(eval_assign_expr).join(", ") ") {\n"
      eval_ast(body) "\n}")

fn eval_obj_entry(node) = node::at(:type)::pipe(~Map{
  :reg_obj_entry => eval_reg_obj_entry
  :obj_shorthand_entry => eval_obj_shorthand_entry
  :dynamic_obj_entry => eval_dynamic_obj_entry
  :spread_obj_entry => eval_spread
  :fn => eval_obj_fn
})::call(node)

fn eval_obj_lit({entries}) =
  str("new ObjectLiteral({"
      entries::map(eval_obj_entry).join(", ") "})")

fn eval_bind_this({expr}) = str(eval_expr(expr) ".bind(this)")
fn eval_id_lookup({name}) = resolve_name(name)
fn eval_num({value}) = str("(" value ")")
fn eval_big_int({value}) = value
fn eval_double_equals({lhs rhs}) = str(
  resolve_name("eq?") ".call(" eval_expr(lhs) ", " eval_expr(rhs) ")")
fn eval_not_equals(node) = str("negate.call(" eval_double_equals(node) ")")
fn eval_not({expr}) = str("negate.call(" eval_expr(expr) ")")
fn eval_dynamic_access({lhs expr}) =
  str(eval_expr(lhs) "[" eval_expr(expr) "]")
fn eval_new({constructor_name, args}) =
  str("new " constructor_name "(" args::map(eval_expr).join(", ") ")")
fn eval_triple_equals({lhs rhs}) =
  str(eval_expr(lhs) " === " eval_expr(rhs))
fn eval_triple_not_equals({lhs rhs}) =
  str(eval_expr(lhs) " !== " eval_expr(rhs))
fn eval_is({lhs rhs}) =
  str(eval_expr(lhs) " instanceof " eval_expr(rhs))
fn eval_and_and({lhs rhs}) =
  str("and.call(" eval_expr(lhs) ", () => " eval_expr(rhs) ")")
fn eval_or_or({lhs rhs}) =
  str("or.call(" eval_expr(lhs) ", () => " eval_expr(rhs) ")")
fn eval_snd_assign({lhs rhs}) =
  str(eval_expr(lhs) " = " eval_expr(rhs))
fn eval_await({expr}) = str("await " eval_expr(expr))
fn eval_yield({star? expr}) =
  str("yield" star?::if_truthy?(#("*")) " " eval_expr(expr))
fn eval_paren_expr({expr}) = str("(" eval_expr(expr) ")")
fn eval_unapplied_math_op({op}) = math_op_to_method::call(op)
fn eval_unapplied_and_and() = "and"
fn eval_unapplied_or_or() = "or"

fn eval_keyword({value}) = str("Keyword.for(\"" resolve_name(value).slice(1) "\")")

fn eval_regular_record_entry({key_expr value_expr}) =
  str("[" eval_expr(key_expr) ", " eval_expr(value_expr) "]")

fn eval_keyword_record_entry({name expr}) =
  str("[" eval_keyword({value: str(":" name)}) ", " eval_expr(expr) "]")

fn eval_record_entry(node) = node::at(:type)::pipe(~Map{
  :regular_record_entry => eval_regular_record_entry
  :keyword_record_entry => eval_keyword_record_entry
})::call(node)

fn eval_record_syntax({constructor_name entries}) =
  str("construct_record.call("
        constructor_name ", "
        "[" entries::map(eval_record_entry).join(", ") "]"
      ")")

fn eval_vector_syntax({constructor_name entries}) =
  str("construct_vector.call("
        constructor_name ", "
        "[" entries::map(eval_expr).join(", ") "]"
      ")")

fn eval_inclusive_range({lhs, rhs}) {
  if rhs {
    return str("new Range(" eval_expr(lhs) ", " eval_expr(rhs) ")")
  } else {
    return str("new Range(" eval_expr(lhs) ", Infinity)")
  }
}

fn eval_exclusive_range({lhs, rhs}) {
  if rhs {
    return str("new Range(" eval_expr(lhs) ", " eval_expr(rhs) ", true)")
  } else {
    return str("new Range(" eval_expr(lhs) ", Infinity, true)")
  }
}

fn eval_shorthand_anon_fn({expr}) =
  str("(...__args) => " eval_expr(expr))

fn eval_anon_arg_id({arg_num}) =
  str("__args[" (arg_num || 1)::dec() "]")

fn eval_decorator({name, fn_def args}) =
  str("let " resolve_name(fn_def::at(:name)) " = "
      name "("
      // yup this is a mess
        ((args || [])::len() != 0)
          ::if_truthy?(#(str(args::map(eval_expr).join(", ") ", ")))
          ::otherwise("")
        eval_fn(fn_def)
      ");")

fn eval_keyof({lhs rhs}) = str(eval_expr(lhs) " in " eval_expr(rhs))
fn eval_and_dot({lhs rhs}) = str(eval_expr(lhs) "?." eval_expr(rhs))
fn eval_partial_fn_call({expr}) = str("(" eval_expr(expr) ")")
fn eval_partial_obj_dyn_access({expr}) = str("[" eval_expr(expr) "]")
fn eval_regex_lit({value}) = value

let logic_ops = ~Map{
  "||" => "or",
  "&&" => "and"
}

let all_ops_to_method = math_op_to_method::concat(logic_ops)

fn eval_rhs_based_on_op(op, rhs) {
  if logic_ops::has?(op) {
    return str("() => " eval_expr(rhs))
  } else {
    return eval_expr(rhs)
  }
}

fn eval_op_eq({ lhs, op, rhs }) = 
  str(eval_expr(lhs) " = "
    all_ops_to_method::call(op) ".call("
      eval_expr(lhs) ", "
      eval_rhs_based_on_op(op rhs) ")")

fn eval_prefix_inclusive_range({ expr }) =
  // todo: do we want this to be polymoprhic based off
  // the type of `expr`? For now its going to expect numbers
  str("new Range(-Infinity, " eval_expr(expr) ")") 

fn eval_expr(node) = node::at(:type)::pipe(~Map{
  :str => eval_str
  :regex_lit => eval_regex_lit
  :decorator => eval_decorator
  :keyword => eval_keyword
  :and_dot => eval_and_dot
  :prefix_inclusive_range => eval_prefix_inclusive_range
  :partial_fn_call => eval_partial_fn_call
  :partial_obj_dyn_access => eval_partial_obj_dyn_access
  :property_lookup => eval_property_lookup
  :id_lookup => eval_id_lookup
  :fn_call => eval_fn_call
  :num => eval_num
  :big_int => eval_big_int
  :array => eval_array
  :math_op => eval_math_op
  :double_equals => eval_double_equals
  :not_equals => eval_not_equals
  :not => eval_not
  :fn => eval_fn
  :bind => eval_bind
  :anon_arg_id => eval_anon_arg_id
  :set => eval_set
  :obj_lit => eval_obj_lit
  :bind_this => eval_bind_this
  :dynamic_access => eval_dynamic_access
  :new => eval_new
  :triple_equals => eval_triple_equals
  :triple_not_equals => eval_triple_not_equals
  :spread => eval_spread
  :is => eval_is
  :and_and => eval_and_and
  :or_or => eval_or_or
  :snd_assign => eval_snd_assign
  :await => eval_await
  :yield => eval_yield
  :record_syntax => eval_record_syntax
  :vector_syntax => eval_vector_syntax
  :paren_expr => eval_paren_expr
  :unapplied_math_op => eval_unapplied_math_op
  :unapplied_and_and => eval_unapplied_and_and
  :unapplied_or_or => eval_unapplied_or_or
  :shorthand_anon_fn => eval_shorthand_anon_fn
  :inclusive_range => eval_inclusive_range
  :exclusive_range => eval_exclusive_range
  :keyof => eval_keyof
  :op_eq => eval_op_eq
})::call(node)

fn eval_return({expr}) = str("return " eval_expr(expr))
fn eval_protocol({name}) = str("const " resolve_name(name) " = Symbol(\"" name "\")")
fn eval_impl_for({proto_expr constructor expr}) =
  str(constructor ".prototype[" eval_expr(proto_expr) "] = " eval_expr(expr))
fn eval_impl_object({constructor expr}) = str(constructor ".prototype = " eval_expr(expr))
fn eval_define_for({proto_expr src_expr expr}) =
  str(eval_expr(src_expr) "[" eval_expr(proto_expr) "] = " eval_expr(expr))

fn eval_for_loop({is_await? assign_expr iterable_expr body}) = 
  str("for "
      is_await?::if_truthy?(#("await "))
      " (let " eval_assign_expr(assign_expr) " of "
      eval_expr(iterable_expr) ") {\n"
        eval_ast(body) "\n"
      "}")

fn eval_id_assign({name, expr}) =
  str(resolve_name(name) " = " eval_expr(expr))

fn eval_assert({expr token msg}) =
  str(resolve_name("assert!") "("
      eval_expr(expr) ", "
      token::at(:line) ", "
      token::at(:col) ", "
      "`" eval_expr(expr) "`,"
      msg
      ")")

fn eval_while_loop({test_expr body}) =
  str("while (" eval_expr(test_expr) ") {\n"
      eval_ast(body) "\n"
      "}")

fn eval_loop({body}) =
  str("while (true) {\n"
      eval_ast(body) "\n"
      "}")

fn eval_continue() = "continue"
fn eval_break() = "break"

fn eval_try(node) =
  str("try {\n"
      eval_ast(node::at(:body)) "\n"
      "}"
      node::has?(:catch)::if_truthy?(
        #(str(" catch (" node::at(:catch)::at(:name) ") {\n"
              eval_ast(node::at(:catch)::at(:body) "\n"
              "}"))))
        ::otherwise("")
      node::has?(:finally)::if_truthy?(
        #(str(" finally {\n"
              eval_ast(node::at(:finally)::at(:body) "\n"
              "}"))))
        ::otherwise("")
      "}")

fn get_deconstructed_obj_entry_name(node) =
  ~Map{:obj_reg_entry => :name
       :obj_entry_rename => :old_name}
    ::at(node::at(:type))
    ::pipe(node)

fn eval_match_obj_pattern({entries}) =
  str(
    "new ObjectLiteral({"
      entries
        ::map(get_deconstructed_obj_entry_name)
        ::filter(_)
        ::map(fn(name) = str(name ": _"))
        .join(",")
    "})"
  )

fn get_deconstructed_array_entry_name(node) =
  ~Map{:id_assign => :name}
    ::at(node::at(:type))
    ::pipe(node)

fn eval_match_array_pattern({entries}) =
  str(
    "["
      entries
        ::map(get_deconstructed_array_entry_name)
        ::filter(_)
        ::map(#("_")).join(", ")
    "]"
  )


fn eval_match_entry({pattern, body}, expr) {
  let pattern_js = null
  let assignments_js = ""
  if pattern::at(:type) == :object_deconstruction {
    pattern_js = eval_match_obj_pattern(pattern)
    assignments_js = eval_object_deconstruction_names(pattern)
  } else if pattern::at(:type) == :array_deconstruction {
    pattern_js = eval_match_array_pattern(pattern)
    assignments_js = eval_array_deconstruction_names(pattern)
  } else {
    pattern_js = eval_expr(pattern)
  }

  if assignments_js::not_empty?() {
    assignments_js = str("let " assignments_js " = deconstruct.call(" eval_expr(expr) ");\n")
  }

  let body_js = null
  if body is Array {
    body_js = eval_ast(body)
  } else {
    body_js = eval_statement(body)
  }

  return str(
    "if (truthy(matches__q.call(" pattern_js ", " eval_expr(expr) "))) {\n"
      assignments_js
      body_js
    "}"
  )
}

fn eval_match({expr, entries}) =
  entries::map(fn(entry) = eval_match_entry(entry, expr))
    .join("else ")

fn eval_import_path(path) {
  if path.split(".")::len() == 1 {
    return str(path ".js")
  } else {
    return path
  }
}

fn eval_import({assign_expr, path}) =
  str("import " eval_assign_expr(assign_expr) " from \"" eval_import_path(path.value.slice(1, -1)) "\"")

fn eval_export({statement}) =
  str("export " eval_statement(statement))

fn eval_export_default({expr}) =
  str("export default " eval_expr(expr))

fn eval_label({label_name, statement}) =
  str(label_name ": " eval_statement(statement))

fn eval_statement(node) = node::at(:type)::pipe(~Map{
  :label => eval_label  
  :if => eval_if
  :unless => eval_unless
  :import => eval_import
  :export => eval_export
  :export_default => eval_export_default
  :let => eval_let
  :if_let => eval_if_let
  :return => eval_return
  :protocol_def => eval_protocol
  :impl_for => eval_impl_for
  :impl_object => eval_impl_object
  :define_for => eval_define_for
  :for_loop => eval_for_loop
  :id_assign => eval_id_assign
  :assert => eval_assert
  :while_loop => eval_while_loop
  :loop => eval_loop
  :while_let_loop => eval_while_let_loop
  :continue => eval_continue
  :break => eval_break
  :try => eval_try
  :match => eval_match
})
  ::if_truthy?(#(compose(&, _ + ";")))
  ::otherwise(eval_expr)::call(node)

fn eval_ast(ast) = ast::map(eval_statement).join("\n")

fn compile(string) = lexer::call(string)
  ::pipe(fn(tokens) = new CollectionView(tokens, 0))
  ::pipe(parse)
  ::pipe(eval_ast)


fn compile_file(src_file_name, out_name, prelude_src) {
  let prelude = Deno.readTextFileSync("./src/std/js_prelude.js")
  prelude = prelude + compile(Deno.readTextFileSync(prelude_src))
  let src = Deno.readTextFileSync(src_file_name)
  Deno.writeTextFile(out_name, prelude + compile(src))
}

if globalThis.Deno {
  let src_file_name = Deno.args[0]
  let out_name = Deno.args[1]
  let prelude_src = "./src/std/prelude.coil"

  if Deno.args[2] == "-w" {
    let watcher = Deno.watchFs([src_file_name, prelude_src])
    for await event of watcher {
      if event.kind != "modify" { continue }
      console.log("Rebuilding...")
      try {
        compile_file(src_file_name, out_name, prelude_src)
      } catch e {
        console.error("Compile Failed", e)
      }
    }
  } else {
    compile_file(src_file_name, out_name, prelude_src)
  }
}
