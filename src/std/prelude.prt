// CALLABLE PROTOCOL

protocol Callable

impl Callable for Function = {
  fn call(...args) = this(...args)
}

impl Callable for Set = {
  fn call(key) = this.has(key)
}

impl Callable for Map = {
  fn call(key) = this.get(key)
}

impl Callable for ObjectLiteral = {
  fn call(key) = this[key]
}

impl Callable for String = {
  fn call(collection) {
    if typeof(collection) === "string" {
      // make sure we don't end up in infinite loop  
      return collection[this]
    } else {
      return collection::call(this)
    }
  }
}

impl Callable for Array = {
  fn call(index) = this.at(index)
}

fn call(...args) = this[[Callable]].call(...args)
fn pipe(callable) = callable::call(this)
fn compose(f, ...fns) = fn(...args) = 
  fns::reduce(
    fn (result, f) = f::call(result),
    f::call(...args)
  )



// EQUAL PROTOCOl

protocol Equal

impl Equal for Number = {
  fn eq?(other) = this === other
}

impl Equal for String = {
  fn eq?(other) = this === other
}

impl Equal for BigInt = {
  fn eq?(other) = this === other
}

impl Equal for Array = {
  fn eq?(other) {
    if other is not Array {
      return false
    }
    if this.length !== other.length {
      return false
    }
    return this.every(fn(value, index) = value[Equal](other[index]))
  }
}

impl Equal for Map = {
  fn eq?(other) {
    if other is not Map {
      return false
    }
    if this.size !== other.size {
      return false
    }
    for let [key, value] of this.entries() {
      if !other.get(key)[Equal](value) {
        return false
      }
    }
    return true
  }
}

impl Equal for ObjectLiteral = {
  fn eq?(other) {
    for let [key, value] of Object.entries(this) {
      if !value[Equal](other[key]) {
        return false
      }
    }
    return true
  }
}

fn eq?(a, b) = a[[Equal]].eq?(b)

// ITER PROTOCOL
protocol Iter

fn entries() = Object.entries(this)
fn from_entries() = Object.fromEntries(this)

impl Iter for ObjectLiteral = {
  fn each(f) = this::entries().forEach(fn ([k, v]) = f(k, v))
  fn map(f) = this::entries().map(fn ([k, v]) = f(k, v))::from_entries()
  fn filter(f) = this::entries().filter(fn ([k, v]) = !!f(k, v))::from_entries()
  fn some?(f) = this::entries().some(fn ([k, v]) = !!f(k, v))::from_entries()
  fn every?(f) = this::entries().every(fn ([k, v]) = !!f(k, v))::from_entries()
  fn reduce(f, start) = this::entries().reduce(f, start)
  fn insert(key, value) = { ...this, [key]: value }
  fn sum() = this::entries().map(fn ([_, v]) = v).reduce(+, 0)
}

impl Iter for Array = {
  fn each(f) = this.forEach(f)
  fn map(f) = this.map(f)
  fn filter(f) = this.filter(f::compose(truthy))
  fn some?(f) = this.some(f::compose(truthy))
  fn every?(f) = this.every(f::compose(truthy))
  fn reduce(f, start) = this.reduce(f, start)
  fn insert(value) = [...this, value]
  fn sum() = this.reduce(+, 0)
}

impl Iter for Set = {
  fn each(f) {
    for let elem of this {
      f(elem)
    }
  }
  fn map(f) {
    let out = new Set([])
    for let elem of this {
      out.add(f(elem))
    }
    return out
  }
  fn reduce(f, start) {
    let acc = start
    for let elem of this {
      acc = f(acc, elem)
    }
    return acc
  }
  fn filter(f) {
    let out = new Set([])
    for let elem of this {
      if f(elem) {
        out.add(elem)
      }
    }
    return out
  }
  fn insert(elem) = new Set(this).add(elem)
  fn sum() = this::reduce(+, 0)
  fn some?(f) {
    for let elem of this {
      if f(elem) {
        return true
      }
    }
    return false
  }
  fn every?(f) {
    for let elem of this {
      if !f(elem) {
        return false
      }
    }
    return true
  }
}

fn each(f) = this[[Iter]].each(f::call)
fn map(...fns) = this[[Iter]].map(compose(...fns))
fn filter(f) = this[[Iter]].filter(f::call)
fn some?(f) = this[[Iter]].some?(f::call)
fn every?(f) = this[[Iter]].every?(f::call)
fn reduce(f, start) = this[[Iter]].reduce(f::call, start)
fn insert(...args) = this[[Iter]].insert(...args)
fn sum() = this[[Iter]].sum()

// OPERATORS

protocol Plus
protocol Minus
protocol Times
protocol Divide
protocol Exponent
protocol Mod
protocol Comparable
protocol LessThan
protocol And
protocol Or

impl And for Object = {
  fn and(other) = js_and(this, other)
}

impl And for Function = {
  fn and(snd_fn) = ::fn(...args) = this::call(...args) && snd_fn::call(...args)
}

impl Or for Object = {
  fn or(other) = js_or(this, other)
}

impl Plus for Number = {
  fn plus(other) {
    assert! typeof(other) === "number"
    return js_plus(this, other)
  }
}

impl Minus for Number = {
  fn minus(other) {
    assert! typeof(other) === "number"
    return js_minus(this, other)
  }
}

impl Times for Number = {
  fn times(other) {
    assert! typeof(other) === "number"
    return js_times(this, other)
  }
}

impl Divide for Number = {
  fn divide_by(other) {
    assert! typeof(other) === "number"
    return js_divide(this, other)
  }
}

impl Exponent for Number = {
  fn exponent(other) {
    assert! typeof(other) === "number"
    return js_exponent(this, other)
  }
}

impl Mod for Number = {
  fn mod(other) {
    assert! typeof(other) === "number"
    return js_mod(this, other)
  }
}

let ComparableMixin = {
  fn greater_than_eq(other) = this::greater_than(other) || this == other
  fn less_than_eq(other) = this::greater_than(other) || this == other
}

impl Comparable for Number = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "number"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "number"
    return js_less_than(this, other)
  }
}

impl Plus for String = {
  fn plus(other) {
    assert! typeof(other) === "string"
    return js_plus(this, other)
  }
}

impl Times for String = {
  fn times(amount) {
    assert! typeof(amount) === "number"
    let s = ""
    for let _ of Array.from({length: amount}) {
      s = s + this
    }
    return s
  }
}

impl Comparable for String = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "string"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "string"
    return js_less_than(this, other)
  }
}

fn plus(other) = this[[Plus]].plus(other)
fn minus(other) = this[[Minus]].minus(other)
fn times(other) = this[[Times]].times(other)
fn divide_by(other) = this[[Divide]].divide_by(other)
fn exponent(other) = this[[Exponent]].exponent(other)
fn mod(other) = this[[Mod]].mod(other)
fn greater_than(other) = this[[Comparable]].greater_than(other)
fn greater_than_eq(other) = this[[Comparable]].greater_than_eq(other)
fn less_than(other) = this[[Comparable]].less_than(other)
fn less_than_eq(other) = this[[Comparable]].less_than_eq(other)
fn and(other) {
  if this {
    return this[[And]].and(other)
  } else {
    return this
  }
}
fn or(other) {
  if this {
    return this[[Or]].or(other)
  } else {
    return other
  }
}

// ideally we use ::each, but the order of compiling the 
// standard library is kind of weird
// maybe I should put it all in a single file & call it prelude.prt
[plus minus times divide_by exponent mod greater_than greater_than_eq less_than less_than_eq and or]
  ::each(fn (op) = op[Callable] = { fn call(a, b) = a::op(b) })

// Printable

protocol Printable

impl Printable for Object = {
  fn printable() = this
}

impl Printable for ObjectLiteral = {
  fn printable() = this::map(fn (k, v) {
    k = k.replaceAll("__q", "?").replaceAll("__b", "!")
    return [k, v]
  })
}

fn printable() {
  if this {  
    return this[[Printable]].printable()
  } else {
    return this
  }
}

fn log() {  
  console.log(this::printable())
  return this
}

// Helpers

fn int?() = Number.isInteger(this)
fn even?() = (this % 2) == 0
fn pos?() = this >= 0

[int? even? pos?]::each(fn (f) = f[Callable] = {
  fn call(num) = num::f()
})
