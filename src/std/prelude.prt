protocol Hashable

impl Hashable for String = fn() = js_str_hash(this)
impl Hashable for Number = fn() = this
impl Hashable for Keyword = fn() = ("____protej_keyword:" + this.value)::hash()
impl Hashable for Array = fn() =
  ::reduce(fn(value, elem, idx) = (value * 31n) + elem::hash(), 7n)
impl Hashable for ObjectLiteral = fn() =
  ::reduce(fn(value, entry) = (value * 31n) + entry::hash(), 7n)
impl Hashable for Map = fn() =
  ::reduce(fn(hash_value, key, value) = (hash_value * 31n) + [key value]::hash(), 7n)

fn hash() = this[Hashable]()

fn Hash(entries) {
  this.raw_entries = entries  
  this.map = new Map(entries.map(fn([key, value]) = [key::hash(), value]))
}

impl Hashable for Hash = fn() = this.map::hash()

// Range

// this needs more thought
fn Range(start, end, exclusive?) {
  assert! Number.isInteger(start)
  assert! Number.isInteger(end)
  this.start = start
  this.end = end
  this.exclusive? = truthy(exclusive?)
}

// CONSTRUCT RECORD PROTOCOL

protocol Record

define Record for Map = {
  fn construct(entries) = new Map(entries)
}
define Record for ObjectLiteral = {
  fn construct(entries) = new ObjectLiteral(Object.fromEntries(entries))
}
define Record for Hash = {
  fn construct(entries) = new Hash(entries)
}

fn construct_record(entries) = this[Record].construct.call(this, entries)

// CALL PROTOCOL

protocol Call

impl Call for Function = fn(...args) = this(...args)

impl Call for Set = fn(key) = this.has(key)

impl Call for Map = fn(key) = this.get(key)

impl Call for ObjectLiteral = fn(key) = this[key]

impl Call for Array = fn(index) = this.at(index)

impl Call for Hash = fn(key) = this::at(key)

impl Call for String = fn(collection) {
  if (typeof(collection) === "string")
  || collection is Keyword {
    // make sure we don't end up in infinite loop  
    return collection[this]
  } else {
    return collection::call(this)
  }
}

impl Call for Number = fn(collection) {
  if collection is Keyword {
    return this[collection]
  } else {
    return collection::call(this)
  }
}

impl Call for Keyword = fn(collection) {
  if (collection is Keyword)
  || typeof(collection) === "string" {
    // again prevent infinite loop
    return collection[this]
  } else {
    return collection::call(this)
  }
}

fn call(...args) = this[Call](...args)

fn pipe(callable) = callable::call(this)

fn compose(f, ...fns) = fn(...args) = 
  fns::reduce(
    fn (result, f) = f::call(result),
    f::call(...args)
  )

fn impl_call_for_bound(f) = f[Call] = fn(first, ...rest) = first::f(...rest)

// EQUAL PROTOCOl

protocol Equal

fn strict_eq?(other) = this === other

impl Equal for Number = strict_eq?

impl Equal for String = strict_eq?

impl Equal for BigInt = strict_eq?

impl Equal for Boolean = strict_eq?

impl Equal for Array = fn(other) {
  if other is not Array {
    return false
  }
  if this.length !== other.length {
    return false
  }
  return this.every(fn(value, index) = value == other[index])
}

impl Equal for Map = fn(other) {
  if other is not Map {
    return false
  }
  if this.size !== other.size {
    return false
  }
  for [key, value] of this.entries() {
    if other.get(key) != value {
      return false
    }
  }
  return true
}

impl Equal for ObjectLiteral = fn(other) {
  for [key, value] of Object.entries(this) {
    if value[Equal] != other[key] {
      return false
    }
  }
  return true
}

fn eq?(a, b) {
  if (a === null) || (a === undefined) {
    return a === b
  } else {
    return a[Equal](b)
  }
}

// CLONE PROTOCOL
protocol Clone

impl Clone for Range = {
  fn clone() = new Range(this.start, this.end, this.exclusive?)
  fn deep_clone() = new Range(this.start::clone(), this.end::clone(), this.exclusive?)
}

impl Clone for ObjectLiteral = {
  fn clone() = {...this}
  fn deep_clone() {
    let output = {}
    for [k, v] of this::entries() {
      output[k] = v::deep_clone()
    }
    return output
  }
}

impl Clone for Array = {
  fn clone() = this.slice()
  fn deep_clone() = this::map(deep_clone)
}

impl Clone for Map = {
  fn clone() = new Map(this)
  fn deep_clone() = this::map(deep_clone)
}

impl Clone for Set = {
  fn clone() = new Set(this)
  fn deep_clone() = this::map(deep_clone)
}

fn clone() = this[Clone].clone.call(this)

fn deep_clone() = this[Clone].deep_clone.call(this)

[clone deep_clone].forEach(impl_call_for_bound)

// IDENTITY PROTOCOL
// this defines the monoid identity for a given type (group)
protocol Identity

impl Identity for Number = 0
impl Identity for BigInt = 0n
impl Identity for String = ""
impl Identity for Array = []
impl Identity for ObjectLiteral = {}
impl Identity for Map = ~Map{}
impl Identity for Hash = ~Hash{}
impl Identity for Set = #{}

fn identity() = this[Identity]


// COLLECTION PROTOCOL
protocol Collection

fn entries() = Object.entries(this)

fn from_entries() = new ObjectLiteral(Object.fromEntries(this))

fn values() = Object.values(this)

impl Collection for ObjectLiteral = {
  fn at(key) = this[key]
  fn sample() = this::values()[0]
  fn each(f) = this::entries().forEach(fn ([k, v]) = f(k, v))
  fn find(f) = this::entries().find(fn ([k, v]) = f(k, v)::pipe(truthy))
  fn map(f) = this::entries().map(fn ([k, v]) = f(k, v))::from_entries()
  fn flat_map(f) = this::entries().map(fn ([k, v]) = f(k, v)::entries()).flat()::from_entries()
  fn filter(f) = this::entries().filter(fn ([k, v]) = f(k, v)::pipe(truthy))::from_entries()
  fn some?(f) = this::entries().some(fn ([k, v]) = f(k, v)::pipe(truthy))::from_entries()
  fn every?(f) = this::entries().every(fn ([k, v]) = f(k, v)::pipe(truthy))::from_entries()
  fn reduce(f, start) = this::entries().reduce(f, start)
  fn insert(key, value) = {...this, [key]: value}
  fn concat(other) = {...this, ...other}
}

impl Collection for Array = {
  fn at(idx) = this.at(idx)
  fn sample() = this[0]
  fn each(f) = this.forEach(f)
  fn find(f) = this.find(compose(f, truthy))
  fn map(f) = this.map(f)
  fn flat_map(f) = this::map(f).flat()
  fn filter(f) = this.filter(compose(f, truthy))
  fn some?(f) = this.some(compose(f, truthy))
  fn every?(f) = this.every(compose(f, truthy))
  fn reduce(f, start) = this.reduce(f, start)
  fn insert(value) = [...this, value]
  fn concat(other) = [...this, ...other]
}

impl Collection for Hash = {
  fn at(key) = this.map.get(key::hash())
  fn sample() = this.raw_entries[0]
  fn each(f) {
    for [k, v] of this.raw_entries {
      f(k, v)
    }
  }
  fn map(f) {
    let new_hash = new Hash([])
    for [k, v] of this.raw_entries {
      new_hash = new_hash::insert(k, f(v))
    }
    return new_hash
  }
  fn find(f) {
    for [k, v] of this.raw_entries {
      if f(k, v) {
        return v
      }
    }
  }
  fn flat_map(f) {
    let new_hash = new Hash([])
    for [k, v] of this {
      for [_k, _v] of f(k, v) {
        new_hash = new_hash::insert(k, f(v))
      }
    }
    return new_hash
  }
  fn filter(f) {
    let new_hash = new Hash([])
    for [k, v] of this.raw_entries {
      if f(k, v) {
        new_hash = new_hash::insert(k, f(v))
      }
    }
    return new_hash
  }
  fn some?(f) {
    for [k, v] of this.raw_entries {
      if f(k, v) {
        return true
      }
    }
    return false
  }
  fn every?(f) {
    for [k, v] of this.raw_entries {
      if !f(k, v) {
        return false
      }
    }
    return true
  }
  fn reduce(f, start) {
    let acc = start
    for [k, v] of this.raw_entries {
      acc = f(acc, k, v)
    }
    return acc
  }
  fn insert(k, v) = new Hash([...this.raw_entries, [k, v]])
  fn concat(other) {
    let new_hash = this::clone()
    for [k, v] of other {
      new_hash = new_hash::insert(k, v)
    }
    return new_hash
  }
}

impl Collection for Map = {
  fn at(key) = this.get(key)
  fn sample() = this.values().next().value
  fn each(f) {
    for [k, v] of this {
      f(k, v)
    }
  }
  fn map(f) {
    let new_map = new Map([])
    for [k, v] of this {
      new_map.set(k, f(v))
    }
    return new_map
  }
  fn find(f) {
    for [k, v] of this {
      if f(k, v) {
        return v
      }
    }
  }
  fn flat_map(f) {
    let new_map = new Map([])
    for [k, v] of this {
      for [_k, _v] of f(k, v) {
        new_map.set(k, f(v))
      }
    }
    return new_map
  }
  fn filter(f) {
    let new_map = new Map([])
    for [k, v] of this {
      if f(k, v) {
        new_map.set(k, f(v))
      }
    }
    return new_map
  }
  fn some?(f) {
    for [k, v] of this {
      if f(k, v) {
        return true
      }
    }
    return false
  }
  fn every?(f) {
    for [k, v] of this {
      if !f(k, v) {
        return false
      }
    }
    return true
  }
  fn reduce(f, start) {
    let acc = start
    for [k, v] of this {
      acc = f(acc, k, v)
    }
    return acc
  }
  fn insert(k, v) = this::clone().set(k, v)
  fn concat(other) {
    let new_map = this::clone()
    for [k, v] of other {
      new_map.set(k, v)
    }
    return new_map
  }
}

impl Collection for Set = {
  fn at(val) {
    if this.has(val) {
      return val
    }
  }
  fn sample() = this.values().next().value
  fn each(f) {
    for elem of this {
      f(elem)
    }
  }
  fn map(f) {
    let out = new Set([])
    for elem of this {
      out.add(f(elem))
    }
    return out
  }
  fn find(f) {
    for elem of this {
      if f(elem) {
        return elem
      }
    }
  }
  fn flat_map(f) {
    let out = new Set([])
    for elem of this {
      for x of f(elem) {
        out.add(x)
      }
    }
    return out
  }
  fn reduce(f, start) {
    let acc = start
    for elem of this {
      acc = f(acc, elem)
    }
    return acc
  }
  fn filter(f) {
    let out = new Set([])
    for elem of this {
      if f(elem) {
        out.add(elem)
      }
    }
    return out
  }

  fn some?(f) {
    for elem of this {
      if f(elem) {
        return true
      }
    }
    return false
  }
  fn every?(f) {
    for elem of this {
      if !f(elem) {
        return false
      }
    }
    return true
  }
  fn insert(elem) = this::clone().add(elem)
  fn concat(other) {
    let new_set = this::clone()
    for item of other {
      new_set.add(item)
    }
    return new_set
  }
}

impl Collection for String = {
  fn at(idx) = this.at(idx)
  fn sample() = this[0]
  fn each(f) {
    for char of this {
      f(char)
    }
  }
  fn map(f) {
    let out = ""
    for char of this {
      out = out + f(char)
    }
    return out
  }
  fn flat_map(f) {
    let out = ""
    for char of this {
      out = out + f(char)
    }
    return out
  }
  fn find(f) {
    for char of this {
      if f(char) {
        return char
      }
    }
  }
  fn filter(f) {
    let out = ""  
    for char of this {
      if f(char) {
        out = out + char
      }
    }
  }
  fn some?(f) {
    for char of this {
      if f(char) {
        return true
      }
    }
    return false
  }
  fn every?(f) {
    for char of this {
      if !f(char) {
        return false
      }
    }
    return true
  }
  fn reduce(f, start) {
    let out = start
    for char of this {
      out = f(out, char)
    }
    return out
  }
  fn insert(char) {
    return this + char
  }
  fn concat(str) {
    return this + str
  }
}

fn at(key_or_idx) = this[Collection].at.call(this, key_or_idx)
fn sample() = this[Collection].sample.call(this)
fn each(f) = this[Collection].each.call(this, f::call)
fn map(...fns) = this[Collection].map.call(this, compose(...fns))
fn flat_map(...fns) = this[Collection].flat_map.call(this, compose(...fns))
fn find(f) = this[Collection].find.call(this, f::call)
fn filter(f) = this[Collection].filter.call(this, f::call)
fn some?(...fns) = this[Collection].some?.call(this, compose(...fns))
fn every?(...fns) = this[Collection].every?.call(this, compose(...fns))
fn reduce(f, start) {
  if !start {
    start = this::sample()::identity()
  }
  return this[Collection].reduce.call(this, f::call, start)
}
fn insert(...args) = this[Collection].insert.call(this, ...args)
fn concat(other) = this[Collection].concat.call(this, other)

protocol OrderedCollection

impl OrderedCollection for Array = {
  fn first() = this[0]
  fn last() = this.at(-1)
  fn take_last(n) = this.slice(-1 - n, -1)
  fn take(n) = this.slice(0, n)
  fn sort(f) = this::clone().sort(f)
  fn reverse() = this::clone().reverse()
}

impl OrderedCollection for String = {
  fn first() = this[0]
  fn last() = this.at(-1)
  fn take_last(n) = this.slice(-1 - n, -1)
  fn take(n) = this.slice(0, n)
  // TODO: don't rely on Array for these
  fn sort(f) = Array.from(this).sort(f).join("")
  fn reverse() = Array.from(this).reverse().join("")
}

impl OrderedCollection for Map = {
  fn first() = this.entries().next().value
  fn last() = Array.from(this).at(-1)
  fn take_last() = new Map(Array.from(this).slice(-1 - n, -1))
  fn take() = new Map(Array.from(this).slice(0, n))
  fn sort() = new Map(Array.from(this).sort(fn ([_k1, v1], [_k2, v2]) = v2 - v1))
  fn reverse() = new Map(Array.from(this).reverse())
}

fn first() = this[OrderedCollection].first.call(this)
fn last() = this[OrderedCollection].last.call(this)
fn take_last(n) = this[OrderedCollection].take_last.call(this, n)
fn take(n) = this[OrderedCollection].take.call(this, n)
fn sort() = this[OrderedCollection].sort.call(this)
fn reverse() = this[OrderedCollection].reverse.call(this)

// OPERATORS

protocol Plus
protocol Minus
protocol Times
protocol Divide
protocol Exponent
protocol Mod
protocol Comparable
protocol LessThan
protocol And
protocol Or

impl And for Object = fn(thunk) = js_and(this, thunk)

impl Or for Object = fn(thunk) = js_or(this, thunk)

impl Plus for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_plus(this, other)
}

impl Minus for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_minus(this, other)
}

impl Times for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_times(this, other)
}

impl Divide for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_divide(this, other)
}

impl Exponent for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_exponent(this, other)
}

impl Mod for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_mod(this, other)
}

impl Plus for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_plus(this, other)
}

impl Minus for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_minus(this, other)
}

impl Times for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_times(this, other)
}

impl Divide for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_divide(this, other)
}

impl Exponent for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_exponent(this, other)
}

impl Mod for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_mod(this, other)
}

let ComparableMixin = {
  fn greater_than_eq(other) = this::greater_than(other) || this == other
  fn less_than_eq(other) = this::greater_than(other) || this == other
}

impl Comparable for Number = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "number"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "number"
    return js_less_than(this, other)
  }
}

impl Comparable for BigInt = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "bigint"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "bigint"
    return js_less_than(this, other)
  }
}

impl Plus for String = fn(other) {
  assert! typeof(other) === "string"
  return js_plus(this, other)
}

impl Times for String = fn(amount) {
  assert! typeof(amount) === "number"
  return this.repeat(amount)
}

impl Comparable for String = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "string"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "string"
    return js_less_than(this, other)
  }
}

fn plus(other) = ~Map{
  Plus => fn(other) = this[Plus](other),
  Collection => fn(other) = this::concat(other)
}
  ::find(::fn(proto, f) = this[proto])
  ::pipe(::fn(f) = this::f(other))

fn minus(other) = this[Minus](other)
fn times(other) = this[Times](other)
fn divide_by(other) = this[Divide](other)
fn exponent(other) = this[Exponent](other)
fn mod(other) = this[Mod](other)
fn greater_than(other) = this[Comparable].greater_than.call(this, other)
fn greater_than_eq(other) = this[Comparable].greater_than_eq.call(this, other)
fn less_than(other) = this[Comparable].less_than.call(this, other)
fn less_than_eq(other) = this[Comparable].less_than_eq.call(this, other)

fn and(other) {
  if this {
    return this[And](other)
  } else {
    return this
  }
}
fn or(thunk) {
  // TODO: this can't be inlined for some reason
  fn null?() = this === null
  if js_or(this === undefined, this::null?) {
    return thunk()
  } else { 
    return this[Or](thunk)
  }
}

[plus minus times divide_by exponent mod greater_than greater_than_eq less_than less_than_eq and or]
  ::each(impl_call_for_bound)

// Printable

protocol Printable

fn _resolve_keyword_str(kw) = kw.replaceAll("__q", "?").replaceAll("__b", "!")

impl Printable for ObjectLiteral = fn() =
  this::map(fn (k, v) = [_resolve_keyword_str(k), v]) 

fn print_for_generic_clone_object() {
  let out = this::clone()
  for [key, value] of this::entries() {
    let new_key = _resolve_keyword_str(key)
    out[new_key] = value
    if new_key != key {
      js_object_delete(out, key)
    }
  }
  return out
}

impl Printable for Keyword = fn() =
  ":" + _resolve_keyword_str(this.value)

impl Printable for Boolean = fn() = this

impl Printable for String = fn() = this

fn when(cond, f) {
  if cond(this) {
    return f(this)
  } else {
    return this
  }
}

fn when_exists(f) = (this || (this == false)) && f::call(this)

fn otherwise(val) = this || val

fn printable() {
  if this {
    return ~Map{
      Printable => fn() = this[Printable]()
      Clone => print_for_generic_clone_object
    }
      ::find(::fn(proto) = this[proto])
      ::when_exists(::fn(printf) = ::printf())
      ::otherwise(this)
  } else {
    return this
  }
}

fn log() {  
  console.log(this::printable())
  return this
}

// Helpers

fn int?() = Number.isInteger(this)
fn bigint?() = typeof(this) === "bigint"
fn float?() = typeof(this) === "number" && !int?(this)
fn even?() = (this % 2) === 0
fn pos?() = this >= this::identity()
fn nan?() = Number.isNaN(this)
fn to_f() = Number(this)
fn to_i() = this::to_f()::pipe(Math.floor)
fn to_s() = this.toString()
fn to_b() = truthy(this)
fn exists?() = (this || (this == false))::to_b()

[int? bigint? even? nan? pos? float? to_f to_i to_s to_b]::each(impl_call_for_bound)

