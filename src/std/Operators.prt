protocol Plus
protocol Minus
protocol Times
protocol Divide
protocol Exponent
protocol Comparable
protocol LessThan

impl Plus for Number = {
  fn plus(other) {
    assert! typeof(other) === "number"
    return js_plus(this, other)
  }
}

impl Minus for Number = {
  fn minus(other) {
    assert! typeof(other) === "number"
    return js_minus(this, other)
  }
}

impl Times for Number = {
  fn times(other) {
    assert! typeof(other) === "number"
    return js_times(this, other)
  }
}

impl Divide for Number = {
  fn divide_by(other) {
    assert! typeof(other) === "number"
    return js_divide(this, other)
  }
}

impl Exponent for Number = {
  fn exponent(other) {
    assert! typeof(other) === "number"
    return js_exponent(this, other)
  }
}

impl Comparable for Object = {
  fn greater_than_eq(other) = this::greater_than(other) || this == other
  fn less_than_eq(other) = this::greater_than(other) || this == other
}

impl Comparable for Number = {
  fn greater_than(other) {
    assert! typeof(other) === "number"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "number"
    return js_less_than(this, other)
  }
}

impl Plus for String = {
  fn plus(other) {
    assert! typeof(other) === "string"
    return js_plus(this, other)
  }
}

impl Times for String = {
  fn times(amount) {
    assert! typeof(amount) === "number"
    let s = ""
    for let _ of Array.from({length: amount}) {
      s = s + this
    }
    return s
  }
}

impl Comparable for String = {
  fn greater_than(other) {
    assert! typeof(other) === "string"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "string"
    return js_less_than(this, other)
  }
}

fn plus(other) = this::(this[Plus].plus)(other)
fn minus(other) = this::(this[Minus].minus)(other)
fn times(other) = this::(this[Times].times)(other)
fn divide_by(other) = this::(this[Divide].divide_by)(other)
fn exponent(other) = this::(this[Exponent].exponent)(other)
fn greater_than(other) = this::(this[Comparable].greater_than)(other)
fn greater_than_eq(other) = this::(this[Comparable].greater_than_eq)(other)
fn less_than(other) = this::(this[Comparable].less_than)(other)
fn less_than_eq(other) = this::(this[Comparable].less_than_eq)(other)

// ideally we use ::each, but the order of compiling the 
// standard library is kind of weird
// maybe I should put it all in a single file & call it prelude.prt
[plus minus times divide_by exponent greater_than greater_than_eq less_than less_than_eq]
  .forEach(fn (op) = op[Callable] = { fn call(a, b) = a::op(b) })