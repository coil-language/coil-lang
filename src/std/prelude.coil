// CALL PROTOCOL

protocol Call

impl Call for Symbol = fn(obj, ...args) = obj[this](...args)
impl Call for Function = fn(...args) = this(...args)
impl Call for Set = fn(key) = this.has(key)
impl Call for Map = fn(key) = this.get(key)
impl Call for ObjectLiteral = fn(key) = this[key]
impl Call for Array = fn(index) = this.at(index)
impl Call for String = fn(collection) {
  if typeof(collection) === "string" || collection is Keyword {
    raise!(new TypeError("Can't 'call' a string with " + collection::as_str()))
  } else {
    return collection::call(this)
  }
}
impl Call for Number = fn(collection) {
  if collection is Keyword {
    return this[collection]
  } else {
    return collection::call(this)
  }
}
impl Call for Keyword = fn(collection) {
  if collection is Keyword || typeof(collection) === "string" {
    raise!(new TypeError("Can't 'call' a keyword with" + collection::as_str()))
  } else if Call keyof collection {
    return collection::call(this)
  } else {
    return collection[this]
  }
}

fn call(...args) = this&.[Call](...args)

// make sets and map callable using bind syntax
impl :bind for Set = fn(val) = ::fn() = this::call(val)
impl :bind for Map = fn(val) = ::fn() = this::call(val)

let nil? = Object.freeze(#{undefined null})

protocol Pipe

impl Pipe for Object = fn(callable) = callable::call(this)

fn pipe(...callables) {
  let f = compose(...callables)  
  if this::nil?() {
    return f(this)
  } else {
    return this[Pipe](f)
  }
}

fn compose(first_fn, ...fns) = fn(...args) =
  fns::reduce(fn (result, f) = f::call(result), first_fn::call(...args))

fn def_call(f) {
  define Call for f = fn(first, ...rest) = first::f(...rest)
  return f
}

// Iterable Protocol

@def_call
fn iter() {
  if this::nil?() {
    return [][Symbol.iterator]()
  } else {
    return this[Symbol.iterator]()
  }
}

@def_call
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol
fn iter?() = this&.[Symbol.iterator] && ::iter() === this

protocol Iterable

let iterable_collection_impl = {
  fn* take(n) {
    for [elem i] of this::zip(0..) {
      if i == n { break }
      yield elem
    }
  }
  fn* drop(n) {
    let size = this::len()
    for [elem i] of this::zip(0..) {
      if (size - i) > n { break }
      yield elem
    }
  }
  fn* until(f) {
    for elem of this {
      if f(elem) { break }
      yield elem
    }
  }
  fn* skip(n) {
    for [elem i] of this::zip(0..) {
      if i < n { continue }
      yield elem
    }
  }
  fn find(f) {
    for elem of this {
      if f(elem) {
        return elem
      }
    }
  }
  fn* zip(...collections) {
    let generators = [this, ...collections]::map(iter)::as_array()
    loop {
      let gen_states = generators::map(#(&.next()))::as_array()
      if gen_states::any?(:done) { break }
      yield gen_states::map(:value)::as_array()
    }
  }
  fn sort() = ::as_array().sort()
  fn sort_by(f) = ::as_array().sort(fn(a, b) = f(a) - f(b))
  fn reduce(f, start) {
    let acc = start
    for elem of this {
      acc = f(acc, elem)
    }
    return acc
  }
  fn* map(f) {
    for elem of this {
      yield f(elem)
    }
  }
  fn* flat_map(f) {
    for elem of this {
      yield* f(elem)
    }
  }
  fn each(f) {
    for elem of this {
      let result = f(elem)
    }
  }
  fn* keep(f) {
    for elem of this {
      if f(elem) {
        yield elem
      }
    }
  }
  fn all?(f) {  
    for elem of this {
      if !f(elem) {
        return false
      }
    }
    return true
  }
  fn any?(f) {
    for elem of this {
      if f(elem) {
        return true
      }
    }
    return false
  }
  fn* split(val, init) {
    init ||= val::EMPTY()
    let chunk = init
    for elem of this {
      if elem == val {
        yield chunk
        chunk = init
      } else {
        chunk = chunk::push(elem)
      }
    }
    yield chunk
  }
}

fn iterable_impl() {
  if this[Iterable] {
    return this[Iterable]
  } else {
    return iterable_collection_impl
  }
}

fn skip(n) = ::iterable_impl().skip.call(this, n)
fn take(n) = ::iterable_impl().take.call(this, n)
fn drop(n) = ::iterable_impl().drop.call(this, n)
fn each(f) = ::iterable_impl().each.call(this, f::call)
fn until(...fns) = ::iterable_impl().until.call(this, compose(...fns))
fn zip(...iterables) = ::iterable_impl().zip.call(this, ...iterables)
fn map(...fns) = ::iterable_impl().map.call(this, compose(...fns))
fn flat_map(...fns) = ::iterable_impl().flat_map.call(this, compose(...fns))
fn find(...fns) = ::iterable_impl().find.call(this, compose(...fns))
fn keep(...fns) = ::iterable_impl().keep.call(this, compose(...fns))
fn reject(...fns) = ::keep(...fns, !_)
fn any?(...fns) = ::iterable_impl().any?.call(this, compose(...fns))
fn all?(...fns) = ::iterable_impl().all?.call(this, compose(...fns))
fn reduce(f, start) = ::iterable_impl().reduce.call(this, f::call, start)
fn sort() = ::iterable_impl().sort.call(this)
fn sort_by(...fns) = ::iterable_impl().sort.call(this, compose(...fns))
fn split(val, init) = ::iterable_impl().split.call(this, val, init)

// RECORD AND VECTOR PROTOCOLS

protocol Record

// using generator here to avoid allocating 2 intermediate entries arrays
fn* merge_iterator(other) {
  yield *this
  yield *other
}

impl Record for ObjectLiteral = {  
  fn at(key) = this[key]
  fn insert(key, value) = {...this, [key]: value}
  fn merge(other) = ObjectLiteral.from_entries(this::merge_iterator(other))
  fn keys() = Object.keys(this)
  fn values() = Object.values(this)
  fn has?(key) = key::as_str() keyof this
  fn len() = this::keys().length
  fn empty?() = this::len() === 0
}

impl Record for Map = {
  fn at(key) = this.get(key)
  fn keys() = this.keys()
  fn values() = this.values()
  fn merge(other) = new Map([...this, ...other])
  fn has?(key) = this.has(key)
  fn len() = this.size
  fn empty?() = this.size === 0
  fn first() = this.entries().next().value
}

fn insert(key, value) = this[Record].insert.call(this, key, value)
fn merge(other) = this[Record].merge.call(this, other)
fn keys() = this[Record].keys.call(this)

define Record for Map = fn(entries) = new Map(entries)

fn record?() = this[Record]::exists?()
fn construct_record(entries) = this[Record](entries)

protocol Vector

fn vector?() = this[Vector]::exists?()

impl Vector for Array = {
  EMPTY: []
  fn at(idx) = this.at(idx)
  fn push(val) = [...this, val]
  fn prepend(val) = [val, ...this]
  fn concat(other) = this::merge_iterator(other)
  fn has?(val) = this::any?(_ == val)
  fn update_at(idx, f) {
    let [before after] = [this::take(idx), this::skip(idx + 1)]
    return [...before, f(::at(idx)), ...after]
  }
  fn insert_at(idx, val) {
    let [before after] = [this::take(idx), this::skip(idx + 1)]
    return [...before, val, ...after]
  }
  fn replace(old_value, new_value) = ::map(fn(val) {
    if val == old_value {
      return new_value
    } else {
      return val
    }
  })
  fn len() = this.length
  fn empty?() = this.length === 0
  fn first() = this[0]
  fn last() = this.at(-1)
}

impl Vector for Set = {
  EMPTY: #{}  
  fn push(value) = new Set(this).add(value)
  fn concat(other) = new Set(this::merge_iterator(other))
  fn has?(value) = this.has(value)
  fn replace(old_value, new_value) {
    let self = new Set(this)  
    self.delete(old_value)
    return self.add(new_value)
  }
  fn len() = this.size
  fn empty?() = this.size === 0
  fn first() = this.values().next().value
}

impl Vector for String = {
  EMPTY: ""  
  fn push(val) = this + val
  fn prepend(val) = val + this
  fn concat(other) = this + other
  fn has?(val) = this.includes(val)
  fn replace(old_val, new_val) = this.replace(old_val, new_val)
  fn len() = this.length
  fn empty?() = this.length === 0
  fn first() = this[0]
  fn last() = this.at(-1)
}

fn EMPTY() = this[Vector].EMPTY
fn at(idx_or_key) = (this[Vector] || this[Record]).at.call(this, idx_or_key)
fn push(val) = this[Vector].push.call(this, val)
fn prepend(val) = this[Vector].prepend.call(this, val)
fn concat(other) = this[Vector].concat.call(this, other)
fn has?(val) = (this[Vector] || this[Record]).has?.call(this, val)
fn replace(old_value, new_value) =
  this[Vector].replace.call(this, old_value, new_value)
fn update_at(idx, callable) =
  this[Vector].update_at.call(this, idx, callable::call)
fn insert_at(idx, val) =
  this[Vector].insert_at.call(this, idx, val)
@def_call
fn len() = (this[Vector] || this[Record]).len.call(this)
@def_call
fn first() = (this[Vector] || this[Record]).first.call(this)
@def_call
fn last() = (this[Vector] || this[Record]).last.call(this)
@def_call
fn empty?() {
  if this::nil?() {
    return true
  } else {
    return (this[Vector] || this[Record]).empty?.call(this)
  }
}
@def_call
fn not_empty?() = !this::empty?()

define Vector for Array = fn(entries) = entries

fn construct_vector(entries) = this[Vector](entries)

// EQUAL PROTOCOl

protocol Equal

fn impl_equal(Ctor, ...keys) {
  impl Equal for Ctor = fn(other) =
    other is Ctor && keys::all?(::fn(key) = this[key] == other[key])
  return Ctor
}

impl Equal for Object = fn(other) = this === other

impl Equal for Set = fn(other) {
  if !(other is Set) { return false }
  if other.size !== this.size { return false }
  return ::all?(fn(val) = other.has(val))
}
impl Equal for Array = fn(other) {
  if !(other is Array) { return false }
  if other.length !== this.length { return false }
  return ::zip(other)::all?(fn([a, b]) = a == b)
}

fn record_equals?(other) {
  if this.constructor !== other.constructor { return false }
  if this::len() != other::len() { return false }
  return this::all?(fn([key, value]) = other::at(key) == value)
}
impl Equal for Map = record_equals?
impl Equal for ObjectLiteral = record_equals?

@def_call
fn equals?(other) {
  if this::nil?() {
    return this === other
  } else {
    return this[Equal](other)
  }
}

// OPERATORS

protocol Plus
protocol Negate
protocol Minus
protocol Times
protocol Divide
protocol Exponent
protocol Mod
protocol Comparable
protocol LessThan
protocol And
protocol Or

impl Negate for Object = fn() = js_negate(this)
impl And for Object = fn(thunk) = js_and(this, thunk)
impl Or for Object = fn(thunk) = js_or(this, thunk)
impl Plus for Set = fn(other_set) = this::concat(other_set)
impl Plus for Array = fn(arr) = this::concat(arr)
impl Plus for Number = fn(other) {
  if typeof(other) === "number" { return js_plus(this, other) }
  else { raise!("Expected number") }
}
impl Minus for Number = fn(other) {
  if typeof(other) === "number" { return js_minus(this, other) }
  else { raise!("Expected number") }
}
impl Times for Number = fn(other) {
  if typeof(other) === "number" { return js_times(this, other) }
  else { raise!("Expected number") }
}
impl Divide for Number = fn(other) {
  if typeof(other) === "number" { return js_divide(this, other) }
  else { raise!("Expected number") }
}
impl Exponent for Number = fn(other) {
  if typeof(other) === "number" { return js_exponent(this, other) }
  else { raise!(new Error("Expected number")) }
}
impl Mod for Number = fn(other) {
  if typeof(other) === "number" { return js_mod(this, other) }
  else { raise!(new Error("Expected number")) }
}
impl Plus for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_plus(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Minus for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_minus(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Times for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_times(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Divide for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_divide(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Exponent for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_exponent(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Mod for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_mod(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Comparable for Number = {
  fn greater_than_eq(other) {
    if typeof(other) === "number" { return js_greater_than_eq(this, other) }
    else { raise!(new Error("Expected number")) }
  }
  fn less_than_eq(other) {
    if typeof(other) === "number" { return js_less_than_eq(this, other) }
    else { raise!(new Error("Expected number")) }
  }
  fn greater_than(other) {
    if typeof(other) === "number" { return js_greater_than(this, other) }
    else { raise!(new Error("Expected number")) }
  }
  fn less_than(other) {
    if typeof(other) === "number" { return js_less_than(this, other) }
    else { raise!(new Error("Expected number")) }
  }
}
impl Comparable for BigInt = {
  fn greater_than_eq(other) {
    if typeof(other) === "bigint" { return js_greater_than_eq(this, other) }
    else { raise!(new Error("Expected bigint")) }
  }
  fn less_than_eq(other) {
    if typeof(other) === "bigint" { return js_less_than_eq(this, other) }
    else { raise!(new Error("Expected bigint")) }
  }
  fn greater_than(other) {
    if typeof(other) === "bigint" { return js_greater_than(this, other) }
    else { raise!(new Error("Expected bigint")) }
  }
  fn less_than(other) {
    if typeof(other) === "bigint" { return js_less_than(this, other) }
    else { raise!(new Error("Expected bigint")) }
  }
}
impl Plus for String = fn(other) {
  if typeof(other) === "string" { return js_plus(this, other) }
  else { raise!(new Error("Expected string")) }
}
impl Times for String = fn(amount) {
  if typeof(amount) === "number" { return this.repeat(amount) }
  else { raise!(new Error("Expected number")) }
}
impl Comparable for String = {
  fn greater_than_eq(other) {
    if typeof(other) === "string" { return js_greater_than_eq(this, other) }
    else { raise!(new Error("Expected string")) }
  }
  fn less_than_eq(other) {
    if typeof(other) === "string" { return js_less_than_eq(this, other) }
    else { raise!(new Error("Expected string")) }
  }
  fn greater_than(other) {
    if typeof(other) === "string" { return js_greater_than(this, other) }
    else { raise!(new Error("Expected string")) }
  }
  fn less_than(other) {
    if typeof(other) === "string" { return js_less_than(this, other) }
    else { raise!(new Error("Expected string")) }
  }
}

@def_call
fn plus(other) = this[Plus](other)
@def_call
fn negate() {
  if this::nil?() {
    return true
  } else {
    return this[Negate]()
  }
}
fn minus(other) = this[Minus](other)
fn times(other) = this[Times](other)
fn divide_by(other) = this[Divide](other)
fn exponent(other) = this[Exponent](other)
fn mod(other) = this[Mod](other)
fn greater_than(other) = this[Comparable].greater_than.call(this, other)
fn greater_than_eq(other) = this[Comparable].greater_than_eq.call(this, other)
fn less_than(other) = this[Comparable].less_than.call(this, other)
fn less_than_eq(other) = this[Comparable].less_than_eq.call(this, other)
fn and(thunk) {
  if this::nil?() {
    return this
  } else {
    return this[And](thunk)
  }
}
fn or(thunk) {
  if this::nil?() {
    return thunk()
  } else {
    return this[Or](thunk)
  }
}

// Printable
// This api is crufty, I'm not gonna lie.

protocol Printable

fn _resolve_keyword_str(kw) = kw::replace("__q", "?")::replace("__b", "!")

impl Printable for ObjectLiteral = fn() {
  let output = new Object()
  for [k, v] of this {
    output[_resolve_keyword_str(k)] = v::printable()
  }
  return output
}

impl Printable for Map = fn() =
  ::map(fn ([k, v]) = [k::printable(), v::printable()])::as_map()

impl Printable for Array = fn() = ::map(printable)::as_array()
impl Printable for Set = fn() = str("#{" this::map(printable)::as_array().join(", ") "}")
impl Printable for Keyword = fn() = ":" + _resolve_keyword_str(this.value)
impl Printable for Boolean = fn() = this
impl Printable for String = fn() = this
impl Printable for Function = fn() = this.name

@def_call
fn printable() {
  if this::nil?() || !this[Printable] {
    return this
  } else {
    return this[Printable]()
  }
}

@def_call
fn log(...args) {  
  console.log(...args, this::printable())
  return this
}

// Global Helpers

fn str(...args) = args.join("")
@def_call
fn nan?() = Number.isNaN(this)
@def_call
fn num?() = typeof(this) == "number"
@def_call
fn bigint?() = typeof(this) == "bigint"
@def_call
fn str?() = typeof(this) == "string"
@def_call
fn as_set() = new Set(this::iter())
@def_call
fn as_array() = Array["from"](this::iter())
@def_call
fn as_obj() = ObjectLiteral.from_entries(this::iter())
@def_call
fn as_map() = new Map(this::iter())
@def_call
fn as_keyword() = Keyword["for"](this.toString())
@def_call
fn as_num() = Number(this)
@def_call
fn as_str() {
  if this::nil?() {
    return ""
  } else if this::iter?() {
    return ::reduce(+, "")
  } else {
    return this.toString()
  }
}
@def_call
fn exists?() = !this::nil?()

// Underscore

fn Underscore(@transforms) {}

protocol UnderscoreInterpreter

let _ = new Underscore([{f: fn id() = this, args: []}])

impl :insert for Underscore = fn(f, ...args) =
  new Underscore(this.transforms::push({f, args}))

impl UnderscoreInterpreter for Object = fn(underscore) {
  let initial_value = this  
  let result = initial_value
  for {f args} of underscore.transforms {
    result = result::f::call(...args)
    // this may not always be true, but this handles And, and Or
    if result is Underscore {
      // we could do something like f[UnderscoreInterpreter]::call(result, initial_value)
      // but I'm not 100% sure
      result = result::call(initial_value)
    }
  }
  return result
}

impl Call for Underscore = fn(data, ...args) {
  if data::nil?() {
    return Object.prototype[UnderscoreInterpreter].call(data, this, ...args)
  } else {
    return data[UnderscoreInterpreter](this, ...args)
  }
}

impl Comparable for Underscore = {
  fn less_than(val) = this.insert(less_than, val)
  fn greater_than(val) = this.insert(greater_than, val)
  fn less_than_eq(val) = this.insert(less_than_eq, val)
  fn greater_than_eq(val) = this.insert(greater_than_eq, val)
}

impl Negate for Underscore = fn() = this.insert(negate)
impl Equal for Underscore = fn(other) = this.insert(equals?, other)

impl Iterable for Underscore = {
  fn empty?() = this.insert(empty?)
  fn first() = this.insert(first)
  fn take() = this.insert(take)
  fn skip() = this.insert(skip)
  fn find(f) = this.insert(find, f)
  fn reduce(f, start) = this.insert(reduce, f, start)
  fn map(f) = this.insert(map, f)
  fn flat_map(f) = this.insert(flat_map, f)
  fn each(f) = this.insert(each, f)
  fn keep(f) = this.insert(keep, f)
  fn all?(f) = this.insert(all? f)
  fn any?(f) = this.insert(any?, f)
}
impl Record for Underscore = {
  fn at(key) = this.insert(at, key)
  fn insert(key, value) = this.insert(insert, key, value)
  fn merge(other) = this.insert(merge, other)
  fn has?(k) = this.insert(has?, k)
  fn len() = this.insert(len)
  fn last() = this.insert(last)
}
impl Vector for Underscore = {
  fn at(key) = this.insert(at, key)
  fn push(value) = this.insert(push, value)
  fn prepend(value) = this.insert(prepend, value)
  fn concat(other) = this.insert(concat, other)
  fn replace(old_value, new_value) = this.insert(has?, old_value, new_value)
  fn len() = this.insert(len)
  fn has?(k) = this.insert(has?, k)
  fn last() = this.insert(last)
}
impl Pipe for Underscore = fn(f) = this.insert(pipe, f)
impl And for Underscore = fn(thunk) = this.insert(and, thunk)
impl Or for Underscore = fn(thunk) = this.insert(or, thunk)
impl Plus for Underscore = fn(other) = this.insert(plus, other)
impl Minus for Underscore = fn(other) = this.insert(minus, other)
impl Times for Underscore = fn(other) = this.insert(times, other)
impl Divide for Underscore = fn(other) = this.insert(divide, other)
impl Exponent for Underscore = fn(other) = this.insert(exponent, other)
impl Mod for Underscore = fn(other) = this.insert(mod, other)

// this is kind of shaky but its good enough
impl Printable for Underscore = fn() {
  let fn_to_op = ~Map{
    "greater_than" => ">"
    "greater_than_eq" => ">="
    "less_than" => "<"
    "less_than_eq" => "<="
    "times" => "*"
    "exponent" => "**"
    "divide_by" => "/"
    "plus" => "+"
    "minus" => "-"
    "mod" => "%"
    "eq__q" => "=="
    "and" => "&&"
    "or" => "||"
  }
  return str("_" this.transforms::skip(1)::map(fn({f, args}) {
    let fn_name = f::printable()
    if let op = fn_to_op::call(fn_name) {
      let [rhs] = args
      if #{and, or}::call(f) { rhs = rhs() }
      return str(" " op " " rhs::printable())
    } else {
      return str("::" fn_name "(" args::map(printable)::as_array().join(", ") ")")
    }
  })::reduce(+, ""))
}

// Ranges

protocol Inc

impl Inc for Number = fn() = this + 1
impl Inc for BigInt = fn() = this + 1n
impl Inc for String = fn() = String.fromCharCode(this.charCodeAt(0) + 1)

fn inc() = this[Inc]()

@impl_equal(:start, :end)
fn IRange(@start, @end) {}
@impl_equal(:start, :end)
fn ERange(@start, @end) {}
@impl_equal(:end)
fn IRangeNoMin(@end) {}
@impl_equal(:start)
fn ERangeNoMax(@start) {}
@impl_equal(:end)
fn ERangeNoMin(@end) {}

impl Call for IRange = fn(value) = value >= this.start && value <= this.end
impl Call for ERange = fn(value) = value >= this.start && value < this.end
impl Call for IRangeNoMin = fn(value) = value <= this.end
impl Call for ERangeNoMax = fn(value) = value >= this.start
impl Call for ERangeNoMin = fn(value) = value < this.end

impl Printable for IRange = fn() = str(this.start "..=" this.end)
impl Printable for ERange = fn() = str(this.start ".." this.end)
impl Printable for IRangeNoMin = fn() = str("..=" this.end)
impl Printable for ERangeNoMax = fn() = str(this.start "..")
impl Printable for ERangeNoMin = fn() = str(".." this.end)

impl Symbol.iterator for IRange = fn*() {
  let {start: i, end} = this
  while i <= end {
    yield i
    i = i::inc()
  }
}
impl Symbol.iterator for ERange = fn*() {
  let {start: i, end} = this
  while i < end {
    yield i
    i = i::inc()
  }
}
impl Symbol.iterator for ERangeNoMax = fn*() {
  let i = this.start  
  loop {
    yield i
    i = i::inc()
  }
}

fn def_vector(Constructor) {
  define Vector for Constructor = fn(args) = new Constructor(...args)
  return Constructor
}

fn def_record(Constructor) {
  define Record for Constructor = fn(entries) = new Constructor(entries)
  impl Symbol.iterator for Constructor = fn() = this.entries::iter()
  return Constructor
}

// string helpers
let char_alpha? = ("a"..="z")::as_set() + ("A"..="Z")::as_set()
let char_numeric? = ("0"..="9")::as_set()
let char_alpha_numeric? = char_alpha? + char_numeric?
fn alpha?() = this::all?(char_alpha?)
fn alpha_numeric?() = this::all?(char_alpha_numeric?)

@def_record
fn CallMap(@entries) {}
impl Call for CallMap = fn(value) =
  ::find(fn([callable, _]) = callable::call(value))
  ::pipe(fn([_, val]) = val)

// GLOBAL EXPORTS

define :Call for globalThis = Call
define :call for globalThis = call
define :nil? for globalThis = nil?
define :Pipe for globalThis = Pipe
define :pipe for globalThis = pipe
define :compose for globalThis = compose
define :iter for globalThis = iter
define :Iterable for globalThis = Iterable
define :skip for globalThis = skip
define :take for globalThis = take
define :drop for globalThis = drop
define :each for globalThis = each
define :until for globalThis = until
define :zip for globalThis = zip
define :map for globalThis = map
define :flat_map for globalThis = flat_map
define :find for globalThis = find
define :split for globalThis = split
define :keep for globalThis = keep
define :reject for globalThis = reject
define :any? for globalThis = any?
define :all? for globalThis = all?
define :reduce for globalThis = reduce
define :Record for globalThis = Record
define :insert for globalThis = insert
define :merge for globalThis = merge
define :keys for globalThis = keys
define :record? for globalThis = record?
define :construct_record for globalThis = construct_record
define :Vector for globalThis = Vector
define :vector? for globalThis = vector?
define :at for globalThis = at
define :push for globalThis = push
define :prepend for globalThis = prepend
define :concat for globalThis = concat
define :has? for globalThis = has?
define :replace for globalThis = replace
define :len for globalThis = len
define :first for globalThis = first
define :last for globalThis = last
define :empty? for globalThis = empty?
define :not_empty? for globalThis = not_empty?
define :construct_vector for globalThis = construct_vector
define :Equal for globalThis = Equal
define :equals? for globalThis = equals?
define :Plus for globalThis = Plus
define :Negate for globalThis = Negate
define :Minus for globalThis = Minus
define :Times for globalThis = Times
define :Divide for globalThis = Divide
define :Exponent for globalThis = Exponent
define :Mod for globalThis = Mod
define :Comparable for globalThis = Comparable
define :LessThan for globalThis = LessThan
define :And for globalThis = And
define :Or for globalThis = Or
define :plus for globalThis = plus
define :negate for globalThis = negate
define :minus for globalThis = minus
define :times for globalThis = times
define :divide_by for globalThis = divide_by
define :exponent for globalThis = exponent
define :mod for globalThis = mod
define :greater_than for globalThis = greater_than
define :greater_than_eq for globalThis = greater_than_eq
define :less_than for globalThis = less_than
define :less_than_eq for globalThis = less_than_eq
define :and for globalThis = and
define :or for globalThis = or
define :Printable for globalThis = Printable
define :printable for globalThis = printable
define :log for globalThis = log
define :str for globalThis = str
define :nan? for globalThis = nan?
define :str? for globalThis = str?
define :as_set for globalThis = as_set
define :as_array for globalThis = as_array
define :as_obj for globalThis = as_obj
define :as_map for globalThis = as_map
define :as_keyword for globalThis = as_keyword
define :as_num for globalThis = as_num
define :as_str for globalThis = as_str
define :exists? for globalThis = exists?
define :Negate for globalThis = Negate
define :Underscore for globalThis = Underscore
define :_ for globalThis = _
define :Inc for globalThis = Inc
define :inc for globalThis = inc
define :IRange for globalThis = IRange
define :ERange for globalThis = ERange
define :alpha? for globalThis = alpha?
define :alpha_numeric? for globalThis = alpha_numeric?
define :def_vector for globalThis = def_vector
define :def_record for globalThis = def_record
