// CALL PROTOCOL

protocol Call

impl Call for Function = fn(...args) = this(...args)
impl Call for Set = fn(key) = this.has(key)
impl Call for Map = fn(key) = this.get(key)
impl Call for ObjectLiteral = fn(key) = this[key]
impl Call for Array = fn(index) = this.at(index)
impl Call for String = fn(collection) {
  if typeof(collection) === "string" || collection is Keyword {
    raise!(new TypeError("Can't 'call' a string with " + collection::as_str()))
  } else {
    return collection::call(this)
  }
}
impl Call for Number = fn(collection) {
  if collection is Keyword {
    return this[collection]
  } else {
    return collection::call(this)
  }
}
impl Call for Keyword = fn(collection) {
  if collection is Keyword || typeof(collection) === "string" {
    raise!(new TypeError("Can't 'call' a keyword with" + collection::as_str()))
  } else if Call keyof collection {
    return collection::call(this)
  } else {
    return collection[this]
  }
}

fn call(...args) = this&.[Call](...args)

// make sets callable using bind syntax
impl :bind for Set = fn(val) = ::fn() = this::call(val)

let nil? = Object.freeze(#{undefined null})

protocol Pipe

impl Pipe for Object = fn(callable) = callable::call(this)

fn pipe(...callables) {
  let f = compose(...callables)
  if this::nil?() {
    return f(this)
  } else {
    return this[Pipe](f)
  }
}

fn compose(first_fn, ...fns) = fn(...args) =
  fns::reduce(fn (result, f) = f::call(result), first_fn::call(...args))

fn def_call(f) {
  define Call for f = fn(first, ...rest) = first::f(...rest)
  return f
}

// Iterable Protocol

@def_call
fn iter() {
  if this::nil?() {
    return [][Symbol.iterator]()
  } else {
    return this[Symbol.iterator]()
  }
}

@def_call
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol
fn iter?() = this&.[Symbol.iterator] && ::iter() === this

protocol Iterable

let iterable_collection_impl = {
  fn* take(n) {
    for [elem i] of this::zip(0..) {
      if i == n { break }
      yield elem
    }
  }
  fn* drop(n) {
    let size = this::len()
    for [elem i] of this::zip(0..) {
      if (size - i) > n { break }
      yield elem
    }
  }
  fn* until(f) {
    for elem of this {
      if f(elem) { break }
      yield elem
    }
  }
  fn* skip(n) {
    for [elem i] of this::zip(0..) {
      if i < n { continue }
      yield elem
    }
  }
  fn find(f) {
    for elem of this {
      if f(elem) {
        return elem
      }
    }
  }
  fn* zip(...collections) {
    let generators = [this, ...collections]::map(iter)::into([])
    loop {
      let gen_states = generators::map(#(&.next()))::into([])
      if gen_states::any?(:done) { break }
      yield gen_states::map(:value)::into([])
    }
  }
  fn reduce(f, start) {
    let acc = start
    for elem of this {
      acc = f(acc, elem)
    }
    return acc
  }
  fn* map(f) {
    for elem of this {
      yield f(elem)
    }
  }
  fn* flat_map(f) {
    for elem of this {
      yield* f(elem)
    }
  }
  fn each(f) {
    for elem of this {
      f(elem)
    }
  }
  fn* keep(f) {
    for elem of this {
      if f(elem) {
        yield elem
      }
    }
  }
  fn all?(f) {
    for elem of this {
      if !f(elem) {
        return false
      }
    }
    return true
  }
  fn any?(f) {
    for elem of this {
      if f(elem) {
        return true
      }
    }
    return false
  }
  fn* split(val, init) {
    init ||= val::EMPTY()
    let chunk = init
    for elem of this {
      if elem == val {
        yield chunk
        chunk = init
      } else {
        chunk = chunk::push(elem)
      }
    }
    yield chunk
  }
  fn* concat(other) {
    yield* this
    yield* other
  }
  fn* push(val) {  
    yield* this
    yield val
  }
  fn* prepend(val) {
    yield val
    yield* this
  }
}

fn iterable_impl() = this[Iterable] || iterable_collection_impl

fn skip(n) = ::iterable_impl().skip.call(this, n)
fn take(n) = ::iterable_impl().take.call(this, n)
fn drop(n) = ::iterable_impl().drop.call(this, n)
fn each(f) = ::iterable_impl().each.call(this, f::call)
fn until(...fns) = ::iterable_impl().until.call(this, compose(...fns))
fn zip(...iterables) = ::iterable_impl().zip.call(this, ...iterables)
fn map(...fns) = ::iterable_impl().map.call(this, compose(...fns))
fn flat_map(...fns) = ::iterable_impl().flat_map.call(this, compose(...fns))
fn find(...fns) = ::iterable_impl().find.call(this, compose(...fns))
fn keep(...fns) = ::iterable_impl().keep.call(this, compose(...fns))
fn reject(...fns) = ::keep(...fns, !_)
fn any?(...fns) = ::iterable_impl().any?.call(this, compose(...fns))
fn all?(...fns) = ::iterable_impl().all?.call(this, compose(...fns))
fn reduce(f, start) = ::iterable_impl().reduce.call(this, f::call, start)
fn split(val, init) = ::iterable_impl().split.call(this, val, init)
fn join(sep) = ::reduce(fn(prev cur) {
  if prev::empty?() {
    return cur
  } else {
    return prev + sep + cur
  }
} "")

// INTO

protocol Into

impl Into for Array = fn(iterable) = [...this, ...iterable]
impl Into for ObjectLiteral = fn(iterable) = ::merge(iterable)
impl Into for Map = fn(iterable) = ::merge(iterable)
impl Into for Set = fn(iterable) = ::concat(iterable)
impl Into for String = fn(iterable) = this + iterable::reduce(+ "")
define Into for Object = fn(iterable) = Object.fromEntries(iterable)

fn into(val) = val[Into](this)

// RECORD AND VECTOR PROTOCOLS

protocol Record

// using generator here to avoid allocating 2 intermediate entries arrays
fn* merge_iterator(other) {
  yield *this
  yield *other
}

impl Record for ObjectLiteral = {
  fn at(key) = this[key]
  fn insert(key, value) = {...this, [key]: value}
  fn merge(other) = ObjectLiteral.from_entries(this::merge_iterator(other))
  fn keys() = Object.keys(this)
  fn values() = Object.values(this)
  fn has?(key) = key::as_str() keyof this
  fn len() = this::keys().length
  fn empty?() = this::len() === 0
}

impl Record for Map = {
  fn at(key) = this.get(key)
  fn keys() = this.keys()
  fn values() = this.values()
  fn merge(other) = new Map([...this, ...other])
  fn has?(key) = this.has(key)
  fn len() = this.size
  fn empty?() = this.size === 0
  fn first() = this.entries().next().value
}

fn insert(key, value) = this[Record].insert.call(this, key, value)
fn merge(other) = this[Record].merge.call(this, other)
fn keys() = this[Record].keys.call(this)

define Record for Map = fn(entries) = new Map(entries)

fn record?() = this[Record]::exists?()
fn construct_record(entries) = this[Record](entries)

protocol Vector

fn vector?() = this[Vector]::exists?()

impl Vector for Array = {
  EMPTY: []
  fn at(idx) = this.at(idx)
  fn push(val) = [...this, val]
  fn prepend(val) = [val, ...this]
  fn concat(other) = this::merge_iterator(other)
  fn has?(val) = this::any?(_ == val)
  fn update_at(idx, f) {
    let [before after] = [this::take(idx), this::skip(idx + 1)]
    return [...before, f(::at(idx)), ...after]
  }
  fn insert_at(idx, val) {
    let [before after] = [this::take(idx), this::skip(idx + 1)]
    return [...before, val, ...after]
  }
  fn replace(old_value, new_value) = ::map(fn(val) {
    if val == old_value {
      return new_value
    } else {
      return val
    }
  })
  fn len() = this.length
  fn empty?() = this.length === 0
  fn first() = this[0]
  fn last() = this.at(-1)
}

impl Vector for Set = {
  EMPTY: #{}
  fn push(value) = new Set(this).add(value)
  fn concat(other) = new Set(this::merge_iterator(other))
  fn has?(value) = this.has(value)
  fn replace(old_value, new_value) {
    let self = new Set(this)
    self.delete(old_value)
    return self.add(new_value)
  }
  fn len() = this.size
  fn empty?() = this.size === 0
  fn first() = this.values().next().value
}

impl Vector for String = {
  EMPTY: ""
  fn push(val) = this + val
  fn prepend(val) = val + this
  fn concat(other) = this + other
  fn has?(val) = this.includes(val)
  fn replace(old_val, new_val) = this.replace(old_val, new_val)
  fn len() = this.length
  fn empty?() = this.length === 0
  fn first() = this[0]
  fn last() = this.at(-1)
}

fn EMPTY() = this[Vector].EMPTY
fn at(idx_or_key) = (this[Vector] || this[Record]).at.call(this, idx_or_key)
fn push(val) = (this[Vector] || ::iterable_impl()).push.call(this, val)
fn prepend(val) = (this[Vector] || ::iterable_impl()).prepend.call(this, val)
fn concat(other) = (this[Vector] || ::iterable_impl()).concat.call(this, other)
fn has?(val) = (this[Vector] || this[Record]).has?.call(this, val)
fn replace(old_value, new_value) =
  this[Vector].replace.call(this, old_value, new_value)
fn update_at(idx, callable) =
  this[Vector].update_at.call(this, idx, callable::call)
fn insert_at(idx, val) =
  this[Vector].insert_at.call(this, idx, val)
@def_call
fn len() = (this[Vector] || this[Record]).len.call(this)
@def_call
fn first() {
  if ::iter?() {
    return this.next().value
  } else {
    return (this[Vector] || this[Record]).first.call(this)
  }
}
@def_call
fn last() = (this[Vector] || this[Record]).last.call(this)
@def_call
fn empty?() {
  if this::nil?() {
    return true
  } else {
    return (this[Vector] || this[Record]).empty?.call(this)
  }
}
@def_call
fn not_empty?() = !this::empty?()

define Vector for Array = fn(entries) = entries

fn construct_vector(entries) = this[Vector](entries)

// EQUAL PROTOCOl

protocol Equal

fn impl_equal(Ctor, ...keys) {
  impl Equal for Ctor = fn(other) =
    other is Ctor && keys::all?(::fn(key) = this[key] == other[key])
  return Ctor
}

impl Equal for Object = fn(other) = this === other

impl Equal for Set = fn(other) {
  if !(other is Set) { return false }
  if other.size !== this.size { return false }
  return ::all?(fn(val) = other.has(val))
}
impl Equal for Array = fn(other) {
  if !(other is Array) { return false }
  if other.length !== this.length { return false }
  return ::zip(other)::all?(fn([a, b]) = a == b)
}

fn record_equals?(other) {
  if this.constructor !== other.constructor { return false }
  if this::len() != other::len() { return false }
  return this::all?(fn([key, value]) = other::at(key) == value)
}
impl Equal for Map = record_equals?
impl Equal for ObjectLiteral = record_equals?

@def_call
fn equals?(other) {
  if this::nil?() {
    return this === other
  } else {
    return this[Equal](other)
  }
}

// OPERATORS

protocol Plus
protocol Negate
protocol Minus
protocol Times
protocol Divide
protocol Exponent
protocol Mod
protocol Comparable
protocol LessThan
protocol And
protocol Or

impl Negate for Object = fn() = js_negate(this)
impl And for Object = fn(thunk) = js_and(this, thunk)
impl Or for Object = fn(thunk) = js_or(this, thunk)
impl Plus for Set = fn(other_set) = this::concat(other_set)
impl Plus for Array = fn(arr) = this::concat(arr)
impl Plus for Number = fn(other) {
  if typeof(other) === "number" { return js_plus(this, other) }
  else { raise!("Expected number") }
}
impl Minus for Number = fn(other) {
  if typeof(other) === "number" { return js_minus(this, other) }
  else { raise!("Expected number") }
}
impl Times for Number = fn(other) {
  if typeof(other) === "number" { return js_times(this, other) }
  else { raise!("Expected number") }
}
impl Divide for Number = fn(other) {
  if typeof(other) === "number" { return js_divide(this, other) }
  else { raise!("Expected number") }
}
impl Exponent for Number = fn(other) {
  if typeof(other) === "number" { return js_exponent(this, other) }
  else { raise!(new Error("Expected number")) }
}
impl Mod for Number = fn(other) {
  if typeof(other) === "number" { return js_mod(this, other) }
  else { raise!(new Error("Expected number")) }
}
impl Plus for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_plus(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Minus for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_minus(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Times for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_times(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Divide for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_divide(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Exponent for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_exponent(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Mod for BigInt = fn(other) {
  if typeof(other) === "bigint" { return js_mod(this, other) }
  else { raise!(new Error("Expected bigint")) }
}
impl Comparable for Number = {
  fn greater_than_eq(other) {
    if typeof(other) === "number" { return js_greater_than_eq(this, other) }
    else { raise!(new Error("Expected number")) }
  }
  fn less_than_eq(other) {
    if typeof(other) === "number" { return js_less_than_eq(this, other) }
    else { raise!(new Error("Expected number")) }
  }
  fn greater_than(other) {
    if typeof(other) === "number" { return js_greater_than(this, other) }
    else { raise!(new Error("Expected number")) }
  }
  fn less_than(other) {
    if typeof(other) === "number" { return js_less_than(this, other) }
    else { raise!(new Error("Expected number")) }
  }
}
impl Comparable for BigInt = {
  fn greater_than_eq(other) {
    if typeof(other) === "bigint" { return js_greater_than_eq(this, other) }
    else { raise!(new Error("Expected bigint")) }
  }
  fn less_than_eq(other) {
    if typeof(other) === "bigint" { return js_less_than_eq(this, other) }
    else { raise!(new Error("Expected bigint")) }
  }
  fn greater_than(other) {
    if typeof(other) === "bigint" { return js_greater_than(this, other) }
    else { raise!(new Error("Expected bigint")) }
  }
  fn less_than(other) {
    if typeof(other) === "bigint" { return js_less_than(this, other) }
    else { raise!(new Error("Expected bigint")) }
  }
}
impl Plus for String = fn(other) {
  if typeof(other) === "string" { return js_plus(this, other) }
  else { raise!(new Error("Expected string")) }
}
impl Times for String = fn(amount) {
  if typeof(amount) === "number" { return this.repeat(amount) }
  else { raise!(new Error("Expected number")) }
}
impl Comparable for String = {
  fn greater_than_eq(other) {
    if typeof(other) === "string" { return js_greater_than_eq(this, other) }
    else { raise!(new Error("Expected string")) }
  }
  fn less_than_eq(other) {
    if typeof(other) === "string" { return js_less_than_eq(this, other) }
    else { raise!(new Error("Expected string")) }
  }
  fn greater_than(other) {
    if typeof(other) === "string" { return js_greater_than(this, other) }
    else { raise!(new Error("Expected string")) }
  }
  fn less_than(other) {
    if typeof(other) === "string" { return js_less_than(this, other) }
    else { raise!(new Error("Expected string")) }
  }
}

@def_call
fn plus(other) = this[Plus](other)
@def_call
fn negate() {
  if this::nil?() {
    return true
  } else {
    return this[Negate]()
  }
}
fn minus(other) = this[Minus](other)
fn times(other) = this[Times](other)
fn divide_by(other) = this[Divide](other)
fn exponent(other) = this[Exponent](other)
fn mod(other) = this[Mod](other)
fn greater_than(other) = this[Comparable].greater_than.call(this, other)
fn greater_than_eq(other) = this[Comparable].greater_than_eq.call(this, other)
fn less_than(other) = this[Comparable].less_than.call(this, other)
fn less_than_eq(other) = this[Comparable].less_than_eq.call(this, other)
fn and(thunk) {
  if this::nil?() {
    return this
  } else {
    return this[And](thunk)
  }
}
fn or(thunk) {
  if this::nil?() {
    return thunk()
  } else {
    return this[Or](thunk)
  }
}

// This api is crufty, I'm not gonna lie.

protocol JsLogFriendly

// Why do we even do this for keywords?
fn _resolve_keyword_str(kw) = kw::replace("__q", "?")::replace("__b", "!")

impl JsLogFriendly for ObjectLiteral = fn() =
  ::map(fn([k, v]) = [_resolve_keyword_str(k) v::js_log_friendly()])
  ::into(Object)

impl JsLogFriendly for Map = fn() =
  ::map(fn ([k, v]) = [k::js_log_friendly(), v::js_log_friendly()])
  ::into(~Map{})

impl JsLogFriendly for Array = fn() = ::map(js_log_friendly)::into([])
impl JsLogFriendly for Set = fn() = str("#{" this::map(js_log_friendly)::join(", ") "}")
impl JsLogFriendly for Keyword = fn() = ":" + _resolve_keyword_str(this.value)
impl JsLogFriendly for Boolean = fn() = this
impl JsLogFriendly for String = fn() = this
impl JsLogFriendly for Function = fn() = this.name

@def_call
fn js_log_friendly() {
  if this::nil?() || !this[JsLogFriendly] {
    return this
  } else {
    return this[JsLogFriendly]()
  }
}

@def_call
fn log(...args) {
  console.log(...args, this::js_log_friendly())
  return this
}

// Global Helpers

fn str(...args) = args.join("")
@def_call
fn nan?() = Number.isNaN(this)
@def_call
fn num?() = typeof(this) == "number"
@def_call
fn bigint?() = typeof(this) == "bigint"
@def_call
fn str?() = typeof(this) == "string"
@def_call
fn as_keyword() = Keyword["for"](this.toString())
@def_call
fn as_num() = Number(this)
@def_call
fn as_str() {
  if this::nil?() {
    return ""
  } else {
    return this.toString()
  }
}
@def_call
fn exists?() = !this::nil?()

// Underscore

// I'm starting to think this is not as useful as it once was
fn Underscore(@transforms) {}

protocol UnderscoreInterpreter

let _ = new Underscore([{f: fn id() = this, args: []}])

impl :insert for Underscore = fn(f, ...args) =
  new Underscore(this.transforms::push({f, args}))

impl UnderscoreInterpreter for Object = fn(underscore) {
  let initial_value = this
  let result = initial_value
  for {f args} of underscore.transforms {
    result = result::f::call(...args)
    // this may not always be true, but this handles And, and Or
    if result is Underscore {
      // we could do something like f[UnderscoreInterpreter]::call(result, initial_value)
      // but I'm not 100% sure
      result = result::call(initial_value)
    }
  }
  return result
}

impl Call for Underscore = fn(data, ...args) {
  if data::nil?() {
    return Object.prototype[UnderscoreInterpreter].call(data, this, ...args)
  } else {
    return data[UnderscoreInterpreter](this, ...args)
  }
}

impl Comparable for Underscore = {
  fn less_than(val) = this.insert(less_than, val)
  fn greater_than(val) = this.insert(greater_than, val)
  fn less_than_eq(val) = this.insert(less_than_eq, val)
  fn greater_than_eq(val) = this.insert(greater_than_eq, val)
}

impl Negate for Underscore = fn() = this.insert(negate)
impl Equal for Underscore = fn(other) = this.insert(equals?, other)

impl Record for Underscore = {
  fn at(key) = this.insert(at, key)
  fn insert(key, value) = this.insert(insert, key, value)
  fn merge(other) = this.insert(merge, other)
  fn has?(k) = this.insert(has?, k)
  fn len() = this.insert(len)
  fn last() = this.insert(last)
}
impl Vector for Underscore = {
  fn at(key) = this.insert(at, key)
  fn push(value) = this.insert(push, value)
  fn prepend(value) = this.insert(prepend, value)
  fn concat(other) = this.insert(concat, other)
  fn replace(old_value, new_value) = this.insert(has?, old_value, new_value)
  fn len() = this.insert(len)
  fn has?(k) = this.insert(has?, k)
  fn last() = this.insert(last)
}
impl Pipe for Underscore = fn(f) = this.insert(pipe, f)
impl And for Underscore = fn(thunk) = this.insert(and, thunk)
impl Or for Underscore = fn(thunk) = this.insert(or, thunk)
impl Plus for Underscore = fn(other) = this.insert(plus, other)
impl Minus for Underscore = fn(other) = this.insert(minus, other)
impl Times for Underscore = fn(other) = this.insert(times, other)
impl Divide for Underscore = fn(other) = this.insert(divide, other)
impl Exponent for Underscore = fn(other) = this.insert(exponent, other)
impl Mod for Underscore = fn(other) = this.insert(mod, other)

// this is kind of shaky but its good enough
impl JsLogFriendly for Underscore = fn() {
  let fn_to_op = ~Map{
    "greater_than" => ">"
    "greater_than_eq" => ">="
    "less_than" => "<"
    "less_than_eq" => "<="
    "times" => "*"
    "exponent" => "**"
    "divide_by" => "/"
    "plus" => "+"
    "minus" => "-"
    "mod" => "%"
    "eq__q" => "=="
    "and" => "&&"
    "or" => "||"
  }
  return str("_"
    this.transforms
      ::skip(1)
      ::map(fn({f, args}) {
        let fn_name = f::js_log_friendly()
        if let op = fn_to_op::call(fn_name) {
          let [rhs] = args
          if #{and, or}::call(f) { rhs = rhs() }
          return str(" " op " " rhs::js_log_friendly())
        } else {
          let formatted_args = args::map(js_log_friendly)::join(", ")
          return str("::" fn_name "(" formatted_args ")")
        }
      })
      ::into(""))
}

// Ranges

protocol Inc

impl Inc for Number = fn() = this + 1
impl Inc for BigInt = fn() = this + 1n
impl Inc for String = fn() = String.fromCharCode(this.charCodeAt(0) + 1)

fn inc() = this[Inc]()

@impl_equal(:start, :end)
fn IRange(@start, @end) {}
@impl_equal(:start, :end)
fn ERange(@start, @end) {}
@impl_equal(:end)
fn IRangeNoMin(@end) {}
@impl_equal(:start)
fn ERangeNoMax(@start) {}
@impl_equal(:end)
fn ERangeNoMin(@end) {}

impl Call for IRange = fn(value) = value >= this.start && value <= this.end
impl Call for ERange = fn(value) = value >= this.start && value < this.end
impl Call for IRangeNoMin = fn(value) = value <= this.end
impl Call for ERangeNoMax = fn(value) = value >= this.start
impl Call for ERangeNoMin = fn(value) = value < this.end

impl JsLogFriendly for IRange = fn() = str(this.start "..=" this.end)
impl JsLogFriendly for ERange = fn() = str(this.start ".." this.end)
impl JsLogFriendly for IRangeNoMin = fn() = str("..=" this.end)
impl JsLogFriendly for ERangeNoMax = fn() = str(this.start "..")
impl JsLogFriendly for ERangeNoMin = fn() = str(".." this.end)

impl Symbol.iterator for IRange = fn*() {
  let {start: i, end} = this
  while i <= end {
    yield i
    i = i::inc()
  }
}
impl Symbol.iterator for ERange = fn*() {
  let {start: i, end} = this
  while i < end {
    yield i
    i = i::inc()
  }
}
impl Symbol.iterator for ERangeNoMax = fn*() {
  let i = this.start
  loop {
    yield i
    i = i::inc()
  }
}

fn def_vector(Constructor) {
  define Vector for Constructor = fn(args) = new Constructor(...args)
  return Constructor
}

fn def_record(Constructor) {
  define Record for Constructor = fn(entries) = new Constructor(entries)
  impl Symbol.iterator for Constructor = fn() = this.entries::iter()
  return Constructor
}

// string helpers
let char_alpha? = ("a"..="z")::into(#{}) + ("A"..="Z")::into(#{})
let char_numeric? = ("0"..="9")::into(#{})
let char_alpha_numeric? = char_alpha? + char_numeric?
fn alpha?() = this::all?(char_alpha?)
fn alpha_numeric?() = this::all?(char_alpha_numeric?)

@def_record
fn CallMap(@entries) {}
impl Call for CallMap = fn(value) =
  ::find(fn([callable, _]) = callable::call(value))
  ::pipe(fn([_, val]) = val)

// GLOBAL EXPORTS

define :Call for globalThis = Call
define :call for globalThis = call
define :nil? for globalThis = nil?
define :Pipe for globalThis = Pipe
define :pipe for globalThis = pipe
define :compose for globalThis = compose
define :iter for globalThis = iter
define :Iterable for globalThis = Iterable
define :skip for globalThis = skip
define :take for globalThis = take
define :drop for globalThis = drop
define :each for globalThis = each
define :until for globalThis = until
define :zip for globalThis = zip
define :map for globalThis = map
define :flat_map for globalThis = flat_map
define :find for globalThis = find
define :split for globalThis = split
define :keep for globalThis = keep
define :reject for globalThis = reject
define :any? for globalThis = any?
define :all? for globalThis = all?
define :reduce for globalThis = reduce
define :Record for globalThis = Record
define :insert for globalThis = insert
define :merge for globalThis = merge
define :keys for globalThis = keys
define :record? for globalThis = record?
define :construct_record for globalThis = construct_record
define :Vector for globalThis = Vector
define :vector? for globalThis = vector?
define :at for globalThis = at
define :push for globalThis = push
define :prepend for globalThis = prepend
define :concat for globalThis = concat
define :has? for globalThis = has?
define :replace for globalThis = replace
define :len for globalThis = len
define :first for globalThis = first
define :last for globalThis = last
define :empty? for globalThis = empty?
define :not_empty? for globalThis = not_empty?
define :construct_vector for globalThis = construct_vector
define :Equal for globalThis = Equal
define :equals? for globalThis = equals?
define :Plus for globalThis = Plus
define :Negate for globalThis = Negate
define :Minus for globalThis = Minus
define :Times for globalThis = Times
define :Divide for globalThis = Divide
define :Exponent for globalThis = Exponent
define :Mod for globalThis = Mod
define :Comparable for globalThis = Comparable
define :LessThan for globalThis = LessThan
define :And for globalThis = And
define :Or for globalThis = Or
define :plus for globalThis = plus
define :negate for globalThis = negate
define :minus for globalThis = minus
define :times for globalThis = times
define :divide_by for globalThis = divide_by
define :exponent for globalThis = exponent
define :mod for globalThis = mod
define :greater_than for globalThis = greater_than
define :greater_than_eq for globalThis = greater_than_eq
define :less_than for globalThis = less_than
define :less_than_eq for globalThis = less_than_eq
define :and for globalThis = and
define :or for globalThis = or
define :log for globalThis = log
define :str for globalThis = str
define :nan? for globalThis = nan?
define :str? for globalThis = str?
define :as_keyword for globalThis = as_keyword
define :as_num for globalThis = as_num
define :as_str for globalThis = as_str
define :exists? for globalThis = exists?
define :Negate for globalThis = Negate
define :Underscore for globalThis = Underscore
define :_ for globalThis = _
define :Inc for globalThis = Inc
define :inc for globalThis = inc
define :IRange for globalThis = IRange
define :ERange for globalThis = ERange
define :alpha? for globalThis = alpha?
define :alpha_numeric? for globalThis = alpha_numeric?
define :def_vector for globalThis = def_vector
define :def_record for globalThis = def_record
define :def_call for globalThis = def_call
