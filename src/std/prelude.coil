// CALL PROTOCOL

protocol Call

impl Call for Symbol = fn(obj, ...args) = obj[this](...args)
impl Call for Function = fn(...args) = this(...args)
impl Call for Set = fn(key) = this.has(key)
impl Call for Map = fn(key) = this.get(key)
impl Call for ObjectLiteral = fn(key) = this[key]
impl Call for Array = fn(index) = this.at(index)
impl Call for String = fn(collection) {
  if typeof(collection) === "string" || collection is Keyword {
    raise!(new TypeError("Can't 'call' a string with " + collection::as_str()))
  } else {
    return collection::call(this)
  }
}
impl Call for Number = fn(collection) {
  if collection is Keyword {
    return this[collection]
  } else {
    return collection::call(this)
  }
}
impl Call for Keyword = fn(collection) {
  if collection is Keyword || typeof(collection) === "string" {
    raise!(new TypeError("Can't 'call' a keyword with" + collection::as_str()))
  } else if Call keyof collection {
    return collection::call(this)
  } else {
    return collection[this]
  }
}

fn call(...args) = this&.[Call](...args)

// make sets and map callable using bind syntax
impl :bind for Set = fn(val) = ::fn() = this::call(val)
impl :bind for Map = fn(val) = ::fn() = this::call(val)

let nil? = Object.freeze(#{undefined null})

protocol Pipe

impl Pipe for Object = fn(callable) = callable::call(this)

fn pipe_one(callable) {
  if this::nil?() {
    return callable::call(this)
  } else {
    return this[Pipe](callable)
  }
}

fn pipe(...callables) =
  callables::iter()::reduce(fn(r, c) = r::pipe_one(c), this)

fn compose(first_fn, ...fns) = fn(...args) =
  fns::iter()::reduce(fn (result, f) = f::call(result), first_fn::call(...args))

fn impl_callable(f) {
  define Call for f = fn(first, ...rest) = first::f(...rest)
  return f
}

// Iterable & OrderedIterable Protocols

@impl_callable
fn iter() = this[Symbol.iterator]()

let ArrayIterator = Object.getPrototypeOf([]::iter())
let MapIterator = Object.getPrototypeOf(new Map()::iter())
let StringIterator = Object.getPrototypeOf(""::iter())
let SetIterator = Object.getPrototypeOf(#{}::iter())
let GeneratorFunction = Object.getPrototypeOf(fn*(){})

protocol Iterable

let iterable_collection_impl = {
  fn empty?() = this.next().done
  fn* take(n) {
    for [elem i] of this::zip(0..) {
      if i == n { break }
      yield elem
    }
  }
  fn* drop(n) {
    let size = this::len()
    for [elem i] of this::zip(0..) {
      if (size - i) > n { break }
      yield elem
    }
  }
  fn* until(f) {
    for elem of this {
      if f(elem) { break }
      yield elem
    }
  }
  fn* skip(n) {
    for [elem i] of this::zip(0..) {
      if i < n { continue }
      yield elem
    }
  }
  fn find(f) {
    for elem of this {
      if f(elem) {
        return elem
      }
    }
  }
  fn* zip(...collections) {
    let generators = [this, ...collections]::iter()::map(iter)::as_array()
    loop {
      let gen_states = generators::iter()::map(#(&.next()))::as_array()
      
      if gen_states::iter()::any?(:done) { break }
      yield gen_states::iter()::map(:value)::as_array()
    }
  }
  fn reduce(f, start) {
    let acc = start
    for elem of this {
      acc = f(acc, elem)
    }
    return acc
  }
  fn* map(f) {
    for elem of this {
      yield f(elem)
    }
  }
  fn* flat_map(f) {
    for elem of this {
      yield* f(elem)
    }
  }
  fn each(f) {
    for elem of this {
      f(elem)
    }
  }
  fn* keep(f) {
    for elem of this {
      if f(elem) {
        yield elem
      }
    }
  }
  fn all?(f) {  
    for elem of this {
      if !f(elem) {
        return false
      }
    }
    return true
  }
  fn any?(f) {
    for elem of this {
      if f(elem) {
        return true
      }
    }
    return false
  }
}

define Iterable for ArrayIterator = iterable_collection_impl
define Iterable for StringIterator = iterable_collection_impl
define Iterable for MapIterator = iterable_collection_impl
define Iterable for SetIterator = iterable_collection_impl
impl Iterable for GeneratorFunction = iterable_collection_impl

fn skip(n) = this[Iterable].skip.call(this, n)
fn take(n) = this[Iterable].take.call(this, n)
fn drop(n) = this[Iterable].drop.call(this, n)
fn each(f) = this[Iterable].each.call(this, f::call)
fn until(f) = this[Iterable].until.call(this, f::call)
fn zip(...iterables) = this[Iterable].zip.call(this, ...iterables)
fn map(...fns) = this[Iterable].map.call(this, compose(...fns))
fn flat_map(...fns) = this[Iterable].flat_map.call(this, compose(...fns))
fn find(f) = this[Iterable].find.call(this, f::call)
fn keep(f) = this[Iterable].keep.call(this, f::call)
fn reject(f) = this::keep(compose(f, !_))
fn any?(...fns) = this[Iterable].any?.call(this, compose(...fns))
fn all?(...fns) = this[Iterable].all?.call(this, compose(...fns))
fn reduce(f, start) {
  if start::nil?() && f[Identity] {
    start = f[Identity]
  }
  return this[Iterable].reduce.call(this, f::call, start)
}

protocol ReversedIterator

fn* _reversed_impl() {
  for i of 1..this::len() {
    yield this.at(i * -1)
  }
}

impl ReversedIterator for Array = _reversed_impl
impl ReversedIterator for String = _reversed_impl

@impl_callable
fn reversed() = this[ReversedIterator]()

// RECORD AND VECTOR PROTOCOLS

protocol Record

impl Record for ObjectLiteral = {
  fn at(key) = this[key]
  fn insert(key, value) = {...this, [key]: value}
  fn merge(other) = {...this, ...other}
  fn keys() = Object.keys(this)
  fn has?(key) = key keyof this
  fn len() = this::keys().length
  fn empty?() = this::len() == 0
}

impl Record for Map = {
  fn at(key) = this.get(key)
  fn insert(key, value) = this.set(key, value)
  fn merge(other) = new Map([...this.entries(), ...other.entries()])
  fn keys() = this.keys()
  fn has?(key) = this.has(key)
  fn len() = this.size
  fn empty?() = this.size === 0
  fn first() = this.entries().next().value
}

fn insert(key, value) = this[Record].insert.call(this, key, value)
fn merge(other) = this[Record].merge.call(this, other)
fn keys() = this[Record].keys.call(this)

define Record for Map = fn(entries) = new Map(entries)

fn record?() = this[Record]::exists?()
fn construct_record(entries) = this[Record](entries)

protocol Vector

fn vector?() = this[Vector]::exists?()

impl Vector for Array = {
  fn at(idx) = this.at(idx)
  fn push(value) = [...this, value]
  fn concat(other) = [...this, ...other]
  fn has?(value) = this::any?(_ == value)
  fn replace(old_value, new_value) =
    this::iter()::map(fn(val) {
      if val == old_value { return new_value }
      else { return val }
    })::as_array()
  fn len() = this.length
  fn empty?() = this.length === 0
  fn first() = this[0]
  fn last() = this.at(-1)
}

impl Vector for Set = {
  fn push(value) = [...this, value]
  fn concat(other) = new Set([...this, ...other])
  fn has?(value) = this.has(value)
  fn replace(old_value, new_value) {
    let self = new Set(this)  
    self.delete(old_value)
    return self.add(new_value)
  }
  fn len() = this.size
  fn empty?() = this.size === 0
}

impl Vector for String = {
  fn push(value) = this + value
  fn concat(other) = this + other
  fn has?(value) = this.includes(value)
  fn replace(old_value, new_value) = this.replace(old_value, new_value)
  fn len() = this.length
  fn empty?() = this.length === 0
  fn first() = this[0]
  fn last() = this.at(-1)
}

fn at(idx_or_key) = (this[Vector] || this[Record]).at.call(this, idx_or_key)
fn push(value) = this[Vector].push.call(this, value)
fn concat(other) = this[Vector].concat.call(this, other)
fn has?(value) = (this[Vector] || this[Record]).has?.call(this, value)
fn replace(old_value, new_value) =
  this[Vector].replace.call(this, old_value, new_value)
@impl_callable
fn len() = (this[Vector] || this[Record]).len.call(this)
@impl_callable
fn first() = (this[Vector] || this[Record]).first.call(this)
@impl_callable
fn last() = (this[Vector] || this[Record]).last.call(this)
fn empty?() {
  if this::nil?() {
    return true
  } else {
    return (this[Vector] || this[Record] || this[Iterable]).empty?.call(this)
  }
}
fn not_empty?() = !this::empty?()

define Vector for Array = fn(entries) = entries

fn construct_vector(entries) = this[Vector](entries)

// STRUCT
// I like this, but I'm not sure if it should be in the prelude..
protocol Validation
protocol Constructors
// This needs to be more thought out
// what if I want to default options.schema to {}, without
// overriding the rest of options
protocol Defaults

fn StructValidationError(message) {
  this.name = "StructValidationError"
  this.message = message
  this.stack = (new Error()).stack
}
StructValidationError.prototype = new Error()

fn validate_struct(struct_name) {
  if !(Validation keyof this) { return true }

  fn error_msg(key, validator) =
    str(struct_name " validation failed.\n"
        "Failed at " key ".\n"
        "Expected [" validator "]"
        ", got value " this[key] ".")

  for [key, validator] of this[Validation] {  
    if validator::matches?(this[key]) {
      continue
    } else {
      raise!(new StructValidationError(this::error_msg(key, validator)))
    }
  }
}

fn construct_struct_values() {
  if !(Constructors keyof this) { return null }
  for [key f] of this[Constructors] {
    if typeof(f) == "function" { f = this::f }
    if let prop_val = f::call(this[key]) {
      this[key] = prop_val
    }
  }
}

fn set_struct_defaults() {
  if !(Defaults keyof this) { return null }
  for [key fallback] of this[Defaults] {
    if this[key]::exists?() {
      continue
    } else {
      this[key] = fallback
    }
  }
}

fn Struct(name, ...properties) {
  fn Constructor(...args) {
    let i = 0
    for key of properties {
      this[key] = args[i]
      i += 1
    }
    this::validate_struct(name)
    this::construct_struct_values(this)
    this::set_struct_defaults(this)
  }
  // This doesn't work >:(
  Object.defineProperty(Constructor, "name", { value: name })
  return Constructor
}
define Vector for Struct = fn(args) = Struct(...args)

// EQUAL PROTOCOl

protocol Equal

fn strict_eq?(other) = this === other

impl Equal for Object = strict_eq?

fn vector_eq?(other) {
  if this.constructor !== other.constructor { return false }
  if this::len() != other::len() { return false }
  return this::iter()::zip(other)::all?(fn([a, b]) = a == b)
}

fn record_eq?(other) {
  if this.constructor !== other.constructor { return false }
  if this::len() != other::len() { return false }
  return this::iter()::all?(fn([key, value]) = other::at(key) == value)
}

impl Equal for Set = vector_eq?
impl Equal for Array = vector_eq?
impl Equal for Map = record_eq?
impl Equal for ObjectLiteral = record_eq?

@impl_callable
fn eq?(other) {
  if this::nil?() {
    return this === other
  } else {
    return this[Equal](other)
  }
}

// IDENTITY PROTOCOL
protocol Identity

impl Identity for Number = 0
impl Identity for BigInt = 0n
impl Identity for String = ""

fn identity() {
  if this::nil?() {
    return this
  } else {
    return this[Identity]
  }
}

// OPERATORS

protocol Plus
protocol Negate
protocol Minus
protocol Times
protocol Divide
protocol Exponent
protocol Mod
protocol Comparable
protocol LessThan
protocol And
protocol Or

impl Negate for Object = fn() = js_negate(this)
impl And for Object = fn(thunk) = js_and(this, thunk)
impl Or for Object = fn(thunk) = js_or(this, thunk)
impl Plus for Set = fn(other_set) = this::concat(other_set)
impl Plus for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_plus(this, other)
}
impl Minus for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_minus(this, other)
}
impl Times for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_times(this, other)
}
impl Divide for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_divide(this, other)
}
impl Exponent for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_exponent(this, other)
}
impl Mod for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_mod(this, other)
}
impl Plus for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_plus(this, other)
}
impl Minus for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_minus(this, other)
}
impl Times for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_times(this, other)
}
impl Divide for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_divide(this, other)
}
impl Exponent for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_exponent(this, other)
}
impl Mod for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_mod(this, other)
}
let ComparableMixin = {
  fn greater_than_eq(other) = this::greater_than(other) || (this == other)
  fn less_than_eq(other) = this::less_than(other) || (this == other)
}
impl Comparable for Number = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "number"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "number"
    return js_less_than(this, other)
  }
}
impl Comparable for BigInt = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "bigint"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "bigint"
    return js_less_than(this, other)
  }
}
impl Plus for String = fn(other) {
  assert! typeof(other) === "string"
  return js_plus(this, other)
}
impl Times for String = fn(amount) {
  assert! typeof(amount) === "number"
  return this.repeat(amount)
}
impl Comparable for String = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "string"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "string"
    return js_less_than(this, other)
  }
}

@impl_callable
fn plus(other) {
  if this[Plus] {
    return this[Plus](other)
  } else {
    return (this::concat || this::merge)(other) 
  }
}

@impl_callable
fn negate() {
  if this::nil?() {
    return true
  } else {
    return this[Negate]()
  }
}
fn minus(other) = this[Minus](other)
fn times(other) = this[Times](other)
fn divide_by(other) = this[Divide](other)
fn exponent(other) = this[Exponent](other)
fn mod(other) = this[Mod](other)
fn greater_than(other) = this[Comparable].greater_than.call(this, other)
fn greater_than_eq(other) = this[Comparable].greater_than_eq.call(this, other)
fn less_than(other) = this[Comparable].less_than.call(this, other)
fn less_than_eq(other) = this[Comparable].less_than_eq.call(this, other)
fn and(thunk) {
  if this::nil?() {
    return this
  } else {
    return this[And](thunk)
  }
}
fn or(thunk) {
  if this::nil?() {
    return thunk()
  } else {
    return this[Or](thunk)
  }
}

// Printable

protocol Printable

fn _resolve_keyword_str(kw) = kw::replace("__q", "?")::replace("__b", "!")

impl Printable for ObjectLiteral = fn() =
  Object.assign(
    new Object(),
    this::iter()
        ::map(fn ([k, v]) = [_resolve_keyword_str(k), v::printable()])
        ::as_obj()
  )

impl Printable for Map = fn() =
  ::iter()::map(fn ([k, v]) = [k::printable(), v::printable()])::as_map()

impl Printable for Array = fn() = ::iter()::map(printable)::as_array()
impl Printable for Set = fn() = str("#{" this::iter()::map(printable)::as_array().join(", ") "}")
impl Printable for Keyword = fn() = ":" + _resolve_keyword_str(this.value)
impl Printable for Boolean = fn() = this
impl Printable for String = fn() = this
impl Printable for Function = fn() = this.name

@impl_callable
fn printable() {
  if this::nil?() || !this[Printable] {
    return this
  } else {
    return this[Printable]()
  }
}

@impl_callable
fn log(...args) {  
  console.log(...args, this::printable())
  return this
}

// Helpers

fn str(...args) = args.join("")
@impl_callable
fn nan?() = Number.isNaN(this)
@impl_callable
fn str?() = typeof(this) == "string"
@impl_callable
fn as_set() = new Set(this)
@impl_callable
fn as_array() = Array["from"](this)
@impl_callable
fn as_obj() = ObjectLiteral.from_entries(this)
@impl_callable
fn as_map() = new Map(this)
@impl_callable
fn as_keyword() = Keyword["for"](this.toString())
@impl_callable
fn as_num() = Number(this)
@impl_callable
fn as_str() = this.toString()
@impl_callable
fn exists?() = !this::nil?()

impl Negate for Set = fn() = #(!this.has(&))

// Underscore

let Underscore = ~Struct["Underscore" :transforms]

protocol UnderscoreInterpreter

let _ = new Underscore([{f: fn id() = this, args: []}])

// this is weird, see my comment on impl Iterable for Underscore
impl Symbol.iterator for Underscore = fn() = this.insert(iter)

impl :insert for Underscore = fn(f, ...args) =
  new Underscore([...this.transforms, {f, args}])

impl UnderscoreInterpreter for Object = fn(underscore) {
  let initial_value = this  
  let result = initial_value
  for {f args} of underscore.transforms {
    result = result::f::call(...args)
    // this may not always be true, but this handles And, and Or
    if result is Underscore {
      // we could do something like f[UnderscoreInterpreter]::call(result, initial_value)
      // but I'm not 100% sure
      result = result::call(initial_value)
    }
  }
  return result
}

impl Call for Underscore = fn(data, ...args) {
  if data::nil?() {
    return Object.prototype[UnderscoreInterpreter].call(data, this, ...args)
  } else {
    return data[UnderscoreInterpreter](this, ...args)
  }
}

impl Comparable for Underscore = {
  fn less_than(val) = this.insert(less_than, val)
  fn greater_than(val) = this.insert(greater_than, val)
  fn less_than_eq(val) = this.insert(less_than_eq, val)
  fn greater_than_eq(val) = this.insert(greater_than_eq, val)
}

impl Negate for Underscore = fn() = this.insert(negate)
impl Equal for Underscore = fn(other) = this.insert(eq?, other)

// Although I think this is cool.. it may be overkill
// how often will we be using Underscore this way?
impl Iterable for Underscore = {
  fn empty?() = this.insert(empty?)
  fn first() = this.insert(first)
  fn take() = this.insert(take)
  fn skip() = this.insert(skip)
  fn find(f) = this.insert(find, f)
  fn reduce(f, start) = this.insert(reduce, f, start)
  fn map(f) = this.insert(map, f)
  fn flat_map(f) = this.insert(flat_map, f)
  fn each(f) = this.insert(each, f)
  fn keep(f) = this.insert(keep, f)
  fn all?(f) = this.insert(all? f)
  fn any?(f) = this.insert(any?, f)
}
impl ReversedIterator for Underscore = fn() = this.insert(reversed)
impl Record for Underscore = {
  fn at(key) = this.insert(at, key)
  fn insert(key, value) = this.insert(insert, key, value)
  fn merge(other) = this.insert(merge, other)
  fn has?(k) = this.insert(has?, k)
  fn len() = this.insert(len)
}
impl Vector for Underscore = {
  fn push(value) = this.insert(push, value)
  fn concat(other) = this.insert(concat, other)
  fn replace(old_value, new_value) = this.insert(has?, old_value, new_value)
}

impl Pipe for Underscore = fn(f) = this.insert(pipe, f)
impl And for Underscore = fn(thunk) = this.insert(and, thunk)
impl Or for Underscore = fn(thunk) = this.insert(or, thunk)
impl Plus for Underscore = fn(other) = this.insert(plus, other)
impl Minus for Underscore = fn(other) = this.insert(minus, other)
impl Times for Underscore = fn(other) = this.insert(times, other)
impl Divide for Underscore = fn(other) = this.insert(divide, other)
impl Exponent for Underscore = fn(other) = this.insert(exponent, other)
impl Mod for Underscore = fn(other) = this.insert(mod, other)

// this is kind of shaky but its good enough
impl Printable for Underscore = fn() {
  let fn_to_op = ~Map{
    "greater_than" => ">"
    "greater_than_eq" => ">="
    "less_than" => "<"
    "less_than_eq" => "<="
    "times" => "*"
    "exponent" => "**"
    "divide_by" => "/"
    "plus" => "+"
    "minus" => "-"
    "mod" => "%"
    "eq__q" => "=="
  }  
  return str("_" this.transforms::iter()::skip(1)::map(fn({f, args}) {
    if f == and {
      let [thunk] = args
      return str(" && " thunk()::printable())
    } else if f == or {
      let [thunk] = args
      return str(" || " thunk()::printable())
    }
    let s = f::printable()
    if let op = fn_to_op::call(s) {
      let [rhs] = args
      return str(" " op " " rhs::printable())
    } else {
      return str("::" s "(" args::map(printable).join(", ") ")")
    }
  })::reduce(+))
}

// Ranges

protocol Inc

impl Inc for Number = fn() = this + 1
impl Inc for BigInt = fn() = this + 1n
impl Inc for String = fn() = String.fromCharCode(this.charCodeAt(0) + 1)

fn inc() = this[Inc]()

let IRange = ~Struct["IRange" :start :end]
let ERange = ~Struct["IRange" :start :end]

impl Call for IRange = fn(value) = value >= this.start && value <= this.end
impl Call for ERange = fn(value) = value >= this.start && value < this.end

impl Printable for IRange = fn() = str(this.start::printable() ".." this.end::printable())
impl Printable for ERange = fn() = str(this.start::printable() "..." this.end::printable())

impl Symbol.iterator for IRange = fn*() {
  let {start: i, end} = this
  while i <= end {
    yield i
    i = i::inc()
  }
}
impl Symbol.iterator for ERange = fn*() {
  let {start: i, end} = this
  while i < end {
    yield i
    i = i::inc()
  }
}

fn DefVector() {}

// This should be rethought.
// if it wants to be `dsl` like, it should not be adhoc like it is now..
define Vector for DefVector = fn(properties) {  
  let Constructor = null
  // TODO: this returns _ itself when its true
  // that's weird, but it still works.
  if properties::at(1) == _ {
    let kw = properties::at(2)
    Constructor = fn(fst, ...args) {
      this[properties::first()] = fst
      this[kw] = args
    }
  } else if properties::first() == _ {
    let kw = properties::at(1)
    Constructor = fn(...args) {
      this[kw] = args
    }
  } else {
    Constructor = fn(...args) {
      for [key i] of properties::iter()::zip(0..) {
        this[key] = args[i]
      }
    }
  }
  define Vector for Constructor = fn(args) = new Constructor(...args)
  return Constructor
}

fn DefRecord() {}

define Vector for DefRecord = fn(property_name) {
  let Constructor = fn (entries) { this[property_name] = entries }
  define Record for Constructor = fn(entries) = new Constructor(entries)
  impl Record for Constructor = {
    fn at(idx) = this.entries[idx]
    // fn insert(key, value) = ~Constructor{...this, key => value}
    // fn merge(other) = ~Constructor{...this, ...other}
    fn keys() = this.entries::iter()::map(first)
    fn has?(key) = this::keys()::has?(key)
    fn len() = this.entries.length
  }
  impl Symbol.iterator for Constructor = fn() = this.entries::iter()
  return Constructor
}

// Consider removing this or rethinking it
protocol Matches

fn matches?(value) = this[Matches](value)

impl Matches for Object = fn(value) {
  if typeof(this) != "object" && typeof(this) != "function" {
    return this == value
  } else if Call keyof this {
    return this::call(value)
  } else {
    return this == value
  }
}

impl Matches for Array = fn(arr) =
  arr::len() == this::len() &&
  this::iter()::zip(arr)::all?(fn([pattern, val]) = pattern::matches?(val))

impl Matches for Set = fn(value) = this::has?(value)

impl Matches for Underscore = fn(value) {
  if value::nil?() {
    return false
  } else {
    return this::call(value)
  }
}

impl Matches for ObjectLiteral = fn(record) =
  ::iter()::all?(fn(key, pattern) = pattern::matches?(record::at(key::as_keyword())))

let Match = ~DefRecord[:entries]

impl Call for Match = fn(val) =
  this.entries::iter()
    ::find(fn([pattern, _ret]) = pattern::matches?(val))
    ::pipe(1)

// string helpers
let char_alpha? = ("a".."z")::as_set() + ("A".."Z")::as_set()
let char_numeric? = ("0".."9")::as_set()
let char_alpha_numeric? = char_alpha? + char_numeric?
fn alpha?() = this::iter()::all?(char_alpha?)
fn alpha_numeric?() = this::iter()::all?(char_alpha_numeric?)
