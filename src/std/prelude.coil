// Doc Protocol

protocol Doc

fn doc(f, doc_str) {
  define Doc for f = doc_str.trim()
  return f
}

fn log_doc() {
  console.log(this[Doc])
  return this
}

// Call Protocol

protocol Call

impl Call for Function = fn(...args) = this(...args)
impl Call for Set = fn(key) = this.has(key)
impl Call for Map = fn(key) = this.get(key)
impl Call for ObjectLiteral = fn(key) = this[key]
impl Call for Array = fn(index) = this.at(index)
impl Call for String = fn(collection) {
  if typeof(collection) === "string" || collection is Keyword {
    raise!(new TypeError("Can't 'call' a string with " + collection::as_str()))
  } else {
    return collection::call(this)
  }
}
impl Call for Number = fn(collection) {
  if collection is Keyword {
    return this[collection]
  } else {
    return collection::call(this)
  }
}
impl Call for Keyword = fn(collection) {
  if collection is Keyword || typeof(collection) === "string" {
    raise!(new TypeError("Can't 'call' a keyword with" + collection::as_str()))
  } else if Call keyof collection {
    return collection::call(this)
  } else {
    return collection[this]
  }
}

@doc("
Invokes [[Call]] on 'this'


Usage:
- On Object Literals
  {a: 10}::call(:a) // 10
")
fn call(...args) = this&.[Call](...args)

// make sets callable using bind syntax
impl :bind for Set = fn(val) = ::fn() = this::call(val)

let nil? = Object.freeze(#{undefined null})

protocol Pipe

impl Pipe for Object = fn(callable) = callable::call(this)

@doc("
invokes [[Pipe]] protocol

args:
  ...callables: list of [[Call]] objects

returns:
  result of invoking 'callables' on this

nil handling:
  since nil doesn't impl Pipe, we'll call 'f' directly.

note on [[Pipe]]:
  pipe is protocol based so that it can be used with Underscore.
")
fn pipe(...callables) {
  let f = compose(...callables)
  return this&.[Pipe](f) ?? f(this)
}

@doc("
composes a list of [[Call]] objects into a single function

example:
  compose(:users 0 :id)({users: [{id: 123}]}) // -> 123 
")
fn compose(first_fn, ...fns) = fn(...args) =
  fns::reduce(fn (result, f) = f::call(result), first_fn::call(...args))

@doc("
decorator to define [[Call]]

takes f, and applies first argument as the 'this' arg.

this is helpful when you are writing functions that rely on 'this'
and don't have any arguments.

example:
  fn first() = this[0]

  // I want this to work.. but it doesn't
  [[1] [2] [3]]::map(first) // Error

  // if I use @def_call we can do this
  @def_call
  fn first() = this[0]

  [[1] [2] [3]]::map(first) // [1 2 3]  
")
fn def_call(f) {
  define Call for f = fn(first, ...rest) = first::f(...rest)
  return f
}

// Iterable Protocol

@def_call
fn iter() = this&.[Symbol.iterator]() || []::iter()

// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol
@def_call
fn iter?() = ::iter() === this

protocol Iterator

let default_iterator_impl = {
  fn* take(n) {
    for [elem i] of this::zip(0..) {
      if i == n {
        break
      } else {
        yield elem
      }
    }
  }
  fn* until(f) {
    for elem of this {
      if f(elem) {
        break
      } else {
        yield elem
      }
    }
  }
  fn* skip(n) {
    for [elem i] of this::zip(0..) {
      if i < n {
        continue
      } else {
        yield elem
      }
    }
  }
  fn find(f) {
    for elem of this {
      if f(elem) {
        return elem
      }
    }
  }
  fn* zip(...collections) {
    let generators = [this, ...collections]::map(iter)::into([])
    loop {
      let gen_states = generators::map(#(&.next()))::into([])
      if gen_states::any?(:done) {
        break
      } else {
        yield gen_states::map(:value)::into([])
      }
    }
  }
  fn reduce(f, start) {
    let acc = start
    for elem of this {
      acc = f(acc, elem)
    }
    return acc
  }
  fn* map(f) {
    for elem of this {
      yield f(elem)
    }
  }
  fn* flat_map(f) {
    for elem of this {
      yield* f(elem)
    }
  }
  fn each(f) {
    for elem of this {
      f(elem)
    }
  }
  fn* keep(f) {
    for elem of this {
      if f(elem) {
        yield elem
      }
    }
  }
  fn all?(f) {
    for elem of this {
      if !f(elem) {
        return false
      }
    }
    return true
  }
  fn any?(f) {
    for elem of this {
      if f(elem) {
        return true
      }
    }
    return false
  }
  fn* split(f) {
    let chunk = []
    for elem of this {
      if f(elem) {
        yield chunk
        chunk = []
      } else {
        chunk = chunk::push(elem)
      }
    }
    yield chunk
  }
  fn* compact() {
    for elem of this {
      if elem::nil?() {
        continue
      } else {
        yield elem
      }
    }
  }
}

fn iterator_impl() = this&.[Iterator] || default_iterator_impl

fn skip(n) = ::iterator_impl().skip.call(this::iter(), n)
fn take(n) = ::iterator_impl().take.call(this::iter(), n)
fn each(f) = ::iterator_impl().each.call(this::iter(), f::call)
fn until(...fns) = ::iterator_impl().until.call(this::iter(), compose(...fns))
fn zip(...iterables) = ::iterator_impl().zip.call(this::iter(), ...iterables)
fn map(...fns) = ::iterator_impl().map.call(this::iter(), compose(...fns))
fn flat_map(...fns) = ::iterator_impl().flat_map.call(this::iter(), compose(...fns))
fn find(...fns) = ::iterator_impl().find.call(this::iter(), compose(...fns))
fn keep(...fns) = ::iterator_impl().keep.call(this::iter(), compose(...fns))
fn reject(...fns) = ::keep(...fns, !_)
fn any?(...fns) = ::iterator_impl().any?.call(this::iter(), compose(...fns))
fn all?(...fns) = ::iterator_impl().all?.call(this::iter(), compose(...fns))
fn reduce(f, start) = ::iterator_impl().reduce.call(this::iter(), f::call, start)
fn split(...fns) = ::iterator_impl().split.call(this::iter(), compose(...fns))
fn compact() = ::iterator_impl().compact.call(this::iter())

fn join(sep) = ::reduce(fn(prev cur) {
  if prev::empty?() {
    return cur
  } else {
    return prev + sep + cur
  }
} "")

// INTO

protocol Into

impl Into for Array = fn(iterable) = [...this, ...iterable]
impl Into for ObjectLiteral = fn(iterable) = ::merge(iterable)
impl Into for Map = fn(iterable) = ::merge(iterable)
impl Into for Set = fn(iterable) = ::concat(iterable)
impl Into for String = fn(iterable) = this + iterable::reduce(+ "")
define Into for Object = fn(iterable) = Object.fromEntries(iterable)

fn into(val) = val[Into](this)

protocol Collection

impl Collection for ObjectLiteral = {
  fn at(key) = this[key]
  fn len() = Object.keys(this).length
  fn empty?() = this::len() === 0
  fn has?(key) = key keyof this
}

impl Collection for Array = {
  fn at(idx) = this.at(idx)
  fn len() = this.length
  fn empty?() = this.length === 0
  fn has?(val) = ::any?(_ == val)
}

impl Collection for Map = {
  fn at(key) = this.get(key)
  fn len() = this.size
  fn empty?() = this.size === 0
  fn has?(key) = this.has(key)
}

impl Collection for String = {
  fn at(idx) = this.at(idx)
  fn len() = this.length
  fn empty?() = this.length === 0
  fn has?(substr) = this.includes(substr)
}

impl Collection for Set = {
  fn at(val) = this.has(val) && val
  fn len() = this.size
  fn empty?() = this.size === 0
  fn has?(val) = this.has(val)
}

@def_call
fn len() = this[Collection].len.call(this)

@def_call
fn empty?() = this&.[Collection].empty?.call(this) ?? true

@def_call
fn not_empty?() = !this::empty?()

fn at(key_or_idx) = this[Collection].at.call(this, key_or_idx)

fn has?(val) = this[Collection].has?.call(this, val)

protocol Record

impl Record for ObjectLiteral = {
  fn insert(key, value) = {...this, [key]: value}
  fn merge(other) = ObjectLiteral.from_entries([...this, ...other])
  fn keys() = Object.keys(this)
  fn values() = Object.values(this)
}

impl Record for Map = {
  fn insert(key, value) = new Map([...this, [key, value]])
  fn merge(other) = new Map([...this, ...other])
  fn keys() = this.keys()
  fn values() = this.values()
}

@def_call
fn keys() = this[Record].keys.call(this)
@def_call
fn values() = this[Record].values.call(this)
fn insert(key, value) = this[Record].insert.call(this, key, value)
fn merge(other) = this[Record].merge.call(this, other)

define Record for Map = fn(entries) = new Map(entries)
define Record for Object = Object.fromEntries

fn record?() = this[Record]::exists?()
fn construct_record(entries) = this[Record](entries)

protocol Vector

fn vector?() = this[Vector]::exists?()

impl Vector for Array = {
  fn push(val) = [...this, val]
  fn replace(old_val, new_val) = ::map(fn(val) {
    if val == old_val {
      return new_val
    } else {
      return val
    }
  })
  fn concat(other) = [...this, ...other]
}

impl Vector for Set = {
  fn push(value) = new Set(this).add(value)
  fn replace(old_val, new_val) {
    let self = new Set(this)
    self.delete(old_value)
    self.add(new_val)
    return self
  }
  fn concat(other) = new Set([...this, ...other])
}

impl Vector for String = {
  fn push(val) = this + val
  fn replace(old_substr, new_substr) = this.replaceAll(old_substr, new_substr)
  fn concat(other) = this + other
}

fn push(val) = this[Vector].push.call(this, val)
fn replace(old_val, new_val) = this[Vector].replace.call(this, old_val, new_val)
fn concat(other) = this[Vector].concat.call(this, other)

protocol OrderedSequence

impl OrderedSequence for Array = {
  fn prepend(val) = [val, ...this]
  fn update_at(idx, f) {
    let [before after] = [this::take(idx) this::skip(idx + 1)]
    return [...before, f(::at(idx)), ...after]
  }
  fn insert_at(idx, val) {
    let [before after] = [this::take(idx) this::skip(idx + 1)]
    return [...before, val, ...after]
  }
  fn first() = this[0]
  fn last() = this.at(-1)
}

impl OrderedSequence for String = {
  fn prepend(val) = val + this
  fn update_at(idx, f) = this.slice(0, idx) + f(this.at(idx)) + this.slice(idx)
  fn insert_at(idx, val) = this.slice(0, idx) + val + this.slice(idx)
  fn first() = this[0]
  fn last() = this.at(-1)
}

fn prepend(val) = this[OrderedSequence].prepend.call(this, val)

fn update_at(idx, ...fns) = this[OrderedSequence].update_at.call(this, idx, compose(...fns))

fn insert_at(idx, val) = this[OrderedSequence].insert_at.call(this, idx, val)

@def_call
fn first() = this[OrderedSequence].first.call(this)

@def_call
fn last() = this[OrderedSequence].last.call(this)

define Vector for Array = fn(entries) = entries

fn construct_vector(entries) = this[Vector](entries)

// EQUAL PROTOCOl

protocol Equal

fn impl_equal(Ctor, ...keys) {
  impl Equal for Ctor = fn(other) =
    other is Ctor && keys::all?(::fn(key) = this[key] == other[key])
  return Ctor
}

impl Equal for Object = fn(other) = this === other

impl Equal for Set = fn(other) {
  if !(other is Set) { return false }
  if other.size !== this.size { return false }
  return ::all?(fn(val) = other.has(val))
}
impl Equal for Array = fn(other) {
  if !(other is Array) { return false }
  if other.length !== this.length { return false }
  return ::zip(other)::all?(fn([a, b]) = a == b)
}

fn record_equals?(other) {
  if this.constructor !== other.constructor { return false }
  if this::len() != other::len() { return false }
  return this::all?(fn([key, value]) = other::at(key) == value)
}
impl Equal for Map = record_equals?
impl Equal for ObjectLiteral = record_equals?

@def_call
fn equals?(other) = this&.[Equal](other) ?? this === other

// OPERATORS

protocol Plus
protocol Negate
protocol Minus
protocol Times
protocol Divide
protocol Exponent
protocol Mod
protocol Comparable
protocol LessThan
protocol And
protocol Or

fn expect_primitive_type!(type_str) {
  if typeof(this) !== type_str {
    raise!(str("Expected " type_str))
  }
}

impl Negate for Object = fn() = js_negate(this)
impl And for Object = fn(thunk) = js_and(this, thunk)
impl Or for Object = fn(thunk) = js_or(this, thunk)
impl Plus for Set = fn(other_set) = this::concat(other_set)
impl Plus for Array = fn(arr) = this::concat(arr)
impl Plus for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_plus(this, other)
}
impl Minus for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_minus(this, other)
}
impl Times for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_times(this, other)
}
impl Divide for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_divide(this, other)
}
impl Exponent for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_exponent(this, other)
}
impl Mod for Number = fn(other) {
  other::expect_primitive_type!("number")
  return js_mod(this, other)
}
impl Plus for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_plus(this, other)
}
impl Minus for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_minus(this, other)
}
impl Times for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_times(this, other)
}
impl Divide for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_divide(this, other)
}
impl Exponent for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_exponent(this, other)
}
impl Mod for BigInt = fn(other) {
  other::expect_primitive_type!("bigint")
  return js_mod(this, other)
}
impl Comparable for Number = {
  fn greater_than_eq(other) {
    other::expect_primitive_type!("number")
    return js_greater_than_eq(this, other)
  }
  fn less_than_eq(other) {
    other::expect_primitive_type!("number")
    return js_less_than_eq(this, other)
  }
  fn greater_than(other) {
    other::expect_primitive_type!("number")
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    other::expect_primitive_type!("number")
    return js_less_than(this, other)
  }
}
impl Comparable for BigInt = {
  fn greater_than_eq(other) {
    other::expect_primitive_type!("bigint")
    return js_greater_than_eq(this, other)
  }
  fn less_than_eq(other) {
    other::expect_primitive_type!("bigint")
    return js_less_than_eq(this, other)
  }
  fn greater_than(other) {
    other::expect_primitive_type!("bigint")
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    other::expect_primitive_type!("bigint")
    return js_less_than(this, other)
  }
}
impl Plus for String = fn(other) {
  other::expect_primitive_type!("string")
  return js_plus(this, other)
}
impl Times for String = fn(amount) {
  amount::expect_primitive_type!("number")
  return this.repeat(amount)
}
impl Comparable for String = {
  fn greater_than_eq(other) {
    other::expect_primitive_type!("string")
    return js_greater_than_eq(this, other)
  }
  fn less_than_eq(other) {
    other::expect_primitive_type!("string")
    return js_less_than_eq(this, other)
  }
  fn greater_than(other) {
    other::expect_primitive_type!("string")
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    other::expect_primitive_type!("string")
    return js_less_than(this, other)
  }
}

@def_call
fn plus(other) = this[Plus](other)
@def_call
fn negate() = this&.[Negate]() ?? true
fn minus(other) = this[Minus](other)
fn times(other) = this[Times](other)
fn divide_by(other) = this[Divide](other)
fn exponent(other) = this[Exponent](other)
fn mod(other) = this[Mod](other)
fn greater_than(other) = this[Comparable].greater_than.call(this, other)
fn greater_than_eq(other) = this[Comparable].greater_than_eq.call(this, other)
fn less_than(other) = this[Comparable].less_than.call(this, other)
fn less_than_eq(other) = this[Comparable].less_than_eq.call(this, other)
fn and(thunk) = this&.[And](thunk)
fn or(thunk) = this&.[Or](thunk) ?? thunk()

// This api is crufty, I'm not gonna lie.

protocol JsLogFriendly

impl JsLogFriendly for ObjectLiteral = fn() = ::into(Object)

impl JsLogFriendly for Map = fn() =
  ::map(fn ([k, v]) = [k::js_log_friendly(), v::js_log_friendly()])
  ::into(~Map{})

impl JsLogFriendly for Array = fn() = ::map(js_log_friendly)::into([])
impl JsLogFriendly for Set = fn() = str("#{" this::map(js_log_friendly as_str)::join(", ") "}")
impl JsLogFriendly for Keyword = fn() = str(":" this.value)
impl JsLogFriendly for Boolean = fn() = this
impl JsLogFriendly for String = fn() = this
impl JsLogFriendly for Function = fn() = this

@def_call
fn js_log_friendly() = this&.[JsLogFriendly]()

@def_call
fn log(...args) {
  console.log(...args, this::js_log_friendly())
  return this
}

// Global Helpers

fn str(...args) = args.join("")
@def_call
fn nan?() = Number.isNaN(this)
@def_call
fn num?() = typeof(this) == "number"
@def_call
fn bigint?() = typeof(this) == "bigint"
@def_call
fn str?() = typeof(this) == "string"
@def_call
fn as_keyword() = Keyword["for"](this.toString())
@def_call
fn as_num() = Number(this)
@def_call
fn as_str() = this&.toString() ?? ""
@def_call
fn exists?() = !this::nil?()

// Underscore

fn Underscore(@transforms) {}

protocol UnderscoreInterpreter

let _ = new Underscore([{f: fn id() = this, args: []}])

impl :insert for Underscore = fn(f, ...args) =
  new Underscore(this.transforms::push({f, args}))

impl UnderscoreInterpreter for Object = fn(underscore) {
  let initial_value = this
  let result = initial_value
  for {f args} of underscore.transforms {
    result = result::f::call(...args)
    // this may not always be true, but this handles And, and Or
    if result is Underscore {
      // we could do something like f[UnderscoreInterpreter]::call(result, initial_value)
      // but I'm not 100% sure
      result = result::call(initial_value)
    }
  }
  return result
}

impl Call for Underscore = fn(data, ...args) {
  if data::nil?() {
    return Object.prototype[UnderscoreInterpreter].call(data, this, ...args)
  } else {
    return data[UnderscoreInterpreter](this, ...args)
  }
}

impl Comparable for Underscore = {
  fn less_than(val) = this.insert(less_than, val)
  fn greater_than(val) = this.insert(greater_than, val)
  fn less_than_eq(val) = this.insert(less_than_eq, val)
  fn greater_than_eq(val) = this.insert(greater_than_eq, val)
}

impl Negate for Underscore = fn() = this.insert(negate)
impl Equal for Underscore = fn(other) = this.insert(equals?, other)
impl Collection for Underscore = {
  fn at(key) = this.insert(at, key)
  fn has?(k) = this.insert(has?, k)
  fn len() = this.insert(len)
  fn empty?() = this.insert(empty?)
}
impl Record for Underscore = {
  fn insert(key, value) = this.insert(insert, key, value)
  fn merge(other) = this.insert(merge, other)
  fn keys() = this.insert(keys)
  fn values() = this.insert(values)
}
impl OrderedSequence for Underscore = {
  fn prepend(value) = this.insert(prepend, value)
  fn update_at(idx, callable) = this.insert(update_at, idx, callable)
  fn insert_at(idx, val) = this.insert(insert_at, idx, val)
  fn first() = this.insert(first)
  fn last() = this.insert(last)
}
impl Vector for Underscore = {
  fn push(value) = this.insert(push, value)
  fn replace(old_value, new_value) = this.insert(has?, old_value, new_value)
  fn concat(other) = this.insert(concat, other)
}
impl Pipe for Underscore = fn(f) = this.insert(pipe, f)
impl And for Underscore = fn(thunk) = this.insert(and, thunk)
impl Or for Underscore = fn(thunk) = this.insert(or, thunk)
impl Plus for Underscore = fn(other) = this.insert(plus, other)
impl Minus for Underscore = fn(other) = this.insert(minus, other)
impl Times for Underscore = fn(other) = this.insert(times, other)
impl Divide for Underscore = fn(other) = this.insert(divide_by, other)
impl Exponent for Underscore = fn(other) = this.insert(exponent, other)
impl Mod for Underscore = fn(other) = this.insert(mod, other)

// this is kind of shaky but its good enough
impl JsLogFriendly for Underscore = fn() {
  let fn_to_op = ~Map{
    "greater_than" => ">"
    "greater_than_eq" => ">="
    "less_than" => "<"
    "less_than_eq" => "<="
    "times" => "*"
    "exponent" => "**"
    "divide_by" => "/"
    "plus" => "+"
    "minus" => "-"
    "mod" => "%"
    "eq__q" => "=="
    "and" => "&&"
    "or" => "||"
  }
  return str("_"
    this.transforms
      ::skip(1)
      ::map(fn({f, args}) {
        let fn_name = f::js_log_friendly()
        if let op = fn_to_op::call(fn_name) {
          let [rhs] = args
          if #{and, or}::call(f) { rhs = rhs() }
          return str(" " op " " rhs::js_log_friendly())
        } else {
          let formatted_args = args::map(js_log_friendly)::join(", ")
          return str("::" fn_name "(" formatted_args ")")
        }
      })
      ::into(""))
}

// Ranges

protocol Inc

impl Inc for Number = fn() = this + 1
impl Inc for BigInt = fn() = this + 1n
impl Inc for String = fn() = String.fromCharCode(this.charCodeAt(0) + 1)

fn inc() = this[Inc]()

@impl_equal(:start, :end)
fn IRange(@start, @end) {}
@impl_equal(:start, :end)
fn ERange(@start, @end) {}
@impl_equal(:end)
fn IRangeNoMin(@end) {}
@impl_equal(:start)
fn ERangeNoMax(@start) {}
@impl_equal(:end)
fn ERangeNoMin(@end) {}

impl Call for IRange = fn(value) = value >= this.start && value <= this.end
impl Call for ERange = fn(value) = value >= this.start && value < this.end
impl Call for IRangeNoMin = fn(value) = value <= this.end
impl Call for ERangeNoMax = fn(value) = value >= this.start
impl Call for ERangeNoMin = fn(value) = value < this.end

impl JsLogFriendly for IRange = fn() = str(this.start "..=" this.end)
impl JsLogFriendly for ERange = fn() = str(this.start ".." this.end)
impl JsLogFriendly for IRangeNoMin = fn() = str("..=" this.end)
impl JsLogFriendly for ERangeNoMax = fn() = str(this.start "..")
impl JsLogFriendly for ERangeNoMin = fn() = str(".." this.end)

impl Symbol.iterator for IRange = fn*() {
  let {start: i, end} = this
  while i <= end {
    yield i
    i = i::inc()
  }
}
impl Symbol.iterator for ERange = fn*() {
  let {start: i, end} = this
  while i < end {
    yield i
    i = i::inc()
  }
}
impl Symbol.iterator for ERangeNoMax = fn*() {
  let i = this.start
  loop {
    yield i
    i = i::inc()
  }
}

fn def_vector(Constructor) {
  define Vector for Constructor = fn(args) = new Constructor(...args)
  return Constructor
}

fn def_record(Constructor) {
  define Record for Constructor = fn(entries) = new Constructor(entries)
  impl Symbol.iterator for Constructor = fn() = this.entries::iter()
  return Constructor
}

// string helpers
let char_alpha? = ("a"..="z")::into(#{}) + ("A"..="Z")::into(#{})
let char_numeric? = ("0"..="9")::into(#{})
let char_alpha_numeric? = char_alpha? + char_numeric?
fn alpha?() = this::all?(char_alpha?)
fn alpha_numeric?() = this::all?(char_alpha_numeric?)

@def_record
fn CallMap(@entries) {}
impl Call for CallMap = fn(value) =
  ::find(fn([callable, _]) = callable::call(value))
  ::pipe(fn([_, val]) = val)

// GLOBAL EXPORTS

define :Call for globalThis = Call
define :call for globalThis = call
define :nil? for globalThis = nil?
define :Pipe for globalThis = Pipe
define :pipe for globalThis = pipe
define :compose for globalThis = compose
define :iter for globalThis = iter
define :Iterator for globalThis = Iterator
define :skip for globalThis = skip
define :take for globalThis = take
define :each for globalThis = each
define :until for globalThis = until
define :zip for globalThis = zip
define :map for globalThis = map
define :flat_map for globalThis = flat_map
define :find for globalThis = find
define :split for globalThis = split
define :keep for globalThis = keep
define :reject for globalThis = reject
define :any? for globalThis = any?
define :all? for globalThis = all?
define :reduce for globalThis = reduce
define :Record for globalThis = Record
define :insert for globalThis = insert
define :merge for globalThis = merge
define :keys for globalThis = keys
define :record? for globalThis = record?
define :construct_record for globalThis = construct_record
define :Vector for globalThis = Vector
define :vector? for globalThis = vector?
define :at for globalThis = at
define :push for globalThis = push
define :prepend for globalThis = prepend
define :concat for globalThis = concat
define :has? for globalThis = has?
define :replace for globalThis = replace
define :len for globalThis = len
define :first for globalThis = first
define :last for globalThis = last
define :empty? for globalThis = empty?
define :not_empty? for globalThis = not_empty?
define :construct_vector for globalThis = construct_vector
define :Equal for globalThis = Equal
define :equals? for globalThis = equals?
define :Plus for globalThis = Plus
define :Negate for globalThis = Negate
define :Minus for globalThis = Minus
define :Times for globalThis = Times
define :Divide for globalThis = Divide
define :Exponent for globalThis = Exponent
define :Mod for globalThis = Mod
define :Comparable for globalThis = Comparable
define :LessThan for globalThis = LessThan
define :And for globalThis = And
define :Or for globalThis = Or
define :plus for globalThis = plus
define :negate for globalThis = negate
define :minus for globalThis = minus
define :times for globalThis = times
define :divide_by for globalThis = divide_by
define :exponent for globalThis = exponent
define :mod for globalThis = mod
define :greater_than for globalThis = greater_than
define :greater_than_eq for globalThis = greater_than_eq
define :less_than for globalThis = less_than
define :less_than_eq for globalThis = less_than_eq
define :and for globalThis = and
define :or for globalThis = or
define :log for globalThis = log
define :str for globalThis = str
define :nan? for globalThis = nan?
define :str? for globalThis = str?
define :as_keyword for globalThis = as_keyword
define :as_num for globalThis = as_num
define :as_str for globalThis = as_str
define :exists? for globalThis = exists?
define :Negate for globalThis = Negate
define :Underscore for globalThis = Underscore
define :_ for globalThis = _
define :Inc for globalThis = Inc
define :inc for globalThis = inc
define :IRange for globalThis = IRange
define :ERange for globalThis = ERange
define :alpha? for globalThis = alpha?
define :alpha_numeric? for globalThis = alpha_numeric?
define :def_vector for globalThis = def_vector
define :def_record for globalThis = def_record
define :def_call for globalThis = def_call
