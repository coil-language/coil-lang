protocol Hash

impl Hash for String = fn() = js_str_hash(this)
impl Hash for Number = fn() = this
impl Hash for Keyword = fn() = ("____coil_keyword:" + this.value)::hash()
impl Hash for Array = fn() =
  ::reduce(fn(value, elem, idx) = (value * 31n) + elem::hash(), 7n)
impl Hash for ObjectLiteral = fn() =
  ::reduce(fn(value, entry) = (value * 31n) + entry::hash(), 7n)
impl Hash for Map = fn() =
  ::reduce(fn(hash_value, key, value) = (hash_value * 31n) + [key value]::hash(), 7n)

fn hash() = this[Hash]()

fn HashMap(entries) {
  this.raw_entries = entries  
  this.map = new Map(entries.map(fn([key, value]) = [key::hash(), value]))
}

impl Hash for HashMap = fn() = this.map::hash()

// Stepable protocol

protocol Stepable

impl Stepable for Number = {
  fn inc() = this + 1
  fn dec() = this - 1
}

impl Stepable for BigInt = {
  fn inc() = this + 1n
  fn dec() = this - 1n
}

fn inc() = this[Stepable].inc.call(this)
fn dec() = this[Stepable].dec.call(this)

// CONSTRUCT RECORD PROTOCOL

protocol Record

define Record for Map = fn(entries) = new Map(entries)
define Record for ObjectLiteral = fn(entries) = entries::from_entries()
define Record for HashMap = fn(entries) = new HashMap(entries)

fn truthy?() = truthy(this)

fn record?() = this.constructor[Record]::truthy?()
fn construct_record(entries) = this[Record](entries)

protocol Vector

define Vector for Array = fn(entries) = entries

fn construct_vector(entries) = this[Vector](entries)

protocol Deconstruct

impl Deconstruct for Map = fn() = this.entries()::from_entries()
impl Deconstruct for ObjectLiteral = fn() = this
impl Deconstruct for HashMap = fn() = this.raw_entries::from_entries()
impl Deconstruct for Array = fn() = this

fn deconstruct() = this[Deconstruct]()

// decorators
fn deconstruct_this(f) = fn() = ::f(this::deconstruct())
fn deconstruct_args(f) = fn(...args) = ::f(...args::map(#(&::deconstruct())))

// CALL PROTOCOL

protocol Call

impl Call for Function = fn(...args) = this(...args)

impl Call for Set = fn(key) = this.has(key)

impl Call for Map = fn(key) = this.get(key)

impl Call for ObjectLiteral = fn(key) = this[key]

impl Call for Array = fn(index) = this.at(index)

impl Call for HashMap = fn(key) = this::at(key)

impl Call for String = fn(collection) {
  if typeof(collection) === "string" || collection is Keyword {
    // make sure we don't end up in infinite loop  
    return collection[this]
  } else {
    return collection::call(this)
  }
}

impl Call for Number = fn(collection) {
  if collection is Keyword {
    return this[collection]
  } else {
    return collection::call(this)
  }
}

impl Call for Keyword = fn(collection) {
  if (collection is Keyword)
  || typeof(collection) === "string" {
    // again prevent infinite loop
    return collection[this]
  } else {
    return collection::call(this)
  }
}

fn call(...args) = this&.[Call](...args)

// make sets and map callable using bind syntax
impl :bind for Set = fn(val) = ::fn() = this::call(val)
impl :bind for Map = fn(val) = ::fn() = this::call(val)

protocol Pipe

impl Pipe for Object = fn(callable) = callable::call(this)

fn freeze() = Object.freeze(this)

let nil? = #{undefined null}::freeze()

fn pipe(callable) = this&.[Pipe](callable)

fn compose(first_fn, ...fns) = fn(...args) =
  fns::reduce(fn (result, f) = f::call(result), first_fn::call(...args))

fn impl_callable(f) {
  define Call for f = fn(first, ...rest) = first::f(...rest)
  return f
}

// EQUAL PROTOCOl

protocol Equal

fn strict_eq?(other) = this === other

impl Equal for Object = strict_eq?

fn vector_eq?(other) {
  if this::len() != other::len() { return false }
  return this::zip(other)::every?(fn([a, b]) = a == b)
}

fn record_eq?(other) {
  if !other::record?() { return false }
  if this::len() != other::len() { return false }
  return this::every?(fn(key, value) = other::at(key) == value)
}

impl Equal for Set = vector_eq?
impl Equal for Array = vector_eq?
impl Equal for Map = record_eq?
impl Equal for ObjectLiteral = record_eq?
impl Equal for HashMap = record_eq?

@impl_callable
fn eq?(other) {
  if this::nil?() {
    return this === other
  } else {
    return this[Equal](other)
  }
}

// CLONE PROTOCOL
protocol Clone

impl Clone for ObjectLiteral = {
  fn clone() = {...this}
  fn deep_clone() = this::map(fn(k, v) = [k, v::deep_clone()])
}

impl Clone for HashMap = {
  fn clone() = new HashMap(this.raw_entries.slice())
  fn deep_clone() = this::map(fn(k, v) = [k, v::deep_clone()])
}

impl Clone for Array = {
  fn clone() = this.slice()
  fn deep_clone() = this::map(deep_clone)
}

impl Clone for Map = {
  fn clone() = new Map(this)
  fn deep_clone() = this::map(deep_clone)
}

impl Clone for Set = {
  fn clone() = new Set(this)
  fn deep_clone() = this::map(deep_clone)
}

@impl_callable
fn clone() = this[Clone].clone.call(this)

@impl_callable
fn deep_clone() = this[Clone].deep_clone.call(this)

// IDENTITY PROTOCOL
// this defines the monoid identity for a given type (group)
protocol Identity

impl Identity for Number = 0
impl Identity for BigInt = 0n
impl Identity for String = ""
impl Identity for Array = []
impl Identity for ObjectLiteral = {}
impl Identity for Map = ~Map{}
impl Identity for HashMap = ~HashMap{}
impl Identity for Set = #{}

fn identity() {
  if this::nil?() {
    return this
  } else {
    return this[Identity]
  }
}

// COLLECTION PROTOCOL
protocol Collection

fn entries() = Object.entries(this)

fn from_entries() = new ObjectLiteral(Object.fromEntries(this))

fn values() = Object.values(this)

// Basics every object should impl this
impl Collection for Object = {
  fn at(key) = this[key]
  fn keys() = Object.keys(this)::as_set()
}

impl Collection for ObjectLiteral = {
  fn at(key) = this[key]
  fn sample() = this::values()[0]
  fn keys() = Object.keys(this)::as_set()
  fn each(f) = this::entries().forEach(fn ([k, v]) = f(k, v))
  fn find(f) = this::entries().find(fn ([k, v]) = f(k, v)::pipe(truthy))
  fn map(f) = this::entries().map(fn ([k, v]) = f(k, v))::from_entries()
  fn flat_map(f) = this::entries().map(fn ([k, v]) = f(k, v)::entries()).flat()::from_entries()
  fn filter(f) = this::entries().filter(fn ([k, v]) = f(k, v)::pipe(truthy))::from_entries()
  fn some?(f) = this::entries().some(fn ([k, v]) = f(k, v)::pipe(truthy))
  fn every?(f) = this::entries().every(fn ([k, v]) = f(k, v)::pipe(truthy))
  fn reduce(f, start) = this::entries().reduce(f, start)
  fn insert(key, value) = {...this, [key]: value}
  fn concat(other) = {...this, ...other}
  fn update(key, update_fn) = this::insert(key, update_fn::call(this::at(key)))
  fn empty?() = this::len() == 0
  fn has?(key) = this[key]::truthy?()
  fn len() = Object.keys(this).length
  fn remove(key) {
    let obj = this::clone()
    js_object_delete(obj, key)
    return obj
  }
}

impl Collection for Array = {
  fn at(idx) = this.at(idx)
  fn keys() = Object.keys(this)::as_set()
  fn sample() = this[0]
  fn each(f) = this.forEach(f)
  fn find(f) = this.find(compose(f, truthy))
  fn map(f) = this.map(f)
  fn flat_map(f) = this::map(f).flat()
  fn filter(f) = this.filter(compose(f, truthy))
  fn some?(f) = this.some(compose(f, truthy))
  fn every?(f) = this.every(compose(f, truthy))
  fn reduce(f, start) = this.reduce(f, start)
  fn insert(value) = [...this, value]
  fn concat(other) = [...this, ...other]
  fn update(val, update_fn) = this::map(fn(v) {
    if val == v {
      return update_fn::call(val)
    } else {
      return v
    }
  })
  fn empty?() = this.length == 0
  fn has?(val) = this.includes(val) || this::some?(fn(v) = v == val)
  fn len() = this.length
  fn remove(val) = this::filter(fn(v) = v != val)
}

impl Collection for HashMap = {
  fn at(key) = this.map.get(key::hash())
  fn keys() = this.raw_entries::map(first)::as_set()
  fn sample() = this.raw_entries[0]
  fn each(f) {
    for [k, v] of this.raw_entries {
      f(k, v)
    }
  }
  fn map(f) {
    let new_hash = new HashMap([])
    for [k, v] of this.raw_entries {
      new_hash = new_hash::insert(...f(k, v))
    }
    return new_hash
  }
  fn find(f) {
    for [k, v] of this.raw_entries {
      if f(k, v) {
        return v
      }
    }
  }
  fn flat_map(f) {
    let new_hash = new HashMap([])
    for [k, v] of this {
      for [_k, _v] of f(k, v) {
        new_hash = new_hash::insert(k, f(v))
      }
    }
    return new_hash
  }
  fn filter(f) {
    let new_hash = new HashMap([])
    for [k, v] of this.raw_entries {
      if f(k, v) {
        new_hash = new_hash::insert(k, f(v))
      }
    }
    return new_hash
  }
  fn some?(f) {
    for [k, v] of this.raw_entries {
      if f(k, v) {
        return true
      }
    }
    return false
  }
  fn every?(f) {
    for [k, v] of this.raw_entries {
      if !f(k, v) {
        return false
      }
    }
    return true
  }
  fn reduce(f, start) {
    let acc = start
    for [k, v] of this.raw_entries {
      acc = f(acc, k, v)
    }
    return acc
  }
  fn insert(k, v) = new HashMap([...this.raw_entries, [k, v]])
  fn concat(other) {
    let new_hash = this::clone()
    for [k, v] of other {
      new_hash = new_hash::insert(k, v)
    }
    return new_hash
  }
  fn update(key, update_fn) = this::insert(key, update_fn::call(this::at(key)))
  fn empty?() = this.raw_entries.length == 0
  fn has?(key) = this::at(key)::truthy?()
  fn len() = this.raw_entries.length
  fn remove(key) = this::filter(fn (k, v) = k != key)
}

impl Collection for Map = {
  fn at(key) = this.get(key)
  fn keys() = this.keys()::as_set()
  fn sample() = this.values().next().value
  fn each(f) {
    for [k, v] of this {
      f(k, v)
    }
  }
  fn map(f) {
    let new_map = new Map([])
    for [k, v] of this {
      new_map.set(k, f(v))
    }
    return new_map
  }
  fn find(f) {
    for [k, v] of this {
      if f(k, v) {
        return v
      }
    }
  }
  fn flat_map(f) {
    let new_map = new Map([])
    for [k, v] of this {
      for [_k, _v] of f(k, v) {
        new_map.set(k, f(v))
      }
    }
    return new_map
  }
  fn filter(f) {
    let new_map = new Map([])
    for [k, v] of this {
      if f(k, v) {
        new_map.set(k, f(v))
      }
    }
    return new_map
  }
  fn some?(f) {
    for [k, v] of this {
      if f(k, v) {
        return true
      }
    }
    return false
  }
  fn every?(f) {
    for [k, v] of this {
      if !f(k, v) {
        return false
      }
    }
    return true
  }
  fn reduce(f, start) {
    let acc = start
    for [k, v] of this {
      acc = f(acc, k, v)
    }
    return acc
  }
  fn insert(k, v) = this::clone().set(k, v)
  fn concat(other) {
    let new_map = this::clone()
    for [k, v] of other {
      new_map.set(k, v)
    }
    return new_map
  }
  fn update(key, update_fn) = this::insert(key, update_fn::call(this::at(key)))
  fn empty?() = this.size == 0
  fn has?(key) = this::at(key)::truthy?()
  fn len() = this.size
  fn remove(key) {
    let map = this::clone()
    map.remove(key)
    return map
  }
}

impl Collection for Set = {
  fn at(val) {
    if this.has(val) {
      return val
    }
  }
  fn keys() = this
  fn sample() = this.values().next().value
  fn each(f) {
    for elem of this {
      f(elem)
    }
  }
  fn map(f) {
    let out = new Set([])
    for elem of this {
      out.add(f(elem))
    }
    return out
  }
  fn find(f) {
    for elem of this {
      if f(elem) {
        return elem
      }
    }
  }
  fn flat_map(f) {
    let out = new Set([])
    for elem of this {
      for x of f(elem) {
        out.add(x)
      }
    }
    return out
  }
  fn reduce(f, start) {
    let acc = start
    for elem of this {
      acc = f(acc, elem)
    }
    return acc
  }
  fn filter(f) {
    let out = new Set([])
    for elem of this {
      if f(elem) {
        out.add(elem)
      }
    }
    return out
  }

  fn some?(f) {
    for elem of this {
      if f(elem) {
        return true
      }
    }
    return false
  }
  fn every?(f) {
    for elem of this {
      if !f(elem) {
        return false
      }
    }
    return true
  }
  fn insert(elem) = this::clone().add(elem)
  fn concat(other) {
    let new_set = this::clone()
    for item of other {
      new_set.add(item)
    }
    return new_set
  }
  fn update(key, update_fn) {
    let new_set = this::clone()
    new_set.remove(key)
    new_set.add(update_fn::call(key))
    return new_set
  }
  fn empty?() = this.size == 0
  fn has?(val) = this.has(val)
  fn len() = this.size
  fn remove(key) {
    let set = this::clone()
    set.remove(key)
    return set
  }
}

impl Collection for String = {
  fn at(idx) = this.at(idx)
  fn keys() = Object.keys(this)::as_set()
  fn sample() = this[0]
  fn each(f) {
    for char of this {
      f(char)
    }
  }
  fn map(f) {
    let out = ""
    for char of this {
      out = out + f(char)
    }
    return out
  }
  fn flat_map(f) {
    let out = ""
    for char of this {
      out = out + f(char)
    }
    return out
  }
  fn find(f) {
    for char of this {
      if f(char) {
        return char
      }
    }
  }
  fn filter(f) {
    let out = ""  
    for char of this {
      if f(char) {
        out = out + char
      }
    }
  }
  fn some?(f) {
    for char of this {
      if f(char) {
        return true
      }
    }
    return false
  }
  fn every?(f) {
    for char of this {
      if !f(char) {
        return false
      }
    }
    return true
  }
  fn reduce(f, start) {
    let out = start
    for char of this {
      out = f(out, char)
    }
    return out
  }
  fn insert(char) {
    return this + char
  }
  fn concat(str) {
    return this + str
  }
  fn update(idx, update_fn) {
    let [before, after] = [this.slice(0, idx), this.slice(idx, -1)]
    return before + update_fn::call(this::at(idx)) + after
  }
  fn empty?() = this.length == 0
  fn has?(substr) = this.includes(substr)
  fn len() = this.length
  fn remove(substr) {
    let idx = this.indexOf(substr)
    return this.slice(0, idx) + this.slice(idx + substr::len())
  }
}

// TODO: make this more general
fn zip(other) = this::map_with_index(fn(val, i) = [val, other::at(i)])

fn at(key_or_idx) = this[Collection].at.call(this, key_or_idx)
fn keys() = this[Collection].keys.call(this)
fn sample() = this[Collection].sample.call(this)
fn each(f) = this[Collection].each.call(this, f::call)
fn map(...fns) = this[Collection].map.call(this, compose(...fns))
// TODO: implement this
fn map_with_index(...fns) = this::map(...fns)
fn flat_map(...fns) = this[Collection].flat_map.call(this, compose(...fns))
fn find(f) = this[Collection].find.call(this, f::call)
fn filter(f) = this[Collection].filter.call(this, f::call)
fn some?(...fns) = this[Collection].some?.call(this, compose(...fns))
fn every?(...fns) = this[Collection].every?.call(this, compose(...fns))
// TODO: implement this
fn every_with_index?(...fns) = this::every?(...fns)
fn reduce(f, start) {
  if start::nil?() {
    start = this::sample()::identity()
  }
  return this[Collection].reduce.call(this, f::call, start)
}
fn insert(...args) = this[Collection].insert.call(this, ...args)
fn concat(other) = this[Collection].concat.call(this, other)
// alias
fn merge(other) = this::concat(other)
fn update(key, update_fn) = this[Collection].update.call(this, key, update_fn)
fn empty?() = this[Collection].empty?.call(this)
fn not_empty?() = !this::empty?()
fn has?(key_or_value) = this[Collection].has?.call(this, key_or_value)
fn len() = this[Collection].len.call(this)
fn remove(key_or_val) = this[Collection].remove.call(this, key_or_val)

// aliases for readability

fn keep(callable) = this::filter(callable)
fn discard(callable) = this::filter(compose(callable, !_))


protocol OrderedCollection

impl OrderedCollection for Array = {
  fn first() = this[0]
  fn last() = this.at(-1)
  fn skip(n) = this.slice(n)
  fn take_last(n) = this.slice(-1 - n, -1)
  fn take(n) = this.slice(0, n)
  fn sort(f) = this::clone().sort(f)
  fn reverse() = this::clone().reverse()
}

impl OrderedCollection for String = {
  fn first() = this[0]
  fn last() = this.at(-1)
  fn skip(n) = this.slice(n)
  fn take_last(n) = this.slice(-1 - n, -1)
  fn take(n) = this.slice(0, n)
  // TODO: don't rely on Array for these
  fn sort(f) = Array.from(this).sort(f).join("")
  fn reverse() = Array.from(this).reverse().join("")
}

impl OrderedCollection for Map = {
  fn first() = this.entries().next().value
  fn last() = Array.from(this).at(-1)
  fn skip(n) = new Map(Array.from(this).slice(n))
  fn take_last() = new Map(Array.from(this).slice(-1 - n, -1))
  fn take() = new Map(Array.from(this).slice(0, n))
  fn sort() = new Map(Array.from(this).sort(fn ([_k1, v1], [_k2, v2]) = v2 - v1))
  fn reverse() = new Map(Array.from(this).reverse())
}

@impl_callable
fn first() = this[OrderedCollection].first.call(this)
@impl_callable
fn last() = this[OrderedCollection].last.call(this)
@impl_callable
fn skip(n) = this[OrderedCollection].skip.call(this, n)
@impl_callable
fn take_last(n) = this[OrderedCollection].take_last.call(this, n)
@impl_callable
fn take(n) = this[OrderedCollection].take.call(this, n)
@impl_callable
fn sort() = this[OrderedCollection].sort.call(this)
@impl_callable
fn reverse() = this[OrderedCollection].reverse.call(this)

// OPERATORS

protocol Plus
protocol Negate
protocol Minus
protocol Times
protocol Divide
protocol Exponent
protocol Mod
protocol Comparable
protocol LessThan
protocol And
protocol Or

impl Negate for Object = fn() = js_negate(this)

impl And for Object = fn(thunk) = js_and(this, thunk)

impl Or for Object = fn(thunk) = js_or(this, thunk)

impl Plus for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_plus(this, other)
}

impl Minus for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_minus(this, other)
}

impl Times for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_times(this, other)
}

impl Divide for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_divide(this, other)
}

impl Exponent for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_exponent(this, other)
}

impl Mod for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_mod(this, other)
}

impl Plus for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_plus(this, other)
}

impl Minus for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_minus(this, other)
}

impl Times for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_times(this, other)
}

impl Divide for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_divide(this, other)
}

impl Exponent for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_exponent(this, other)
}

impl Mod for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_mod(this, other)
}

let ComparableMixin = {
  fn greater_than_eq(other) = this::greater_than(other) || (this == other)
  fn less_than_eq(other) = this::less_than(other) || (this == other)
}

impl Comparable for Number = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "number"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "number"
    return js_less_than(this, other)
  }
}

impl Comparable for BigInt = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "bigint"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "bigint"
    return js_less_than(this, other)
  }
}

impl Plus for String = fn(other) {
  assert! typeof(other) === "string"
  return js_plus(this, other)
}

impl Times for String = fn(amount) {
  assert! typeof(amount) === "number"
  return this.repeat(amount)
}

impl Comparable for String = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "string"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "string"
    return js_less_than(this, other)
  }
}

@impl_callable
fn plus(other) = ~Map{
  Plus => ::fn() = this[Plus](other),
  Collection => ::fn() = this::concat(other)
}
  ::find(::fn(proto, f) = this[proto])
  ::call()

@impl_callable
fn negate() {
  if this::nil?() {
    return true
  } else {
    return this[Negate]()
  }
}
@impl_callable
fn minus(other) = this[Minus](other)
@impl_callable
fn times(other) = this[Times](other)
@impl_callable
fn divide_by(other) = this[Divide](other)
@impl_callable
fn exponent(other) = this[Exponent](other)
@impl_callable
fn mod(other) = this[Mod](other)
@impl_callable
fn greater_than(other) = this[Comparable].greater_than.call(this, other)
@impl_callable
fn greater_than_eq(other) = this[Comparable].greater_than_eq.call(this, other)
@impl_callable
fn less_than(other) = this[Comparable].less_than.call(this, other)
@impl_callable
fn less_than_eq(other) = this[Comparable].less_than_eq.call(this, other)
@impl_callable
fn and(thunk) {
  if this::nil?() {
    return this
  } else {
    return this[And](thunk)
  }
}
@impl_callable
fn or(thunk) {
  if this::nil?() {
    return thunk()
  } else {
    return this[Or](thunk)
  }
}

// Printable

protocol Printable

fn _resolve_keyword_str(kw) = kw.replaceAll("__q", "?").replaceAll("__b", "!")

impl Printable for ObjectLiteral = fn() =
  Object.assign(
    new Object(),
    this::map(fn (k, v) = [_resolve_keyword_str(k), v::printable()])
  )

impl Printable for HashMap = fn() =
  this::map(fn (k, v) = [k::printable(), v::printable()])
    .raw_entries::pipe(#(new Map(&)))

impl Printable for Array = fn() =
  this::map(printable)

impl Printable for Set = fn() = "#{" + Array.from(this::map(printable)).join(", ") + "}"

fn print_for_generic_clone_object() {
  let out = this::clone()
  for [key, value] of this::entries() {
    let new_key = _resolve_keyword_str(key)
    out[new_key] = value
    if new_key != key {
      js_object_delete(out, key)
    }
  }
  return out
}

impl Printable for Keyword = fn() =
  ":" + _resolve_keyword_str(this.value)

impl Printable for Boolean = fn() = this

impl Printable for String = fn() = this

impl Printable for Function = fn() = this.name

fn when(cond, f) {
  if cond(this) {
    return f(this)
  } else {
    return this
  }
}

fn otherwise(val) = this || val

@impl_callable
fn printable() {
  if this::nil?() {
    return this
  } else {  
    return ~Map{
      Printable => ::fn() = this[Printable]()
      Clone => ::print_for_generic_clone_object
    }
      ::find(::fn(proto) = this[proto])
      ::call()
      ::otherwise(this)
  }
}

fn log(...args) {  
  console.log(...args, this::printable())
  return this
}

// Helpers

fn str(...args) = args.join("")

@impl_callable
fn int?() = Number.isInteger(this)

@impl_callable
fn bigint?() = typeof(this) === "bigint"

@impl_callable
fn float?() = typeof(this) === "number" && !int?(this)

@impl_callable
fn even?() = (this % 2) === 0

@impl_callable
fn pos?() = this >= this::identity()

@impl_callable
fn nan?() = Number.isNaN(this)

@impl_callable
fn to_f() = Number(this)

@impl_callable
fn to_i() = this::to_f()::pipe(Math.floor)

@impl_callable
fn to_s() = this.toString()

@impl_callable
fn str?() = typeof(this) == "string"

@impl_callable
fn to_b() = truthy(this)

@impl_callable
fn exists?() = (this || (this == false))::to_b()

@impl_callable
fn finite?() = this::bigint?() || Number.isFinite(this)

@impl_callable
fn inf?() = !this::finite?()

@impl_callable
fn to_lowercase() = this.toLowerCase()

@impl_callable
fn as_set() = new Set(this)

@impl_callable
fn as_keyword() = Keyword["for"](this.toString())

@impl_callable
fn error?() = this is Error

@impl_callable
fn is_a?(klass) = this is Klass

// Schema / Schema relatedÂ stuff
impl Negate for Set = fn() = #(!this.has(&))

fn pre(...args) {
  let cond_fns = args.slice(0, -1)
  let f = args.at(-1)
  return fn(...args) {
    assert! cond_fns::every?(fn(f) = f::call(...args))
    return f(...args)
  }
}

fn Args(schemas) {
  this.schemas = schemas
}

define Vector for Args = fn(schemas) = new Args(schemas)

impl Call for Args = fn(...args) =
  this.schemas::every?(fn(schema, i) = schema::call(args[i]))

impl Negate for Args = fn() = ::fn(...args) = !this::call(...args)

fn Schema(entries) {
  this.entries = new Map(entries)
}

define Record for Schema = fn(entries) = new Schema(entries)

impl Call for Schema = fn(record) = 
  record::record?() &&
  this.entries::every?(fn(k, schema) = schema::call(record::at(k)))

impl Negate for Schema = fn() = ::fn(record) = !this::call(record)

impl And for Schema = fn(thunk) = new Schema([
  ...this.entries.entries(),
  ...thunk().entries.entries()
])


impl Or for Schema = fn(thunk) =
  ::fn(record) = (this::call(record) || thunk()::call(record))::to_b()

fn Underscore(transforms) {
  this.transforms = transforms
}

fn id() = this

protocol UnderscoreInterpreter

let _ = new Underscore([{f: id, args: []}])

impl Symbol.iterator for Underscore = fn*() {
  for transform of this.transforms {
    yield transform
  }
}

impl :insert for Underscore = fn(f, ...args) =
  new Underscore([...this.transforms, {f, args}])

define Hash for _ = fn() = 2n

impl UnderscoreInterpreter for Object = fn(underscore) {
  let initial_value = this  
  let result = initial_value
  for {f args} of underscore {
    result = f.bind(result)::call(...args)
    // this may not always be true, but this handles And, and Or
    if result is Underscore {
      // we could do something like f[UnderscoreInterpreter]::call(result, initial_value)
      // but I'm not 100% sure
      result = result::call(initial_value)
    }
  }
  return result
}

impl Call for Underscore = fn(data, ...args) = data[UnderscoreInterpreter](this, ...args)

impl Comparable for Underscore = {
  fn less_than(val) = this.insert(less_than, val)
  fn greater_than(val) = this.insert(greater_than, val)
  fn less_than_eq(val) = this.insert(less_than_eq, val)
  fn greater_than_eq(val) = this.insert(greater_than_eq, val)
}

impl Negate for Underscore = fn() =
  ::fn(val) = !this::call(val)

impl Equal for Underscore = fn(other) = this.insert(eq?, other)

impl Collection for Underscore = {
  fn at(idx) = this.insert(at, idx)
  fn sample() = this.insert(sample)
  fn each(f) = this.insert(each, f)
  fn find(f) = this.insert(find, f)
  fn map(f) = this.insert(map, f)
  fn flat_map(f) = this.insert(flat_map, f)
  fn filter(f) = this.insert(filter, f)
  fn some?(f) = this.insert(some?, f)
  fn every?(f) = this.insert(every? f)
  fn reduce(f, start) = this.insert(reduce, f, start)
  fn insert(...args) = this.insert(insert, ...args)
  fn concat(other) = this.insert(concat, other)
  fn update(key, update_fn) = this.insert(update, key, update_fn)
  fn empty?() = this.insert(empty?)
  fn has?(k) = this.insert(has? k)
  fn len() = this.insert(len)
  fn remove(key_or_val) = this.insert(remove, key_or_val)
}

impl Pipe for Underscore = fn(f) = this.insert(pipe, f)

impl And for Underscore = fn(thunk) = this.insert(and, thunk)

impl Or for Underscore = fn(other) = this.insert(or, other)

impl Plus for Underscore = fn(other) = this.insert(plus, other)
impl Minus for Underscore = fn(other) = this.insert(minus, other)
impl Times for Underscore = fn(other) = this.insert(times, other)
impl Divide for Underscore = fn(other) = this.insert(divide, other)
impl Exponent for Underscore = fn(other) = this.insert(exponent, other)
impl Mod for Underscore = fn(other) = this.insert(mod, other)

// this is kind of shakey but its good enough
impl Printable for Underscore = fn() {
  let fn_to_op = ~Map{
    "greater_than" => ">"
    "greater_than_eq" => ">="
    "less_than" => "<"
    "less_than_eq" => "<="
    "times" => "*"
    "exponent" => "**"
    "divide_by" => "/"
    "plus" => "+"
    "minus" => "-"
    "mod" => "%"
    "eq__q" => "=="
  }  
  return str("_" this.transforms::skip(1)::map(fn({f, args}) {
    if f == and {
      let [thunk] = args
      return str(" && " thunk()::printable())
    }
    if f == or {
      let [thunk] = args
      return str(" || " thunk()::printable())
    }
    let s = f::printable()
    if let op = fn_to_op::call(s) {
      let [rhs] = args
      return str(" " op " " rhs::printable())
    } else {
      return str("::" s "(" args::map(printable).join(", ") ")")
    }
  }).join(""))
}

// Range

fn Range(start, end, exclusive?, transform) {
  // assert! Number.isInteger(start)
  // assert! Number.isInteger(end)
  this.start = start
  this.end = end
  this.exclusive? = truthy(exclusive?)
  this.transform = js_or(transform, fn() = _)
}

impl Printable for Range = fn() {
  if this.exclusive? {
    return str(this.start::printable() "..." this.end::printable())
  } else {
    return str(this.start::printable() ".." this.end::printable())
  }
}

impl UnderscoreInterpreter for Range = fn(underscore, val) {
  let result = val
  for {f args} of underscore {
    result = ~Map{
      map => fn(map_fn) = map_fn(result)
      filter => fn(filter_fn) {
        if filter_fn(result) {
          return result
        } else {
          return :filtered
        }
      }
    }::at(f)::call(...args)::otherwise(result)
  }
  return result
}

impl Symbol.iterator for Range = fn*() {
  let i = this.start
  let end = this.end
  if this.exclusive? { end = end::dec() }
  while i <= end {
    let result = this.transform::call(this, i)
    if result != :filtered {
      yield result
    }
    i = i::inc()
  }
}

impl :update for Range = fn(new_transform) = new Range(
  this.start,
  this.end,
  this.exclusive?,
  new_transform
)

impl Collection for Range = {
  fn sample() = this.start
  fn each(f) {
    for elem of this {
      f(elem)
    }
  }
  fn reduce(f, start) {
    let result = start
    for elem of this {
      result = f(result, elem)
    }
    return result
  }
  fn map(f) = this.update(this.transform::map(f))
  fn filter(f) = this.update(this.transform::filter(f))
  fn has?(value) = this::call(value)
}

impl Call for Range = fn(value) {
  value = this.transform::call(this, value)
  if value == :filtered { return false }
  if this.exclusive? {  
    return value >= this.start && value < this.end
  } else {
    return value >= this.start && value <= this.end
  }
}

impl Clone for Range = {
  fn clone() = new Range(this.start, this.end, this.exclusive?, this.transform)
  fn deep_clone() = new Range(this.start::deep_clone(), this.end::deep_clone(), this.exclusive?, this.transform::deep_clone())
}

// Schemas

fn All(conds) { this.conds = conds }

define Vector for All = fn(conds) = new All(conds)

impl Call for All = fn(val) = this.conds::every?(fn(f) = f::call(val))

fn Any(conds) { this.conds = conds }

define Vector for Any = fn(conds) = new Any(conds)

impl Call for Any = fn(val) = this.conds::some?(fn(f) = f::call(val))

// Effect system

protocol Effect

fn run_effect() {
  if this[Effect] {
    return this[Effect]()
  } else {
    console.log("No effect found for", this)  
    raise(this)
  }
}

async fn spawn(generator_fn, ...gen_args) {
  let generator = generator_fn(...gen_args)
  let state = {done: false}
  let yield_result = null
  let effects = []
  while !state.done {
    state = await generator.next(yield_result)
    if state.done { break }
    let effect = state.value
    try {
      yield_result = await effect::run_effect()
    } catch error {
      state = await generator.throw(error)
      yield_result = await state.value::run_effect()
      effects.push(state.value)
    }
    effects.push(effect)
  }
  return {effects, value: state.value}
}

async fn run(generator_fn) = (await spawn(generator_fn))::at(:value)

fn Channel() {}

impl :send for Channel = fn (msg) {
  this.resolve(msg)
}

impl :subscribe for Channel = fn(f) {
  this.resolve = f
}

impl Symbol.asyncIterator for Channel = async fn*() {
  loop {
    yield new Promise(::fn (resolve) = this.resolve = resolve)
  }
}

fn fork(generator_fn) {
  let pid = new Channel()
  spawn(generator_fn, pid)
  return pid
}

// builtin effects

fn CallEffectWith(effect, ...args) {
  this.effect = effect
  this.args = args
}

fn with(...args) = new CallEffectWith(this, ...args)

impl Effect for CallEffectWith = fn() =
  this.effect[Effect](...this.args)

fn intern_vec(klass) {
  if !klass.cache {
    klass.cache = ~Map{}
    define Vector for klass = fn(args) {
      let hash_value = args::hash()
      if let obj = klass.cache.get(hash_value) {
        return obj
      } else {
        let obj = new klass(...args)
        klass.cache.set(hash_value, obj)
        return obj
      }
    }
  }
  return klass
}

// HTTP

@intern_vec
fn Fetch(method, url, status) {
  this.method = method  
  this.url = url
  this.status = status
}

@intern_vec
fn Msg(...descriptors) {
  this.descriptors = descriptors
}

impl Equal for Msg = fn(obj) =
  obj is Msg && this.descriptors == obj.descriptors

// Idea to allow you do write the following
// define Effect for ~Msg[:save _] = ...
// and it would get called even if ~Msg[:save 12] was triggered.
// In other words, allowing _ to be used as a placeholder.
// This is a step towards getting to closer to feel like 
// pattern matching.

// Implementing this as the root handler for Msg is pretty safe
// performance-wise I imagine since, I won't be reached 
// in the prototype chain unless an effect hasn't been implemented
// for the effect that was triggered.

// So the concrete effect handlers will be fast
// and the placeholders will have O(n) where n is
// the amount of descriptors which again should be very few.

// impl Effect for Msg = fn(...with_args) {
//   for i of 0..this.descriptors.length {
//     let before = this.descriptors.slice(0, i)
//     let after = this.descriptors.slice(i + 1)
//     let eff_vec = Msg::construct_vector([...before, _, ...after])
//     if Effect keyof eff_vec {
//       return eff_vec[Effect](...with_args)
//     }
//   }
//   console.log("No effect found")
//   raise(this)
// }


fn HttpError(code, message) {
  this.name = "HttpError"
  this.message = message
  this.stack = (new Error()).stack
  this.code = code::as_keyword()
}
HttpError.prototype = new Error()

fn JSONRequest(url) {
  this.url = url
}

impl Effect for JSONRequest = fn() = fetch(this.url).then(async fn(res) {
  if !res.ok {
    let text = await res.text()
    return Promise.reject(new HttpError(res.status, text))
  }
  return res.json()
})

fn json_req(url) = new JSONRequest(url)

let http = {
  async fn* get(url) {
    if Effect keyof ~Fetch[:get url :init] {
      yield ~Fetch[:get url :init]
    }
    if Effect keyof ~Fetch[:get url :loading] {
      yield ~Fetch[:get url :loading]
    }
    try {
      return yield json_req(url)
    } catch error {
      if Effect keyof ~Fetch[:get url error.code] {
        yield ~Fetch[:get url error.code]::with(error)
      } else {
        yield ~Fetch[:get url :error]::with(error)
      }
      return error
    }
  }
}

fn Comp() {}

define Vector for Comp = fn([map_fn, _for, collection, ...rest]) {
  assert! _for == :for
  assert! Call keyof map_fn
  let result = collection

  if rest::first() == :where {
    let [_if filter_fn, ..._rest] = rest
    rest = _rest
    assert! Call keyof filter_fn
    result = result::filter(filter_fn)
  }

  result = result::map(map_fn)

  if rest::first() == :verify {
    let [_verify, verify_fn, ..._rest] = rest
    assert! result::every?(verify_fn)
  }

  return result
}

// CollectionView is an efficent data structure to use
// the same old Collection protocol methods, without
// copying the entire array each time you ::skip(1)
// which happens a lot during parsing.
fn CollectionView(collection, idx) { this.collection = collection, this.idx = idx }

// Its only partially implemented right now because most use-cases
// don't require the complete collections api.
impl OrderedCollection for CollectionView = {
  fn first() = this.collection::at(this.idx)
  fn last() = this.collection::last()
  fn skip(n) = new CollectionView(this.collection, this.idx + n)
}

impl Collection for CollectionView = {
  fn at(idx) = this.collection::at(this.idx + idx)
  fn len() = this.collection::len() - this.idx
  fn empty?() = this::len() == 0
}

impl Printable for CollectionView = fn() = this.collection::skip(this.idx)

fn DefVector() {}

define Vector for DefVector = fn(properties) {  
  let Constructor = null
  // TODO: this returns _ itself when its true
  // that's weird, but it still works.
  if properties::first() == _ {
    let kw = properties::at(1)
    Constructor = fn(...args) {
      this[kw] = args
    }
  } else {
    Constructor = fn(...args) {
      for [key, arg] of properties::zip(args) {
        this[key] = arg
      }
    }
  }
  define Vector for Constructor = fn(args) = new Constructor(...args)
  return Constructor
}

fn DefRecord() {}

define Vector for DefRecord = fn(property_name) {
  let Constructor = fn (entries) { this[property_name] = entries }
  define Record for Constructor = fn(entries) = new Constructor(entries)
  return Constructor
}

protocol Validation

fn StructValidationError(message) {
  this.name = "StructValidationError"
  this.message = message
  this.stack = (new Error()).stack
}

StructValidationError.prototype = new Error()

fn validate_struct(struct_name) {
  if !(Validation keyof this) { return true }

  for [key, validator] of this[Validation]::entries() {
    if validator::call(this[key]) {
      continue
    } else {
      raise(
        new StructValidationError(
          str(
            struct_name " validation failed.\n"
            "Failed at " key::printable() ".\n"
            "Expected " validator::printable()
            ", got value " this[key]::printable() "."
          )
        )
      )
    }
  }
}

fn Struct(name, ...properties) {
  fn Constructor(...args) {
    for [key, arg] of properties::zip(args) {
      this[key] = arg
    }
    this::validate_struct(name)
  }
  Object.defineProperty(Constructor, "name", { value: name })
  return Constructor
}
define Vector for Struct = fn(args) = Struct(...args)


// Reactive primitives

let Atom = ~Struct["Atom" :value]

impl Atom = {
  fn set(new_value) {
    this.value = new_value
  }
}

protocol Dereference

impl Dereference for Atom = fn() = this.value

fn Deref() {}

let $ = new Deref()

define :bind for $ = fn(other) = other[Dereference]()

protocol Matches

fn matches?(value) = this[Matches](value)

impl Matches for Object = fn(value) {
  if Call keyof this {
    return this::call(value)
  } else {
    return this == value
  }
}

impl Matches for Array = fn(value) =
  value::len() == this::len() &&
  ::every_with_index?(fn(pattern, i) = pattern::matches?(value::at(i)))

impl Matches for Underscore = fn(value) {
  if value::nil?() {
    return false
  } else {
    return this::call(value)
  }
}

impl Matches for ObjectLiteral = fn(record) =
  ::every?(fn(key, pattern) = pattern::matches?(record::at(key::as_keyword())))

// for listening to window events

let EventStream = ~Struct["EventStream" :event_type :filter]

impl EventStream = {
  fn start() {
    this.watch = ::fn(e) {
      if this.filter::call(e) {
        this.resolve::call(e)
      }
    }
    window.addEventListener(this.event_type, this.watch)
  }
  fn end() = window.removeEventListener(this.event_type, this.watch)
  fn subscribe(f) {
    if !this.watch { this.start() }
    this.resolve = f
  }
}

impl Symbol.asyncIterator for EventStream = async fn*() {
  loop {
    yield await new Promise(::fn(resolve) = this.subscribe(resolve))
  }
}

// so you can iterate over animation frames
let AnimationFrames = {}

define Symbol.asyncIterator for AnimationFrames = async fn*() {
  loop {
    yield await new Promise(fn (resolve) = requestAnimationFrame(resolve))
  }
}

// so you can listen to multiple event sources at once
fn Race() {}

define Vector for Race = async fn*(items) {
  loop {
    let promises = items::map(fn(stream) = new Promise(fn (resolve) = stream.subscribe(resolve)))
    yield await Promise.race(promises)
  }
}

// sane defaults
define Effect for ~Msg[:keydown] = fn(filter) =
  new EventStream("keydown", _::at(:key)::pipe(filter))

define Effect for ~Msg[:mousedown] = fn() = new EventStream("mousedown", _)
define Effect for ~Msg[:mousemove] = fn() = new EventStream("mousemove", _)
