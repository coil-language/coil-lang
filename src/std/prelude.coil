// CALL PROTOCOL

protocol Call

impl Call for Symbol = fn(obj, ...args) = obj[this](...args)
impl Call for Function = fn(...args) = this(...args)
impl Call for Set = fn(key) = this.has(key)
impl Call for Map = fn(key) = this.get(key)
impl Call for ObjectLiteral = fn(key) = this[key]
impl Call for Array = fn(index) = this.at(index)
impl Call for String = fn(collection) {
  if typeof(collection) === "string" || collection is Keyword {
    raise!(new TypeError("Can't 'call' a string with " + collection::as_str()))
  } else {
    return collection::call(this)
  }
}
impl Call for Number = fn(collection) {
  if collection is Keyword {
    return this[collection]
  } else {
    return collection::call(this)
  }
}
impl Call for Keyword = fn(collection) {
  if collection is Keyword || typeof(collection) === "string" {
    raise!(new TypeError("Can't 'call' a keyword with" + collection::as_str()))
  } else if Call keyof collection {
    return collection::call(this)
  } else {
    return collection[this]
  }
}

fn call(...args) = this&.[Call](...args)

// make sets and map callable using bind syntax
impl :bind for Set = fn(val) = ::fn() = this::call(val)
impl :bind for Map = fn(val) = ::fn() = this::call(val)

let nil? = Object.freeze(#{undefined null})

protocol Pipe

impl Pipe for Object = fn(callable) = callable::call(this)

fn pipe_one(callable) {
  if this::nil?() {
    return callable::call(this)
  } else {
    return this[Pipe](callable)
  }
}

fn pipe(...callables) =
  callables::iter()::reduce(fn(r, c) = r::pipe_one(c), this)

fn compose(first_fn, ...fns) = fn(...args) =
  fns::iter()::reduce(fn (result, f) = f::call(result), first_fn::call(...args))

fn impl_callable(f) {
  define Call for f = fn(first, ...rest) = first::f(...rest)
  return f
}

// Iterable & OrderedIterable Protocols

@impl_callable
fn iter() = this[Symbol.iterator]()

let ArrayIterator = Object.getPrototypeOf([]::iter())
let MapIterator = Object.getPrototypeOf(new Map()::iter())
let StringIterator = Object.getPrototypeOf(""::iter())
let SetIterator = Object.getPrototypeOf(#{}::iter())
let GeneratorFunction = Object.getPrototypeOf(fn*(){})

protocol Iterable

let iterable_collection_impl = {
  fn* take(n) {
    for [elem i] of this::zip(0..) {
      if i == n { break }
      yield elem
    }
  }
  fn* drop(n) {
    let size = this::len()
    for [elem i] of this::zip(0..) {
      if (size - i) > n { break }
      yield elem
    }
  }
  fn* until(f) {
    for elem of this {
      if f(elem) { break }
      yield elem
    }
  }
  fn* skip(n) {
    for [elem i] of this::zip(0..) {
      if i < n { continue }
      yield elem
    }
  }
  fn find(f) {
    for elem of this {
      if f(elem) {
        return elem
      }
    }
  }
  fn* zip(...collections) {
    let generators = [this, ...collections]::iter()::map(iter)::as_array()
    loop {
      let gen_states = generators::iter()::map(#(&.next()))::as_array()
      
      if gen_states::iter()::any?(:done) { break }
      yield gen_states::iter()::map(:value)::as_array()
    }
  }
  fn reduce(f, start) {
    let acc = start
    for elem of this {
      acc = f(acc, elem)
    }
    return acc
  }
  fn* map(f) {
    for elem of this {
      yield f(elem)
    }
  }
  fn* flat_map(f) {
    for elem of this {
      yield* f(elem)
    }
  }
  fn each(f) {
    for elem of this {
      f(elem)
    }
  }
  fn* keep(f) {
    for elem of this {
      if f(elem) {
        yield elem
      }
    }
  }
  fn all?(f) {  
    for elem of this {
      if !f(elem) {
        return false
      }
    }
    return true
  }
  fn any?(f) {
    for elem of this {
      if f(elem) {
        return true
      }
    }
    return false
  }
}

define Iterable for ArrayIterator = iterable_collection_impl
define Iterable for StringIterator = iterable_collection_impl
define Iterable for MapIterator = iterable_collection_impl
define Iterable for SetIterator = iterable_collection_impl
impl Iterable for GeneratorFunction = iterable_collection_impl

fn skip(n) = this[Iterable].skip.call(this, n)
fn take(n) = this[Iterable].take.call(this, n)
fn drop(n) = this[Iterable].drop.call(this, n)
fn each(f) = this[Iterable].each.call(this, f::call)
fn until(f) = this[Iterable].until.call(this, f::call)
fn zip(...iterables) = this[Iterable].zip.call(this, ...iterables)
fn map(...fns) = this[Iterable].map.call(this, compose(...fns))
fn flat_map(...fns) = this[Iterable].flat_map.call(this, compose(...fns))
fn find(f) = this[Iterable].find.call(this, f::call)
fn keep(f) = this[Iterable].keep.call(this, f::call)
fn reject(f) = this::keep(compose(f, !_))
fn any?(...fns) = this[Iterable].any?.call(this, compose(...fns))
fn all?(...fns) = this[Iterable].all?.call(this, compose(...fns))
fn reduce(f, start) {
  if start::nil?() && f[Identity] {
    start = f[Identity]
  }
  return this[Iterable].reduce.call(this, f::call, start)
}

protocol ReversedIterator

fn* _reversed_impl() {
  for i of 1..this::len() {
    yield this.at(i * -1)
  }
}

impl ReversedIterator for Array = _reversed_impl
impl ReversedIterator for String = _reversed_impl

@impl_callable
fn reversed() = this[ReversedIterator]()

// RECORD AND VECTOR PROTOCOLS

protocol Record

// using generator here to avoid allocating 2 intermediate entries arrays
fn* record_merge_(other) {
  yield *this
  yield *other
}

impl Record for ObjectLiteral = {
  fn at(key) = this[key]
  fn insert(key, value) = {...this, [key]: value}
  fn merge(other) = ObjectLiteral.from_entries(this::record_merge_(other))
  fn keys() = Object.keys(this)
  fn has?(key) = key keyof this
  fn len() = this::keys().length
  fn empty?() = this::len() == 0
}

impl Record for Map = {
  fn at(key) = this.get(key)
  fn insert(key, value) {
    let map = new Map(this)
    return map.set(key, value)
  }
  fn merge(other) {
    if other is ObjectLiteral {
      other = other::iter()::map(fn([k, v]) {
        if k::as_num()::nan?() {
          return [k::as_keyword(), v]
        } else {
          return [k, v]
        }
      })
    }
    return new Map(this::record_merge_(other))
  }
  fn keys() = this.keys()
  fn has?(key) = this.has(key)
  fn len() = this.size
  fn empty?() = this.size === 0
  fn first() = this.entries().next().value
}

fn insert(key, value) = this[Record].insert.call(this, key, value)
fn merge(other) = this[Record].merge.call(this, other)
fn keys() = this[Record].keys.call(this)

define Record for Map = fn(entries) = new Map(entries)

fn record?() = this[Record]::exists?()
fn construct_record(entries) = this[Record](entries)

protocol Vector

fn vector?() = this[Vector]::exists?()

impl Vector for Array = {
  fn at(idx) = this.at(idx)
  fn push(value) = [...this, value]
  fn concat(other) = [...this, ...other]
  fn has?(value) = this::any?(_ == value)
  fn replace(old_value, new_value) =
    this::iter()::map(fn(val) {
      if val == old_value { return new_value }
      else { return val }
    })::as_array()
  fn len() = this.length
  fn empty?() = this.length === 0
  fn first() = this[0]
  fn last() = this.at(-1)
}

impl Vector for Set = {
  fn push(value) = new Set(this).add(value)
  fn concat(other) = new Set(this::fn*() {
    yield* this
    yield* other
  }())
  fn has?(value) = this.has(value)
  fn replace(old_value, new_value) {
    let self = new Set(this)  
    self.delete(old_value)
    return self.add(new_value)
  }
  fn len() = this.size
  fn empty?() = this.size === 0
  fn first() = this.values().next().value
}

impl Vector for String = {
  fn push(value) = this + value
  fn concat(other) = this + other
  fn has?(value) = this.includes(value)
  fn replace(old_value, new_value) = this.replace(old_value, new_value)
  fn len() = this.length
  fn empty?() = this.length === 0
  fn first() = this[0]
  fn last() = this.at(-1)
}

fn at(idx_or_key) = (this[Vector] || this[Record]).at.call(this, idx_or_key)
fn push(value) = this[Vector].push.call(this, value)
fn concat(other) = this[Vector].concat.call(this, other)
fn has?(value) = (this[Vector] || this[Record]).has?.call(this, value)
fn replace(old_value, new_value) =
  this[Vector].replace.call(this, old_value, new_value)
@impl_callable
fn len() = (this[Vector] || this[Record]).len.call(this)
@impl_callable
fn first() = (this[Vector] || this[Record]).first.call(this)
@impl_callable
fn last() = (this[Vector] || this[Record]).last.call(this)
fn empty?() {
  if this::nil?() {
    return true
  } else {
    return (this[Vector] || this[Record]).empty?.call(this)
  }
}
fn not_empty?() = !this::empty?()

define Vector for Array = fn(entries) = entries

fn construct_vector(entries) = this[Vector](entries)

// EQUAL PROTOCOl

protocol Equal

fn strict_eq?(other) = this === other

impl Equal for Object = strict_eq?

fn vector_eq?(other) {
  if this.constructor !== other.constructor { return false }
  if this::len() != other::len() { return false }
  return this::iter()::zip(other)::all?(fn([a, b]) = a == b)
}

fn record_eq?(other) {
  if this.constructor !== other.constructor { return false }
  if this::len() != other::len() { return false }
  return this::iter()::all?(fn([key, value]) = other::at(key) == value)
}

impl Equal for Set = vector_eq?
impl Equal for Array = vector_eq?
impl Equal for Map = record_eq?
impl Equal for ObjectLiteral = record_eq?

@impl_callable
fn eq?(other) {
  if this::nil?() {
    return this === other
  } else {
    return this[Equal](other)
  }
}

// IDENTITY PROTOCOL
protocol Identity

impl Identity for Number = 0
impl Identity for BigInt = 0n
impl Identity for String = ""

fn identity() {
  if this::nil?() {
    return this
  } else {
    return this[Identity]
  }
}

// OPERATORS

protocol Plus
protocol Negate
protocol Minus
protocol Times
protocol Divide
protocol Exponent
protocol Mod
protocol Comparable
protocol LessThan
protocol And
protocol Or

impl Negate for Object = fn() = js_negate(this)
impl And for Object = fn(thunk) = js_and(this, thunk)
impl Or for Object = fn(thunk) = js_or(this, thunk)
impl Plus for Set = fn(other_set) = this::concat(other_set)
impl Plus for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_plus(this, other)
}
impl Minus for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_minus(this, other)
}
impl Times for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_times(this, other)
}
impl Divide for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_divide(this, other)
}
impl Exponent for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_exponent(this, other)
}
impl Mod for Number = fn(other) {
  assert! typeof(other) === "number"
  return js_mod(this, other)
}
impl Plus for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_plus(this, other)
}
impl Minus for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_minus(this, other)
}
impl Times for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_times(this, other)
}
impl Divide for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_divide(this, other)
}
impl Exponent for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_exponent(this, other)
}
impl Mod for BigInt = fn(other) {
  assert! typeof(other) === "bigint"
  return js_mod(this, other)
}
let ComparableMixin = {
  fn greater_than_eq(other) = this::greater_than(other) || (this == other)
  fn less_than_eq(other) = this::less_than(other) || (this == other)
}
impl Comparable for Number = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "number"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "number"
    return js_less_than(this, other)
  }
}
impl Comparable for BigInt = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "bigint"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "bigint"
    return js_less_than(this, other)
  }
}
impl Plus for String = fn(other) {
  assert! typeof(other) === "string"
  return js_plus(this, other)
}
impl Times for String = fn(amount) {
  assert! typeof(amount) === "number"
  return this.repeat(amount)
}
impl Comparable for String = {
  ...ComparableMixin,
  fn greater_than(other) {
    assert! typeof(other) === "string"
    return js_greater_than(this, other)
  }
  fn less_than(other) {
    assert! typeof(other) === "string"
    return js_less_than(this, other)
  }
}

@impl_callable
fn plus(other) {
  if this[Plus] {
    return this[Plus](other)
  } else {
    return (this::concat || this::merge)(other) 
  }
}

@impl_callable
fn negate() {
  if this::nil?() {
    return true
  } else {
    return this[Negate]()
  }
}
fn minus(other) = this[Minus](other)
fn times(other) = this[Times](other)
fn divide_by(other) = this[Divide](other)
fn exponent(other) = this[Exponent](other)
fn mod(other) = this[Mod](other)
fn greater_than(other) = this[Comparable].greater_than.call(this, other)
fn greater_than_eq(other) = this[Comparable].greater_than_eq.call(this, other)
fn less_than(other) = this[Comparable].less_than.call(this, other)
fn less_than_eq(other) = this[Comparable].less_than_eq.call(this, other)
fn and(thunk) {
  if this::nil?() {
    return this
  } else {
    return this[And](thunk)
  }
}
fn or(thunk) {
  if this::nil?() {
    return thunk()
  } else {
    return this[Or](thunk)
  }
}

// Printable

protocol Printable

fn _resolve_keyword_str(kw) = kw::replace("__q", "?")::replace("__b", "!")

impl Printable for ObjectLiteral = fn() {
  let output = new Object()
  for [k, v] of this {
    output[_resolve_keyword_str(k)] = v::printable()
  }
  return output
}

impl Printable for Map = fn() =
  ::iter()::map(fn ([k, v]) = [k::printable(), v::printable()])::as_map()

impl Printable for Array = fn() = ::iter()::map(printable)::as_array()
impl Printable for Set = fn() = str("#{" this::iter()::map(printable)::as_array().join(", ") "}")
impl Printable for Keyword = fn() = ":" + _resolve_keyword_str(this.value)
impl Printable for Boolean = fn() = this
impl Printable for String = fn() = this
impl Printable for Function = fn() = this.name

@impl_callable
fn printable() {
  if this::nil?() || !this[Printable] {
    return this
  } else {
    return this[Printable]()
  }
}

@impl_callable
fn log(...args) {  
  console.log(...args, this::printable())
  return this
}

// Helpers

fn str(...args) = args.join("")
@impl_callable
fn nan?() = Number.isNaN(this)
@impl_callable
fn str?() = typeof(this) == "string"
@impl_callable
fn as_set() = new Set(this)
@impl_callable
fn as_array() = Array["from"](this)
@impl_callable
fn as_obj() = ObjectLiteral.from_entries(this)
@impl_callable
fn as_map() = new Map(this)
@impl_callable
fn as_keyword() = Keyword["for"](this.toString())
@impl_callable
fn as_num() = Number(this)
@impl_callable
fn as_str() = this.toString()
@impl_callable
fn exists?() = !this::nil?()

impl Negate for Set = fn() = #(!this.has(&))

// Underscore

fn Underscore(transforms) { this.transforms = transforms }

protocol UnderscoreInterpreter

let _ = new Underscore([{f: fn id() = this, args: []}])

impl Symbol.iterator for Underscore = fn() = this.insert(iter)

impl :insert for Underscore = fn(f, ...args) =
  new Underscore(this.transforms::push({f, args}))

impl UnderscoreInterpreter for Object = fn(underscore) {
  let initial_value = this  
  let result = initial_value
  for {f args} of underscore.transforms {
    result = result::f::call(...args)
    // this may not always be true, but this handles And, and Or
    if result is Underscore {
      // we could do something like f[UnderscoreInterpreter]::call(result, initial_value)
      // but I'm not 100% sure
      result = result::call(initial_value)
    }
  }
  return result
}

impl Call for Underscore = fn(data, ...args) {
  if data::nil?() {
    return Object.prototype[UnderscoreInterpreter].call(data, this, ...args)
  } else {
    return data[UnderscoreInterpreter](this, ...args)
  }
}

impl Comparable for Underscore = {
  fn less_than(val) = this.insert(less_than, val)
  fn greater_than(val) = this.insert(greater_than, val)
  fn less_than_eq(val) = this.insert(less_than_eq, val)
  fn greater_than_eq(val) = this.insert(greater_than_eq, val)
}

impl Negate for Underscore = fn() = this.insert(negate)
impl Equal for Underscore = fn(other) = this.insert(eq?, other)

impl Iterable for Underscore = {
  fn empty?() = this.insert(empty?)
  fn first() = this.insert(first)
  fn take() = this.insert(take)
  fn skip() = this.insert(skip)
  fn find(f) = this.insert(find, f)
  fn reduce(f, start) = this.insert(reduce, f, start)
  fn map(f) = this.insert(map, f)
  fn flat_map(f) = this.insert(flat_map, f)
  fn each(f) = this.insert(each, f)
  fn keep(f) = this.insert(keep, f)
  fn all?(f) = this.insert(all? f)
  fn any?(f) = this.insert(any?, f)
}
impl ReversedIterator for Underscore = fn() = this.insert(reversed)
impl Record for Underscore = {
  fn at(key) = this.insert(at, key)
  fn insert(key, value) = this.insert(insert, key, value)
  fn merge(other) = this.insert(merge, other)
  fn has?(k) = this.insert(has?, k)
  fn len() = this.insert(len)
}
impl Vector for Underscore = {
  fn push(value) = this.insert(push, value)
  fn concat(other) = this.insert(concat, other)
  fn replace(old_value, new_value) = this.insert(has?, old_value, new_value)
}

impl Pipe for Underscore = fn(f) = this.insert(pipe, f)
impl And for Underscore = fn(thunk) = this.insert(and, thunk)
impl Or for Underscore = fn(thunk) = this.insert(or, thunk)
impl Plus for Underscore = fn(other) = this.insert(plus, other)
impl Minus for Underscore = fn(other) = this.insert(minus, other)
impl Times for Underscore = fn(other) = this.insert(times, other)
impl Divide for Underscore = fn(other) = this.insert(divide, other)
impl Exponent for Underscore = fn(other) = this.insert(exponent, other)
impl Mod for Underscore = fn(other) = this.insert(mod, other)

// this is kind of shaky but its good enough
impl Printable for Underscore = fn() {
  let fn_to_op = ~Map{
    "greater_than" => ">"
    "greater_than_eq" => ">="
    "less_than" => "<"
    "less_than_eq" => "<="
    "times" => "*"
    "exponent" => "**"
    "divide_by" => "/"
    "plus" => "+"
    "minus" => "-"
    "mod" => "%"
    "eq__q" => "=="
  }  
  return str("_" this.transforms::iter()::skip(1)::map(fn({f, args}) {
    if f == and {
      let [thunk] = args
      return str(" && " thunk()::printable())
    } else if f == or {
      let [thunk] = args
      return str(" || " thunk()::printable())
    }
    let s = f::printable()
    if let op = fn_to_op::call(s) {
      let [rhs] = args
      return str(" " op " " rhs::printable())
    } else {
      return str("::" s "(" args::map(printable).join(", ") ")")
    }
  })::reduce(+))
}

// Ranges

protocol Inc

impl Inc for Number = fn() = this + 1
impl Inc for BigInt = fn() = this + 1n
impl Inc for String = fn() = String.fromCharCode(this.charCodeAt(0) + 1)

fn inc() = this[Inc]()

fn IRange(start, end) { this.start = start; this.end = end }
fn ERange(start, end) { this.start = start; this.end = end }

impl Call for IRange = fn(value) = value >= this.start && value <= this.end
impl Call for ERange = fn(value) = value >= this.start && value < this.end

impl Printable for IRange = fn() = str(this.start ".." this.end)
impl Printable for ERange = fn() = str(this.start "..." this.end)

impl Symbol.iterator for IRange = fn*() {
  let {start: i, end} = this
  while i <= end {
    yield i
    i = i::inc()
  }
}
impl Symbol.iterator for ERange = fn*() {
  let {start: i, end} = this
  while i < end {
    yield i
    i = i::inc()
  }
}

fn def_vector(Constructor) {
  define Vector for Constructor = fn(args) = new Constructor(...args)
  return Constructor
}

fn def_record(Constructor, key) {
  key ||= :entries
  define Record for Constructor = fn(entries) = new Constructor(entries)
  impl Record for Constructor = {
    fn at(idx) = this[key][idx]
    fn keys() = this[key]::iter()::map(first)
    fn has?(key) = this::keys()::has?(key)
    fn len() = this[key].length
  }
  impl Symbol.iterator for Constructor = fn() = this[key]::iter()
  return Constructor
}

// Consider removing this or rethinking it
protocol Matches

fn matches?(value) = this[Matches](value)

impl Matches for Object = fn(value) {
  if typeof(this) != "object" && typeof(this) != "function" {
    return this == value
  } else if Call keyof this {
    return this::call(value)
  } else {
    return this == value
  }
}

impl Matches for Array = fn(arr) =
  arr::len() == this::len() &&
  this::iter()::zip(arr)::all?(fn([pattern, val]) = pattern::matches?(val))

impl Matches for Set = fn(value) = this::has?(value)

impl Matches for Underscore = fn(value) {
  if value::nil?() {
    return false
  } else {
    return this::call(value)
  }
}

impl Matches for ObjectLiteral = fn(record) =
  ::iter()::all?(fn(key, pattern) = pattern::matches?(record::at(key::as_keyword())))

@def_record
fn Match(entries) { this.entries = entries }

impl Call for Match = fn(val) =
  this.entries::iter()
    ::find(fn([pattern, _ret]) = pattern::matches?(val))
    ::pipe(1)

// string helpers
let char_alpha? = ("a".."z")::as_set() + ("A".."Z")::as_set()
let char_numeric? = ("0".."9")::as_set()
let char_alpha_numeric? = char_alpha? + char_numeric?
fn alpha?() = this::iter()::all?(char_alpha?)
fn alpha_numeric?() = this::iter()::all?(char_alpha_numeric?)

// GLOBAL EXPORTS

define :Call for globalThis = Call
define :call for globalThis = call
define :nil? for globalThis = nil?
define :Pipe for globalThis = Pipe
define :pipe for globalThis = pipe
define :compose for globalThis = compose
define :iter for globalThis = iter
define :Iterable for globalThis = Iterable
define :skip for globalThis = skip
define :take for globalThis = take
define :drop for globalThis = drop
define :each for globalThis = each
define :until for globalThis = until
define :zip for globalThis = zip
define :map for globalThis = map
define :flat_map for globalThis = flat_map
define :find for globalThis = find
define :keep for globalThis = keep
define :reject for globalThis = reject
define :any? for globalThis = any?
define :reduce for globalThis = reduce
define :ReversedIterator for globalThis = ReversedIterator
define :revered for globalThis = reversed
define :Record for globalThis = Record
define :insert for globalThis = insert
define :merge for globalThis = merge
define :keys for globalThis = keys
define :record? for globalThis = record?
define :construct_record for globalThis = construct_record
define :Vector for globalThis = Vector
define :vector? for globalThis = vector?
define :at for globalThis = at
define :push for globalThis = push
define :concat for globalThis = concat
define :has? for globalThis = has?
define :replace for globalThis = replace
define :len for globalThis = len
define :first for globalThis = first
define :last for globalThis = last
define :empty? for globalThis = empty?
define :not_empty? for globalThis = not_empty?
define :construct_vector for globalThis = construct_vector
define :Equal for globalThis = Equal
define :eq? for globalThis = eq?
define :Identity for globalThis = Identity
define :identity for globalThis = identity
define :Plus for globalThis = Plus
define :Negate for globalThis = Negate
define :Minus for globalThis = Minus
define :Times for globalThis = Times
define :Divide for globalThis = Divide
define :Exponent for globalThis = Exponent
define :Mod for globalThis = Mod
define :Comparable for globalThis = Comparable
define :LessThan for globalThis = LessThan
define :And for globalThis = And
define :Or for globalThis = Or
define :plus for globalThis = plus
define :negate for globalThis = negate
define :minus for globalThis = minus
define :times for globalThis = times
define :divide_by for globalThis = divide_by
define :exponent for globalThis = exponent
define :mod for globalThis = mod
define :greater_than for globalThis = greater_than
define :greater_than_eq for globalThis = greater_than_eq
define :less_than for globalThis = less_than
define :less_than_eq for globalThis = less_than_eq
define :and for globalThis = and
define :or for globalThis = or
define :Printable for globalThis = Printable
define :printable for globalThis = printable
define :log for globalThis = log
define :str for globalThis = str
define :nan? for globalThis = nan?
define :str? for globalThis = str?
define :as_set for globalThis = as_set
define :as_array for globalThis = as_array
define :as_obj for globalThis = as_obj
define :as_map for globalThis = as_map
define :as_keyword for globalThis = as_keyword
define :as_num for globalThis = as_num
define :as_str for globalThis = as_str
define :exists? for globalThis = exists?
define :Negate for globalThis = Negate
define :Underscore for globalThis = Underscore
define :_ for globalThis = _
define :Inc for globalThis = Inc
define :inc for globalThis = inc
define :IRange for globalThis = IRange
define :ERange for globalThis = ERange
define :Matches for globalThis = Matches
define :matches? for globalThis = matches?
define :alpha? for globalThis = alpha?
define :alpha_numeric? for globalThis = alpha_numeric?
define :def_vector for globalThis = def_vector
define :def_record for globalThis = def_record
