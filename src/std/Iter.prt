protocol Iter

fn entries() = Object.entries(this)
fn from_entries() = Object.fromEntries(this)

impl Iter for ObjectLiteral = {
  fn each(f) = this::entries().forEach(fn ([k, v]) = f(k, v))
  fn map(f) = this::entries().map(fn ([k, v]) = f(k, v))::from_entries()
  fn filter(f) = this::entries().filter(fn ([k, v]) = f(k, v))::from_entries()
  fn some?(f) = this::entries().some(fn ([k, v]) = f(k, v))::from_entries()
  fn every?(f) = this::entries().every(fn ([k, v]) = f(k, v))::from_entries()
  fn reduce(f, start) = this::entries().reduce(f, start)
  fn insert(key, value) = Object.assign(this, {[key]: value})
  fn sum() = this::entries().map(fn ([_, v]) = v).reduce(fn (acc, x) = acc + x, 0)
}

impl Iter for Array = {
  fn each(f) = this.forEach(f)
  fn map(f) = this.map(f)
  fn filter(f) = this.filter(f)
  fn reduce(f, start) = this.reduce(f, start)
  fn insert(value) = [...this, value]
  fn sum() = this.reduce(+, 0)
  fn some?(f) = this.some(f)
  fn every?(f) = this.every(f)
}

impl Iter for Set = {
  fn each(f) {
    for let elem of this {
      f(elem)
    }
  }
  fn map(f) {
    let out = new Set([])
    for let elem of this {
      out.add(f(elem))
    }
    return out
  }
  fn reduce(f, start) {
    let acc = start
    for let elem of this {
      acc = f(acc, elem)
    }
    return acc
  }
  fn filter(f) {
    let out = new Set([])
    for let elem of this {
      if f(elem) {
        out.add(elem)
      }
    }
    return out
  }
  fn insert(elem) = new Set(a).add(elem)
  fn sum() = Array.from(this).reduce(fn (acc, x) = acc + x, 0)
  fn some?(f) {
    for let elem of this {
      if f(elem) {
        return true
      }
    }
    return false
  }
  fn every?(f) {
    for let elem of this {
      if !f(elem) {
        return false
      }
    }
    return true
  }
}

fn each(f) = this::(this[Iter].each)(f::call)
fn map(f) = this::(this[Iter].map)(f::call)
fn filter(f) = this::(this[Iter].filter)(f::call)
fn some?(f) = this::(this[Iter].some?)(f::call)
fn every?(f) = this::(this[Iter].every?)(f::call)
fn reduce(f, start) = this::(this[Iter].reduce)(f::call, start)
fn insert(...args) = this::(this[Iter].insert)(...args)
fn sum() = this::(this[Iter].sum)()
