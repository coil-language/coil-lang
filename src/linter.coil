import {lex_and_parse} from "./dist/compiler.js"

protocol Lint

fn impl_lint(Ctor, type) {
  Ctor = def_record(Ctor)
  impl Lint for Ctor = fn(node) =
    node::at(:type) == type &&
    ::all?(fn([key, val]) = val[Lint](node::at(key)))
  return Ctor
}

fn has_node?(linter) = ::all?(fn(node) =
  linter[Lint](node) || node::at(:body)::pipe(#(&::has_node?(linter)))
)

fn has_no_nodes?(linter) = ::has_node?(linter)::negate()


define Lint for log = fn(other) = other::log("Lint")

impl Lint for String = fn(other) = this === other

impl Lint for Underscore = fn(other) = this::call(other)

impl Lint for Array = fn(other) =
  other is Array && this::len() == other::len() &&
  ::zip(other)::all?(fn([rule, val]) = rule[Lint](val))

@impl_lint(:decorator)
fn Decorator(@entries) {}

@impl_lint(:fn)
fn Fn(@entries) {}

@impl_lint(:fn_call)
fn FnCall(@entries) {}

@impl_lint(:id_lookup)
fn IdLookup(@entries) {}

@impl_lint(:this_assign)
fn ThisAssign(@entries) {}

fn check_rule({query, check, message}) =
  ::keep(fn(node) = query[Lint](node))
  ::reject(check)
  // ::as_array()
  // ::log()
  ::each(fn(node) = node::log(message))

let example_program = "
fn do_stuff() {
  other_stuff!()
}
"

let query = ~Fn{name: _::last() != "!"}

fn check({body}) = body
  ::has_no_nodes?(~FnCall{lhs: ~IdLookup{name: _::last() == "!"}})

let message = "
Side effects must be propagated by convention of appending '!'
to the name of functions that call effectful functions.
"

let rule = {query, check, message}

fn check_program(program_str, rule) = program_str
  ::pipe(lex_and_parse)
  ::pipe(#(&::check_rule(rule)))

check_program(example_program, rule)
