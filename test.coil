let EventStream = ~Struct["EventStream" :event_type :filter]

impl :start for EventStream = fn() {
  this.watch = ::fn(e) {
    if this.filter::call(e) {
      this.resolve::call(e)
    }
  }
  window.addEventListener(this.event_type, this.watch)
}

impl :end for EventStream = fn() =
  window.removeEventListener(this.event_type, this.watch)

impl :subscribe for EventStream = fn(f) {
  if !this.watch { this.start() }
  this.resolve = f
}

impl Symbol.asyncIterator for EventStream = async fn*() {
  while true {
    yield await new Promise(::fn(resolve) = this.subscribe(resolve))
  }
}

define Effect for ~Msg[:keydown] = fn(filter) =
  new EventStream("keydown", #(&.key::pipe(filter)))

let canvas = document.querySelector("canvas")

let ctx = canvas.getContext("2d")

let Point = ~Struct["Point" :x :y]

impl Plus for Point = fn({x, y}) =
  new Point(this.x + x, this.y + y)

let data = new Point(0, 0)

define Effect for ~Msg[:draw] = fn() {
  ctx.rect(data.x, data.y, 50, 50)
  ctx.stroke()
}

define Effect for ~Msg[:move] = fn(dir) {
  data = data + dir
}

define Effect for ~Msg[:clear] = fn() {
  ctx.clearRect(0, 0, 500, 500)
  ctx.beginPath()
}

@spawn
async fn* main() {
  yield ~Msg[:draw]
  let stream = yield ~Msg[:keydown]::with(#{"w" "a" "s" "d"})
  for await {key} of stream {
    let dir = ~Map{
      "w" => {x: 0, y: -10}
      "a" => {x: -10, y: 0},
      "s" => {x: 0, y: 10}
      "d" => {x: 10, y: 0}
    }::call(key)
    yield ~Msg[:move]::with(dir)
    yield ~Msg[:clear]
    yield ~Msg[:draw]
  }
}
