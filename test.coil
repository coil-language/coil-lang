let canvas = document.querySelector("canvas")

let ctx = canvas.getContext("2d")

define Effect for ~Msg[:clear] = fn() {
  ctx.clearRect(0, 0, 500, 500)
  ctx.beginPath()
}

let Point = ~Struct["Point" :x :y]

let mask = []

define Effect for ~Msg[:draw] = fn() {
  if mask::empty?() {return null}
  let [first, ...rest] = mask
  ctx.beginPath()
  ctx.moveTo(first.x, first.y)
  for {x, y} of rest {
    ctx.lineTo(x, y)
  }
  ctx.closePath()
  ctx.stroke()
}

define Effect for ~Msg[:place_point] = fn(x, y) =
  mask.push(new Point(x, y))

async fn* hover_mouse(channel) {
  for await msg of ~Race[channel, yield ~Msg[:mousemove]] {
    match msg {
      ~Msg[:stop] => return null
      {clientX: x, clientY: y} => yield ~Msg[:reset]::with({x, y})
    }
  }
}

@spawn
async fn* watch_mouse() {
  // let pid = null
  for await {clientX, clientY} of yield ~Msg[:mousedown] {
    yield ~Msg[:place_point]::with(clientX, clientY)
    // if pid::nil?() {
    //   // pid = fork(hover_mouse)
    // } else {
    //   pid = pid.send(~Msg[:stop])
    // }
  }
}

@spawn
async fn* main() {
  for await _ of AnimationFrames {
    yield ~Msg[:clear]
    yield ~Msg[:draw]
  }  
}
