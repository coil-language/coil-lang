@intern_vec
fn Fetch(method, url, status) {
  this.method = method  
  this.url = url
  this.status = status
}

fn as_keyword() = Keyword["for"](this.toString())

fn HttpError(code, message) {
    this.name = 'HttpError'
    this.message = message
    this.stack = (new Error()).stack
    this.code = code::as_keyword()
}
HttpError.prototype = new Error()

let http = {
  async fn* get(url) {
    if Effect keyof ~Fetch[:get url :init] {
      yield ~Fetch[:get url :init]
    }
    let promise = fetch(url).then(async fn(res) {
      if !res.ok {
        let text = await res.text()
        return Promise.reject(new HttpError(res.status, text))
      }
      return res.json()
    })
    if Effect keyof ~Fetch[:get url :loading] {
      yield ~Fetch[:get url :loading]
    }
    try {
      return await promise
    } catch error {
      if Effect keyof ~Fetch[:get url error.code] {
        yield ~Fetch[:get url error.code]::with(error)
      } else {
        yield ~Fetch[:get url :error]::with(error)
      }
      return error
    }
  }
}

let state = null
let API = { todos: "https://jsonplaceholder.typicode.com/todos" }

define Effect for ~Fetch[:get API.todos :error] = fn() {
  console.log("error")
}

define Effect for ~Fetch[:get API.todos :error] = fn() {
  console.log("404")
}

define Effect for ~Fetch[:get API.todos :loading] = fn() {
  console.log("loading")
}

async fn* main() {
  let result = yield* http.get(API.todos)
  if result::error?() { return null }
  result::at(-1)::log("LAST")
  return result
}

run(main)
