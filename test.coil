let Lexer = ~DefRecord[:entries]

fn pass() {}
fn newline() {}

impl Call for Lexer = fn(str) {
  let tokens = []  
  let index = 0
  fn rest_of_string() = str.slice(index)

  fn scan() {
    let result = rest_of_string().match(this)
    if !result || result.index != 0 { return false }
    index = index + result[0].length
    return result[0]
  }

  let line = 1
  let col = 1
  while rest_of_string() != "" {
    let found = false  
    for [pattern type] of this.entries {
      if let value = pattern::scan() {
        if type == newline {
          line = line + 1
          col = 1
          found = true
          break
        }
        if type != pass {
          tokens.push({type, value, line, col})
          col = col + value::len()
          found = true
          break
        } else {
          col = col + 1
          found = true
        }
      }
    }
    assert! found
  }

  return tokens
}

let lexer = ~Lexer{
  /^\n/ => newline
  /^\s+/ => pass
  /^\/\/.*/ => pass
  /^\,/ => pass
  /^\~/ => :tilde
  /^if\b/ => :if
  /^is\b/ => :is
  /^unless\b/ => :unless
  /^else\b/ => :else
  /^return\b/ => :return
  /^let\b/ => :let
  /^protocol\b/ => :protocol
  /^for\b/ => :for
  /^try\b/ => :try
  /^catch\b/ => :catch
  /^finally\b/ => :finally
  /^while\b/ => :while
  /^continue\b/ => :continue
  /^break\b/ => :break
  /^of\b/ => :of
  /^impl\b/ => :impl
  /^define\b/ => :define
  /^yield\b/ => :yield
  /^async\b/ => :async
  /^await\b/ => :await
  /^assert\b/ => :assert
  /^new\b/ => :new
  /^keyof\b/ => :keyof
  /^\=\>/ => :arrow
  /^\@/ => :at
  /^\&\&/ => :and_and
  /^\|\|/ => :or_or
  /^\=\=\=/ => :triple_eq
  /^\!\=\=/ => :triple_not_eq
  /^\=\=/ => :double_eq
  /^\!\=/ => :not_eq
  /^\!/ => :bang
  /^\=/ => :eq
  /^fn\b/ => :fn
  /^\{/ => :open_b
  /^\}/ => :close_b
  /^\(/ => :open_p
  /^\)/ => :close_p
  /^[\-\+]?\d+n/ => :big_int
  /^[\-\+]?(\d*\.)?\d+/ => :num
  /^\.\.\./ => :dot_dot_dot
  /^\.\./ => :dot_dot
  /^\./ => :dot
  /^\/.*\// => :regex_lit
  /^\>\=/ => :gt_eq
  /^\<\=/ => :lt_eq
  /^\>/ => :gt
  /^\</ => :lt
  /^\+/ => :plus
  /^\%/ => :mod
  /^\-/ => :minus
  /^\*\*/ => :pow
  /^\*/ => :times
  /^\&/ => :single_and
  /^\:\:/ => :double_colon
  /^\:[a-zA-Z_\?\!\$0-9]+/ => :keyword
  /^\:/ => :colon
  /^\// => :div
  /^\[/ => :open_sq
  /^\]/ => :close_sq
  /^\"([^\\\"]|\\.)*\"/s => :string_lit
  /^[a-zA-Z_\?\!\$0-9]+/ => :id
}

fn str(...args) = args.join("")

fn ParseError(expected_token_type, actual_token) {
  this.stack = (new Error()).stack
  this.message = str(
    "Expected: " expected_token_type::printable()
    " got " actual_token::at(:type)::printable()
    " @ " actual_token::at(:line)::to_s() ":" actual_token::at(:col)::to_s()
  )
}
ParseError.prototype = new Error()

fn expect_token!(kw) {
  if this::first()::at(:type) != kw {
    raise(new ParseError(kw, this::first()))
  } else {
    return this
  }
}

fn verify_exists!(parser) {
  if this::nil?() {
    raise(new Error("Parser Failed - " + parser::printable()))
  } else {
    return this
  }
}

// PARSER MACHINE IMPL

protocol ParseInstruction

let Init = ~DefVector[:expr]
impl ParseInstruction for Init = fn([_expr, tokens]) =
  [this.expr tokens]
impl Printable for Init = fn() = "Init(" + this.expr::printable() + ")"

let One = ~DefVector[:kw :as]
impl ParseInstruction for One = fn([expr tokens]) {
  let {value, type} = tokens::expect_token!(this.kw)::first()
  return [expr::merge({[this.as]: value}) tokens::skip(1)]
}
impl Printable for One = fn() = "One(kw: " + this.kw::printable() + ", as: " + this.as::printable() +  ")"

let Optional = ~DefVector[:kw :parse_fn :as]
impl ParseInstruction for Optional = fn([expr tokens]) {  
  if tokens::first() && tokens::first()::at(:type) == kw {
    return then(this.parse_fn, this.as)::parse_step([expr tokens])
  } else {
    return [expr tokens]
  }
}
impl Printable for Optional = fn() = "Optional(kw: " + this.kw::printable() + ", as: " + this.as::printable() +  ")"

impl ParseInstruction for Function = fn([_expr tokens]) = this(tokens)

let Chomp = ~DefVector[_ :kws]
impl ParseInstruction for Chomp = fn([expr tokens]) {
  let i = 0
  for kw of this.kws {
    tokens::skip(i)::expect_token!(kw)
    i = i + 1
  }
  return [expr, tokens::skip(i)]
}
impl Printable for Chomp = fn() = "Chomp(" + this.kws::printable().join(", ") + ")"

let Then = ~DefVector[:parser :kw]
impl ParseInstruction for Then = fn([expr tokens]) {
  let [new_expr new_tokens] = this.parser::call(tokens)::verify_exists!(this)
  return [expr::merge({[this.kw]: new_expr}) new_tokens]
}
impl Printable for Then = fn() = "Then(" + this.kw::printable() + ")"

let Until = ~DefVector[:end_kw :parser :kw]
impl ParseInstruction for Until = fn([expr tokens]) {
  let exprs = []  
  while tokens::first()::at(:type) != this.end_kw {
    let [expr new_tokens] = this.parser::call(tokens)
      ::verify_exists!(this)
    exprs.push(expr)
    tokens = new_tokens
  }
  if this.kw {
    return [expr::merge({[this.kw]: exprs}) tokens]
  } else {
    return [exprs, tokens]
  }
}
impl Printable for Until = fn() = "Until(end:" + this.end_kw::printable() + ", as: " + this.kw::printable() + ")"

let Case = ~DefVector[:parse_map :kw]
impl ParseInstruction for Case = fn([expr tokens]) {
  if let [new_expr, new_tokens] = this.parse_map::call(tokens) {
    return [expr::merge({[this.kw]: new_expr}), new_tokens]
  } else {
    console.log(this.parse_map)
    raise(new Error("Case Parse Failed"))
  }
}
impl Printable for Case = fn() = "Case(" + this.parse_map::printable() + ", as: " + this.kw::printable() + ")"

let Either = ~DefVector[:set :kw]
impl ParseInstruction for Either = fn([expr tokens]) {
  let op = this.set::at(tokens::first())::verify_exists!(this.set)
  let [new_expr, rest] = [tokens::first(), tokens::skip(1)]
  return [expr::merge({[this.kw]: new_expr::at(:value)}), rest]
}
impl Printable for Either = fn() = "Either(" + this.set::printable() + ", as: " + this.kw::printable() + ")"

fn parse_step(result) {
  if !(ParseInstruction keyof this) {
    console.log("This is not parsable:", this::printable())
  }
  return this[ParseInstruction](result)
}

let Parser = ~DefVector[_ :instructions]
impl Printable for Parser = fn() = "~Parser[" + this.instructions::printable().join(", ") + "]"
impl Call for Parser = fn(tokens) {
  if let result = this::parse_step([null tokens]) {
    return result
  } else {
    return this::log("Parser Failed:")
  }
}

let AbortIf = ~DefVector[:cond_fn]
impl Printable for AbortIf = fn() = "~AbortIf[" + _resolve_keyword_str(this.cond_fn.name) + "]"

impl ParseInstruction for Parser = fn(result) {
  for instruction of this.instructions {
    if instruction is AbortIf {
      if instruction.cond_fn::call(result) {
        return null
      } else {
        continue
      }
    }
    result = instruction::parse_step(result)
  }
  return result
}

let ParseMap = ~DefRecord[:entries]

impl Call for ParseMap = fn(tokens, ...args) {
  if tokens::empty?() { return null }

  for [pattern parser] of this.entries {
    if pattern == _ {
      return parser::call(tokens, ...args)
    }
    if pattern is Set && pattern::call(tokens::first()::at(:type)) {
      return parser::call(tokens, ...args)
    }
    if pattern is Array && pattern::every?(fn(p, i) = p == tokens::at(i)::at(:type)) {
      return parser::call(tokens, ...args)
    }
    if pattern is Keyword && pattern == tokens::first()::at(:type) {
      return parser::call(tokens, ...args)
    }
  }
}

// COIL PARSER START

let math_ops = #{:mod :plus :minus :times :pow :div}
let comparison_ops = #{:lt :gt :lt_eq :gt_eq}
let all_math_ops = math_ops::merge(comparison_ops)

fn parse_partial_obj_dyn_access(tokens) = ~Parser[
  ~Init[{type: :partial_obj_dyn_access}]
  ~Chomp[:open_sq]
  ~Then[parse_expr :expr]
  ~Chomp[:close_sq]
]::call(tokens)

fn parse_partial_fn_call(tokens) = ~Parser[
  ~Init[{type: :partial_fn_clal}]
  ~Chomp[:open_p]
  ~Until[:close_p parse_expr :args]
  ~Chomp[:close_p]
]::call(tokens)

fn parse_and_dot(tokens, lhs) = ~Parser[
  ~Init[{type: :and_dot, lhs}]
  ~Chomp[:single_and :dot]
  ~Case[~ParseMap{
    :id => parse_id,
    :open_sq => parse_partial_obj_dyn_access
    :open_p => parse_partial_fn_clal
  } :rhs]
]::call(tokens)

fn parse_dot(tokens, lhs) = ~Parser[
  ~Init[{type: :property_lookup, lhs}]
  ~Chomp[:dot]
  ~One[:id :property]
]::call(tokens)

fn parse_infix_bind(tokens lhs) = ~Parser[
  ~Init[{type: :bind, lhs}]
  ~Chomp[:double_colon]
  ~Case[~ParseMap{
    :id => parse_id
    :fn => parse_fn
    [:tilde :id :open_b] => parse_record_syntax
    all_math_ops => parse_unapplied_math_op
    :open_p => parse_paren_expr
  } :expr]
]::call(tokens)

fn parse_is(tokens, lhs) = ~Parser[
  ~Init[{type: :is, lhs}]
  ~Chomp[:is]
  ~Then[parse_1_2_expr, :rhs]
]::call(tokens)

fn parse_snd_assign(tokens, lhs) = ~Parser[
  ~Init[{type: :snd_assign, lhs}]
  ~Chomp[:eq]
  ~Then[parse_expr :rhs]
]::call(tokens)

fn parse_math_op(tokens lhs) = ~Parser[
  ~Init[{type: :math_op, lhs}]
  ~Either[math_ops :op]
  ~Then[parse_1_2_expr :rhs]
]::call(tokens)

fn not_adjacent?([_expr tokens]) {
  let current = tokens::first()
  let previous = tokens.collection::at(tokens.idx - 1)
  return current.line != previous.line || ((current.col - previous.col) != 1)
}

fn parse_inclusive_range(tokens lhs) = ~Parser[
  ~AbortIf[not_adjacent?]
  ~Init[{type: :inclusive_range, lhs}]
  ~Chomp[:dot_dot]
  ~Then[parse_1_2_expr :rhs]
]::call(tokens)

fn parse_exclusive_range(tokens lhs) = ~Parser[
  ~AbortIf[not_adjacent?]
  ~Init[{type: :exclusive_range, lhs}]
  ~Chomp[:dot_dot_dot]
  ~Then[parse_1_2_expr :rhs]
]::call(tokens)

fn parse_fn_call(tokens lhs) = ~Parser[
  ~AbortIf[not_adjacent?]
  ~Init[{type: :fn_call, lhs}]
  ~Chomp[:open_p]
  ~Until[:close_p parse_expr :args]
  ~Chomp[:close_p]
]::call(tokens)

fn parse_object_dynamic_access(tokens lhs) = ~Parser[
  ~AbortIf[not_adjacent?]
  ~Init[{type: :dynamic_access, lhs}]
  ~Chomp[:open_sq]
  ~Then[parse_expr :expr]
  ~Chomp[:close_sq]
]::call(tokens)

fn parse_snd_expr_step(tokens, lhs) = ~ParseMap{
  :single_and => parse_and_dot
  :dot => parse_dot
  :dot_dot => parse_inclusive_range
  :dot_dot_dot => parse_exclusive_range
  :open_p => parse_fn_call
  :double_colon => parse_infix_bind
  :open_sq => parse_object_dynamic_access
  :is => parse_is
  :eq => parse_snd_assign
  math_ops => parse_math_op
}::call(tokens, lhs)

fn parse_snd_expr([lhs tokens]) {  
  while true {
    if let [new_lhs rest] = parse_snd_expr_step(tokens, lhs) {
      lhs = new_lhs
      tokens = rest
    } else {
      return [lhs tokens]
    }
  }
}

fn parse_call_expr(tokens) = ~Parser[
  ~Chomp[:open_p]
  ~Until[:close_p parse_expr]
  ~Chomp[:close_p]
]::call(tokens)

fn parse_decorator(tokens) = ~Parser[
  ~Init[{type: :decorator}]
  ~Chomp[:at]
  ~One[:id :name]
  ~Optional[:open_p parse_call_expr :args]
  ~Then[parse_fn :fn_def]
]::call(tokens)

let parse_regex = ~Parser[
  ~Init[{type: :regex_lit}]
  ~One[:regex_lit :value]
]

let parse_str = ~Parser[
  ~Init[{type: :str}]
  ~One[:string_lit :value]
]

let parse_id = ~Parser[
  ~Init[{type: :id_lookup}]
  ~One[:id :name]
]

fn parse_reg_obj_entry(tokens) = ~Parser[
  ~Init[{type: :reg_obj_entry}]
  ~Either[#{:id :num} :key]
  ~Chomp[:colon]
  ~Then[parse_expr :value]
]::call(tokens)

let parse_obj_shorthand_entry = ~Parser[
  ~Init[{type: :obj_shorthand_entry}]
  ~One[:id :id]
]

fn parse_dynamic_obj_entry(tokens) = ~Parser[
  ~Init[{type: :dynamic_obj_entry}]
  ~Chomp[:open_sq]
  ~Then[parse_expr :key_expr]
  ~Chomp[:close_sq :colon]
  ~Then[parse_expr :value]
]::call(tokens)

fn parse_spread_obj_entry(tokens) = ~Parser[
  ~Init[{type: :spread_obj_entry}]
  ~Chomp[:dot_dot_dot]
  ~Then[parse_expr :expr]
]::call(tokens)

fn parse_obj_entry(tokens) = ~ParseMap{
  :open_sq => parse_dynamic_obj_entry
  :dot_dot_dot => parse_spread_obj_entry
  :fn => parse_fn
  [:async :fn] => parse_fn
  [:id :colon] => parse_reg_obj_entry
  [:num :colon] => parse_reg_obj_entry
  :id => parse_obj_shorthand_entry
}::call(tokens)

fn parse_obj(tokens) = ~Parser[
  ~Init[{type: :obj_lit}]
  ~Chomp[:open_b]
  ~Until[:close_b parse_obj_entry :entries]
  ~Chomp[:close_b]
]::call(tokens)

let parse_spread_assign = ~Parser[
  ~Init[{type: :spread_assign}]
  ~Chomp[:dot_dot_dot]
  ~One[:id :name]
]

let parse_assign_id = ~Parser[
  ~Init[{type: :id_assign}]
  ~One[:id :name]
]

let parse_assign_array_entry = ~ParseMap{
  :id => parse_assign_id
  :dot_dot_dot => parse_spread_assign
}

let parse_assign_array = ~Parser[
  ~Init[{type: :array_deconstruction}]
  ~Chomp[:open_sq]
  ~Until[:close_sq parse_assign_array_entry :entries]
  ~Chomp[:close_sq]
]

let parse_obj_entry_rename = ~Parser[
  ~Init[{type: :obj_entry_rename}]
  ~One[:id :old_name]
  ~Chomp[:colon]
  ~One[:id :new_name]
]

let parse_regular_obj_assign_entry = ~Parser[
  ~Init[{type: :obj_reg_entry}]
  ~One[:id :name]
]

let parse_obj_assign_entry = ~ParseMap{
  [:id :colon] => parse_obj_entry_rename
  :id => parse_regular_obj_assign_entry
  :dot_dot_dot => parse_spread_assign
}

let parse_assign_obj = ~Parser[
  ~Init[{type: :object_deconstruction}]
  ~Chomp[:open_b]
  ~Until[:close_b parse_obj_assign_entry :entries]
  ~Chomp[:close_b]
]

let parse_assign_expr = ~ParseMap{
  :id => parse_assign_id
  :open_sq => parse_assign_array
  :open_b => parse_assign_obj
  :dot_dot_dot => parse_spread_assign
}

let parse_keyword = ~Parser[
  ~Init[{type: :keyword}]
  ~One[:keyword :value]
]

fn parse_paren_expr(tokens) = ~Parser[
  ~Chomp[:open_p]
  parse_expr
  ~Chomp[:close_p]
]::call(tokens)

fn parse_yield(tokens) = ~Parser[
  ~Init[{type: :yield}]
  ~Chomp[:yield]
  parse_expr
]::call(tokens)

fn parse_await(tokens) = ~Parser[
  ~Init[{type: :await}]
  ~Chomp[:await]
  parse_expr
]::call(tokens)

let parse_num = ~Parser[
  ~Init[{type: :num}]
  ~One[:num :value]
]

let parse_big_int = ~Parser[
  ~Init[{type: :big_int}]
  ~One[:num :value]
]

fn parse_array(tokens) = ~Parser[
  ~Init[{type: :array}]
  ~Chomp[:open_sq]
  ~Until[:close_sq parse_expr :elements]
  ~Chomp[:close_sq]
]::call(tokens)

fn parse_spread(tokens) = ~Parser[
  ~Init[{type: :spread}]
  ~Chomp[:dot_dot_dot]
  ~Then[parse_expr :expr]
]::call(tokens)

let parse_unapplied_math_op = ~Parser[
  ~Init[{type: :unapplied_math_op}]
  ~Either[all_math_ops :op]
]

fn parse_bind_this(tokens) = ~Parser[
  ~Init[{type: :bind_this}]
  ~Chomp[:double_colon]
  ~Case[~ParseMap{
    :id => parse_id
    :fn => parse_fn
    all_math_ops => parse_unapplied_math_op
    :open_p => parse_paren_expr
  } :expr]
]::call(tokens)

fn parse_not(tokens) = ~Parser[
  ~Init[{type: :not}]
  ~Chomp[:bang]
  ~Then[parse_1_2_expr :expr]
]::call(tokens)

fn parse_new(tokens) = ~Parser[
  ~Init[{type: :new}]
  ~Chomp[:new]
  ~Then[parse_1_2_expr :expr]
]::call(tokens)

fn parse_num_raw(tokens) =
  parse_num(tokens)::pipe(fn([expr, tokens]) = [expr::at(:value)::to_i(), tokens])

let parse_anon_arg_id = ~Parser[
  ~Init[{type: :anon_arg_id}]
  ~Chomp[:single_and]
  ~Optional[:num parse_num_raw :arg_num]
]

let parse_unapplied_and_and = ~Parser[
  ~Init[{type: :unapplied_and_and}]
  ~Chomp[:and_and]
]

let parse_unapplied_or_or = ~Parser[
  ~Init[{type: :unapplied_or_or}]
  ~Chomp[:or_or]
]

fn parse_shorthand_anon_fn(tokens) = ~Parser[
  ~Init[{type: :shorthand_anon_fn}]
  ~Chomp[:hash :open_p]
  ~Then[parse_expr :expr]
  ~Chomp[:close_p]
]

let parse_async_modifier = ~Parser[
  ~Init[true]
  ~Chomp[:async]
]

let parse_gen_modifier = ~Parser[
  ~Init[true]
  ~Chomp[:times]
]

fn parse_fn_expr_body(tokens) = ~Parser[
  ~Init[{type: :return}]
  ~Chomp[:eq]
  ~Then[parse_expr :expr]
]::call(tokens)

fn parse_args_def(tokens) = ~Parser[
  ~Chomp[:open_p]
  ~Until[:close_p parse_assign_expr]
  ~Chomp[:close_p]
]::call(tokens)

fn parse_fn_name(tokens) = parse_id(tokens)::pipe(fn([expr, tokens]) = [expr::at(:name) tokens])

fn parse_fn(tokens) = ~Parser[
  ~Init[{type: :fn}]
  ~Optional[:async parse_async_modifier :async?]
  ~Chomp[:fn]
  ~Optional[:times parse_gen_modifier :generator?]
  ~Optional[:id parse_fn_name :name]
  ~Optional[:open_p parse_args_def :args]
  ~Case[~ParseMap{
    :eq => parse_fn_expr_body,
    :open_b => block()
  } :body]
]::call(tokens)

fn parse_keyword_record_entry(tokens) = ~Parser[
  ~Init[{type: :keyword_record_entry}]
  ~One[:id :name]
  ~Chomp[:colon]
  ~Then[parse_expr :expr]
]::call(tokens)

fn parse_regular_record_entry(tokens) = ~Parser[
  ~Init[{type: :regular_record_entry}]
  ~Then[parse_expr :key_expr]
  ~Chomp[:arrow]
  ~Then[parse_expr :value_expr]
]::call(tokens)

fn parse_record_entry(tokens) = ~ParseMap{
  [:id :colon] => parse_keyword_record_entry
  _ => parse_regular_record_entry
}::call(tokens)

fn parse_record_syntax(tokens) = ~Parser[
  ~Init[{type: :record_syntax}]
  ~Chomp[:tilde]
  ~One[:id :constructor_name]
  ~Chomp[:open_b]
  ~Until[:close_b parse_record_entry :entries]
  ~Chomp[:close_b]
]::call(tokens)

fn parse_vector_syntax(tokens) = ~Parser[
  ~Init[{type: :vector_syntax}]
  ~Chomp[:tilde]
  ~One[:id :constructor_name]
  ~Chomp[:open_sq]
  ~Until[:close_sq parse_expr :entries]
  ~Chomp[:close_sq]
]::call(tokens)

fn parse_single_expr(tokens) = ~ParseMap{
  :string_lit => parse_str
  :regex_lit => parse_regex
  :keyword => parse_keyword
  :open_p => parse_paren_expr
  :yield => parse_yield
  :await => parse_await
  :id => parse_id
  :at => parse_decorator
  :num => parse_num
  :big_int => parse_big_int
  :open_sq => parse_array
  :dot_dot_dot => parse_spread
  :double_colon => parse_bind_this
  :bang => parse_not
  :new => parse_new
  :single_and => parse_anon_arg_id
  :open_b => parse_obj
  :and_and => parse_unapplied_and_and
  :or_or => parse_unapplied_or_or
  all_math_ops => parse_unapplied_math_op
  [:hash :open_p] => parse_shorthand_anon_fn
  [:async :fn] => parse_fn
  :fn => parse_fn
  [:tilde :id :open_b] => parse_record_syntax
  [:tilde :id :open_sq] => parse_vector_syntax
}::call(tokens)

fn parse_1_2_expr(tokens) =
  parse_single_expr(tokens)
    ::pipe(parse_snd_expr)

fn parse_expr(tokens) =
  parse_single_expr(tokens)
    ::pipe(parse_snd_expr)
    // ::pipe(parse_third_expr)

fn parse_else_branch(tokens) = ~Parser[~Chomp[:else] block()]

fn parse_if(tokens) = ~Parser[
  ~Init[{type: :if}]
  ~Chomp[:if]
  ~Then[parse_expr :expr]
  block(:pass)
  ~Optional[:else parse_else_branch :fail]
]::call(tokens)

fn parse_unless(tokens) = ~Parser[
  ~Init[{type: :unless}]
  ~Chomp[:unless]
  ~Then[parse_expr :expr]
  block(:body)
]::call(tokens)

let parse_let = ~Parser[
  ~Init[{type: :let}]
  ~Chomp[:let]
  ~Then[parse_assign_expr :assign_expr]
  ~Chomp[:eq]
  ~Then[parse_expr :rhs]
]

fn parse_if_let(tokens) = ~Parser[
  ~Init[{type: :if_let}]
  ~Chomp[:if :let]
  ~Then[parse_assign_expr :assign_expr]
  ~Chomp[:eq]
  ~Then[parse_expr :expr]
  ~Chomp[:open_b]
  ~Until[:close_b parse_statement :pass]
  ~Chomp[:close_b]
  ~Optional[:else parse_else_branch :fail]
]::call(tokens)

let parse_impl = ~Parser[
  ~Init[{type: :impl_for}]
  ~Chomp[:impl]
  ~Then[parse_expr :proto_expr]
  ~Chomp[:for]
  ~One[:id :constructor]
  ~Chomp[:eq]
  ~Then[parse_expr :expr]
]

let parse_define = ~Parser[
  ~Init[{type: :define_for}]
  ~Chomp[:define]
  ~Then[parse_expr :proto_expr]
  ~Chomp[:for]
  ~Then[parse_expr :src_expr]
  ~Chomp[:eq]
  ~Then[parse_expr :expr]
]

let parse_protocol = ~Parser[
  ~Init[{type: :protocol_def}]
  ~Chomp[:protocol]
  ~One[:id :name]
]

let parse_return = ~Parser[
  ~Init[{type: :return}]
  ~Chomp[:return]
  ~Then[parse_expr :expr]
]

let parse_await_modifier = ~Parser[
  ~Init[true]
  ~Chomp[:await]
]

fn parse_for_loop(tokens) = ~Parser[
  ~Init[{type: :for_loop}]
  ~Chomp[:for]
  ~Optional[:await parse_await_modifier :await?]
  ~Then[parse_assign_expr :assign_expr]
  ~Chomp[:of]
  ~Then[parse_expr :iterable_expr]
  block(:body)
]::call(tokens)

fn parse_assert(tokens) = ~Parser[
  ~Init[{type: :assert}]
  ~Chomp[:assert!]
  ~Then[fn(tokens) = [tokens::first() tokens] :token]
  ~Then[parse_expr :expr]
  ~Optional[:string_lit parse_str :msg]
]::call(tokens)

fn parse_while_loop() = ~Parser[
  ~Init[{type: :while_loop}]
  ~Chomp[:while]
  ~Then[parse_expr :test_expr]
  ~Block[:body]
]::call(tokens)

fn parse_continue(tokens) = ~Parser[
  ~Init[{type: :continue}]
  ~Chomp[:continue]
]::call(tokens)

fn parse_break(tokens) = ~Parser[
  ~Init[{type: :break}]
  ~Chomp[:break]
]::call(tokens)

fn parse_catch(tokens) = ~Parser[
  ~Init[{type: :catch}]
  ~Chomp[:catch]
  ~One[:id :name]
  block(:body)
]::call(tokens)

fn parse_finally(tokens) = ~Parser[
  ~Init[{type: :finally}]
  ~Chomp[:finally]
  block(:body)
]::call(tokens)

fn parse_try(tokens) = ~Parser[
  ~Init[{type: :try}]
  ~Chomp[:try]
  block(:body)
  ~Optional[:catch parse_catch :catch]
  ~Optional[:finally parse_finally :finally]
]::call(tokens)

fn parse_statement(tokens) = ~ParseMap{
  :unless => parse_unless,
  :assert! => parse_assert,
  :impl => parse_impl
  :define => parse_define
  :try => parse_try
  :protocol => parse_protocol
  :let => parse_let
  :return => parse_return
  :for => parse_for_loop
  :while => parse_while_loop
  :continue => parse_continue
  :break => parse_break
  [:if :let] => parse_if_let
  :if => parse_if
  _ => parse_expr
}::call(tokens)

fn block(name) = ~Parser[
  ~Chomp[:open_b]
  ~Until[:close_b parse_statement name]
  ~Chomp[:close_b]
]

fn parse(tokens) {
  let ast = []
  while tokens::len() != 0 {
    let [statement_or_expr, rest] = parse_statement::call(tokens)
    ast.push(statement_or_expr)
    tokens = rest
  }
  return ast
}

let tokens = lexer::call("
if let [a, b] = [] {
  [1, 2]::map(f)
}
")

let ast = parse
  ::call(new CollectionView(tokens, 0))
  ::log("if let with infix bind")
