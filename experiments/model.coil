@pre(:options :mapping _::values()::iter()::all?(fn (x) = x.[Invertible])))
fn Model(name, options) {
  this.name = name
  this.options = options
}

protocol Invertible

// opposite of looking up a keyword is inserting it into a record
impl Invertible for Keyword = fn(output, new_value) = 
  output::insert(this, new_value)

// opposite of looking up a keyword is inserting it into a record
impl Invertible for Number = fn(output, new_value) = 
  output::insert(this, new_value)

fn invert(...args) = this[Invertible](...args)

impl Model = {
  ...Model.prototype  
  data: null
  fn load(data) {
    // this should not be necessary
    let output = new Model(this.names, this.options)
    let {mapping, schema} = this.options
    output.data = {}
    for [key map_fn] of mapping {
      output.data[key] = map_fn::call(data)
      if key keyof schema {
        assert! schema::at(key)::call(output.data[key])
      }
    }
    return output
  }
  fn unload() {
    let {mapping, schema} = this.options
    let output = {}
    for [key mapper] of mapping {
      if key keyof schema {  
        assert! schema[key]::call(this.data[key])
      }
      output = mapper::invert(output, this.data[key])
    }
    return output
  }
}

impl Printable for Model = fn() = this.data::printable()

fn Lookup(...keys) { this.keys = keys }

impl Call for Lookup = fn(obj) =
  this.keys::reduce(fn(result, kw) = result::at(kw), obj)

// inverse of :age _::at(:person)::at(:my_age) is:
//            {...output, person: {my_age: new_value}}
// that is    output::insert(:person ::insert(:my_age new_value))
// This breaks at ~Lookup[:age] - that is, it breaks when
// there is only one key in this.keys
impl Invertible for Lookup = fn(output, value) {
  // this is a mess, but it kind of works??
  let reversed_keys = this.keys::reverse()
  let [all_but_last last_kw] = [reversed_keys::skip(1) reversed_keys::first()]
  let obj = {[last_kw]: value}
  let i = 1
  fn get_obj_at(i) {
    // I don't get how this works..
    let result = output  
    for [_ key] of (0...i)::zip(this.keys) {
      result = result::at(key)
    }
    return result || {}
  }
  for key of all_but_last {
    obj = {[key]: this::get_obj_at(i)::merge(obj)}
    i += 1
  }
  return obj
}

// what if compose stored the functions instead of combining them right away
// kind of like Underscore
// it would mean we could use compose(:user :id) in
// these mappings & as long as each step was reversible..
// it should be possible?
// idk
// The other thing is reading compose(:user :id)
// is pretty meaningless because that word has been
// overloaded so many times

fn Point(x, y) { this.x = x; this.y = y }

fn Construct(ctor, ...entries) { this.ctor = ctor; this.entries = entries }

impl Symbol.iterator for Construct = fn*() {
  let i = 0
  let prev = null
  for elem of this.entries {
    i += 1
    if i::odd?() {
      prev = elem
      continue
    }
    yield [prev elem]
  }
}

impl Call for Construct = fn(data) {
  let args = []
  for [_prop, mapper] of this {
    args.push(mapper::call(data))
  }
  let Ctor = this.ctor
  return new Ctor(...args)
}

impl Invertible for Construct = fn(output, value) {
  for [prop mapper] of this {
    output = mapper::invert(output, value[prop])
  }
  return output
}

let Post = new Model("Post" {
  mapping: {
    point: ~Construct[Point
      :x :point_x
      :y :point_y
    ]
  }
  schema: {}
})

let my_post = Post.load({point_x: 10, point_y: 20})::log()
my_post.data.point.x += 20
my_post.unload()::log()
