fn Composite(@type, @lhs, @rhs) {}
impl Equal for Composite = fn(other) = new Composite(Equal, this, other)

protocol IsFoo
protocol Chain

fn sym(chain) {
  chain ||= []
  return new Proxy({}, {
    fn get(_, prop) {
      if prop == Plus {
        return fn(rhs) = new Composite(Plus, sym(chain), rhs)
      } else if prop == Equal {
        return fn(rhs) = new Composite(Equal, sym(chain), rhs)
      } else if prop == IsFoo {
        return true
      } else if prop == Chain {
        return chain  
      } else {
        return sym(chain::push(prop))
      }
    }
  })
}

fn solve_eq(world, {lhs, rhs}) {
  let knowns = {}
  let [x] = lhs.lhs[Chain]
  let [y] = lhs.rhs[Chain]
  if world::at(x) && world::at(y) {
    return world::at(x) + world::at(y) == rhs
  } else if world::at(y) {
    console.log("x =", rhs - world::at(y))
    return rhs - world::at(y)
  }
  // if let [name] = rhs[Chain] {
  //   let rhs_val = world::at(name)

  // }
  if !rhs[IsFoo] {
    return rhs
  }
}

fn sym_eval(world, expr) {
  if expr is Composite && expr.type == Plus {
    return sym_eval(world, expr.lhs) + sym_eval(world, expr.rhs)
  } else if expr is Composite && expr.type == Equal {
    return solve_eq(world, expr)
  } else if expr[IsFoo] {
    let [prop] = expr[Chain]
    return world::at(prop)
  } else if expr::num?() {
    return expr
  } else {
    assert! false
  }
}

let {x, y} = sym()
console.log(sym_eval({y: 8}, x + y == 10))
