str[:kw] = fn (...args) = fn (obj) {
  let out = ""
  for o of args {
    if o is Keyword {
      out += obj[o]
    } else {
      out += o
    }
  }
  return out
}

protocol Tokenize

impl Tokenize for String = fn (program_str) {
  if program_str.slice(skip).startsWith(this) {
    return {value: this, rest: program_str.slice(this.length)}
  }
}

impl Tokenize for RegExp = fn (program_str) {
  if let result = program_str.match(this) {
    return {value: result[0], rest: program_str.slice(result[0].length)}
  }
}

fn tokenize(program_str) = this[Tokenize](program_str.trim())

protocol Parse
fn parse(parse_expr) = this[Parse](parse_expr)

fn Parser(@kind @instructions) {}
fn Chomp(@token) {}
fn Store(@token @kw) {}
fn Then(@parser @kw) {}
define "[]" for Parser = fn (kind ...instructions) = new Parser(kind instructions)
define "[]" for Chomp = fn (token) = new Chomp(token)
define "[]" for Store = fn (token kw) = new Store(token kw)
define "[]" for Then = fn (parser kw) = new Then(parser kw)

fn Compiler(@parser @eval_fn) {}
fn emitting(eval_fn) = new Compiler(this, eval_fn)

impl Parse for Chomp = fn ([result rest_of_string]) {
  let {value, rest} = this.token::tokenize(rest_of_string)
  return [result rest]
}
impl Parse for Store = fn ([result rest_of_string]) {
  let {value, rest} = this.token::tokenize(rest_of_string)
  return [result::insert(this.kw, value) rest]
}
impl Parse for Then = fn ([old_result rest_of_string_]) {
  let [result rest_of_string] = this.parser::parse([null rest_of_string_])
  // TODO: use a protocol here
  if this.parser is Compiler {
    result = this.parser.eval_fn(result)
  }
  return [old_result::insert(this.kw result) rest_of_string]
}
impl Parse for Parser = fn (parse_expr) =
  this.instructions::reduce(
    fn (parse_expr, instruction) = instruction::parse(parse_expr)
    parse_expr
  )
impl Call for Parser = fn (program_str) = this::parse([{} program_str])

impl Parse for Compiler = fn (parse_expr) = this.parser::parse(parse_expr)
impl Call for Compiler = fn (program_str) =
  this.parser::call(program_str)::pipe(0 this.eval_fn)

let id = /[a-zA-Z]+/

let eval_bignum = Parser[:bignum
  Store[/\d+/ :num]
  Chomp["n"]
]::emitting(str.kw("new BigNum(" :num ")"))

let eval_let = Parser[:let
  Chomp["let"]
  Store[id :name]
  Chomp["="]
  Then[eval_bignum :expr]
]::emitting(str.kw("let " :name " = " :expr))

eval_let::call("let a = 10n")
  ::log()
