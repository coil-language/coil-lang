protocol Sample

@def_call
fn sample(...args) = this[Sample](...args)

@def_call
fn* sample_stream(...args) {
  loop {
    yield this::sample(...args)
  }
}

define Sample for :xs_float = Math.random
define Sample for :sm_float = fn() = Math.random() * 50
define Sample for :lg_float = fn() = Math.random() * 100000000
define Sample for :med_float = fn() = Math.random() * 1000
define Sample for :xs_int = fn() = Math.floor(Math.random() * 10)
define Sample for :sm_int = fn() = Math.floor(Math.random() * 50)
define Sample for :lg_int = fn() = Math.floor(Math.random() * 100000000)

impl Sample for Set = fn() = ::as_array()::at((0..this.size)::sample())
define Sample for :str_set = fn(set) = set::take((5..20)::sample())::reduce(+, "")

impl Sample for IRange = fn() =
  Math.floor(Math.random() * (this.end - this.start)) + this.start
impl Sample for ERange = fn() =
  Math.floor(Math.random() * (this.end - this.start - 1)) + this.start

@def_record
fn Fake(@entries) {}

impl Sample for Fake = fn() =
  ::map(fn([key, kind]) = [key, kind::sample()])::as_obj()

define Sample for :first_name = fn() {
  let names = ["marcelle" "jake" "jill" "john" "lori"]
  return names::at((0..names::len())::sample())
}

~Fake{name: :first_name
      age: 0..100
      grade: #{:A :B :C :D :F}}
  ::sample_stream()::take(5)::as_array()::log()
