protocol Sample

@impl_callable
fn sample(...args) = this[Sample](...args)

@impl_callable
fn* sample_stream(...args) {
  while true {
    yield this::sample(...args)
  }
}

define Sample for :xs_float = Math.random
define Sample for :sm_float = fn() = Math.random() * 50
define Sample for :lg_float = fn() = Math.random() * 100000000
define Sample for :med_float = fn() = Math.random() * 1000
define Sample for :xs_int = fn() = Math.floor(Math.random() * 10)
define Sample for :sm_int = fn() = Math.floor(Math.random() * 50)
define Sample for :lg_int = fn() = Math.floor(Math.random() * 100000000)
define Sample for :bounded_int = fn(max_size) = Math.floor(Math.random() * max_size)

impl Sample for Set = fn(max_size) =
  (0..:bounded_int::sample(max_size || 50))
    ::map(#(:bounded_int::sample(this.size)))
    ::map(::as_array())

define Sample for :str_set = fn(set, max_size) =
  set::sample(max_size)::reduce(+, "")

impl Sample for IRange = fn() =
  :bounded_int::sample(this.end - this.start) + this.start

@def_record
fn Fake(@entries) {}

impl Sample for Fake = fn() =
  ::map(fn([key, kind]) = [key, kind::sample()])::as_obj()

define Sample for :first_name = fn() {
  let names = ["marcelle" "jake" "jill" "john" "lori"]
  return names::at((0..names::len())::sample())
}

~Fake{
  name: :first_name
  age: :sm_int
}
  ::sample_stream()::take(5)::as_array()::log()
