// The module naively implements persistent immutable vector & dict

// Immutable Vec implementation

let MAX_SIZE = 500

fn VecMergeNode(@left, @right) {
  this.length = left.length + right.length
}
fn VecPushNode(@left, @node) {
  this.length = left.length + 1
}
fn VecNode(@list) {
  this.length = list.length
}

impl Printable for VecMergeNode = fn() = ::map(printable)::as_array()
impl Printable for VecPushNode = fn() = ::map(printable)::as_array()
impl Printable for VecNode = fn() = ::map(printable)::as_array()

impl Symbol.iterator for VecPushNode = fn*() {
  yield* this.left
  yield this.node
}
impl Symbol.iterator for VecNode = fn() = this.list::iter()
impl Symbol.iterator for VecMergeNode = fn*() {
  yield* this.left
  yield* this.right
}

// Should we consider making a VecMergeNode vs MaxVecMergeNode
// to avoid having to make the if this.right::len() > MAX_SIZE
// on every concat.

impl Vector for VecMergeNode = {
  fn len() = this.length
  fn at(idx) {
    if idx < this.left::len() {
      return this.left::at(idx)
    } else {
      return this.right::at(idx - this.left::len())
    }
  }
  // maybe we can copy .right & append up to a certain 
  // point, because small lists should be fast to shallow copy
  // better than having very nested trees later.
  fn push(item) {
    if this.right::len() === MAX_SIZE {  
      return new VecPushNode(this, item)
    } else {
      // we are assuming that this.left is "full"
      return new VecMergeNode(this.left, [...this.right, item])
    }
  }
  fn concat(vec) {
    // again we are assuming that this.left is "full"
    if this.right::len() > MAX_SIZE {  
      return new VecMergeNode(this, vec)
    } else {
      return new VecMergeNode(this.left, [...this.right, ...vec])
    }
  }
  fn last() = this.right::last()
  fn first() = this.left::first()
  fn has?(val) = this.left::has?(val) || this.right::has?(val)
  fn empty?() = false
}

// we could just remove the notion of a PushNode all together
// it seems like a premature optimization that actually will make ::concat very slow
// maybe?
// its possible that slowness will happen with MergeNode aswell.
impl Vector for VecPushNode = {
  fn len() = this.length
  fn at(idx) {
    if idx < this.left::len() {
      return this.left::at(idx)
    } else if idx == this.left::len() {
      return this.node
    }
  }
  fn push(item) = new VecMergeNode(this.left, [this.node, item])
  // we can probably optimize this for cases that vec is a small array/vec
  fn concat(vec) {
    if (vec::len() + this.left::len() + 1) === MAX_SIZE {
      return new VecMergeNode(this, vec)
    }
    if (vec::len() + this.left::len() + 1) > MAX_SIZE {
      // this could break the assumption that this.left is "full"..
      // meaning that the tree leafs could potentially have a lot of small lists.
      // What we could do is break up vec to make the following cond be true
      // this.left::len() + new_vec::len() + 1 == MAX_SIZE
      let new_vec_idx = MAX_SIZE - vec::len()
      let [new_left, new_vec] = [vec::take(new_vec_idx), vec::skip(new_vec_idx)]
      return new VecMergeNode([...this.left, this.node, ...new_left], new_vec)
    } else {
      return new VecNode([...this.left, this.node, ...vec])
    }
  }
  fn last() = this.node
  fn first() = this.left::first()
  fn has?(val) = this.node == val || this.left::has?(val)
  fn empty?() = false
}

impl Vector for VecNode = {
  fn len() = this.length
  fn at(idx) = this.list.at(idx)
  fn push(item) = new VecPushNode(this, item)
  fn concat(vec) = new VecMergeNode(this, vec)
  fn last() = this.list.at(-1)
  fn first() = this.list.at(0)
  fn has?(val) = this.list::has?(val)
  fn empty?() = this::len() == 0
}
impl :remove for VecPushNode = fn(val) {
  if this.node == val { return this.left }
  else { return new VecPushNode(this.left.remove(val), this.node) }
}
impl :remove for VecNode = fn(value) {
  let idx = this.list.findIndex(fn(item) = item == value)
  return new VecMergeNode(this.list.slice(0, idx), this.list.slice(idx + 1))
}
impl :remove for VecMergeNode = fn(value) =
  new VecMergeNode(this.left.remove(value), this.right.remove(value))

fn Vec() {}

define Vector for Vec = fn(items) = new VecNode(items)

impl Plus for VecNode = fn(other) = this::concat(other)
impl Plus for VecPushNode = fn(other) = this::concat(other)
impl Plus for VecMergeNode = fn(other) = this::concat(other)

// Immutable Dict 

fn DictMergeNode(@left, @right) {
  this.length = left::len() + right::len()
}
fn DictPushNode(@left, @key, @value) {
  this.length = left::len() + 1
}
fn DictNode(entries) {
  this.dict = ObjectLiteral.from_entries(entries)
  this.length = Object.keys(this.dict).length
}

impl Printable for DictMergeNode = fn() = ::map(printable)::pipe(Object.fromEntries)
impl Printable for DictPushNode = fn() = ::map(printable)::pipe(Object.fromEntries)
impl Printable for DictNode = fn() = ::map(printable)::pipe(Object.fromEntries)

impl Symbol.iterator for DictMergeNode = fn*() {
  yield* this.left
  yield* this.right
}

impl Symbol.iterator for DictPushNode = fn*() {
  yield* this.left
  yield [this.key this.right]
}

impl Symbol.iterator for DictNode = fn() = this.dict::iter()

fn Dict() {}

define Record for Dict = fn(entries) = new DictNode(entries)

impl Record for DictMergeNode = {
  fn at(key) = this.right::at(key) || this.left::at(key)
  fn insert(key, value) = new DictPushNode(this, key, value)
  fn merge(other) = new DictMergeNode(this, other)
  fn keys() = this.left::keys()::concat(this.right::keys())
  fn values() = this.right::values()::concat(this.left::values())
  fn has?(key) = this.right::has?(key) || this.left::has?(key)
  fn len() = this.length
  fn empty?() = false
}

impl Record for DictPushNode = {
  fn at(key) {
    if this.key == key {
      return value
    } else {
      return this.left::at(key)
    }
  }
  fn insert(key, value) = new DictMergeNode(this, {[this.key]: this.value, [key]: value})
  fn merge(other) = new DictMergeNode(this, other)
  fn keys() = this.left::keys()::push(this.key)
  fn values() = this.left::values()::push(this.value)
  fn has?(key) {
    if this.key == key {
      return true
    } else {
      return this.left::has?(key)
    }
  }
  fn len() = this.length
  fn empty?() = false
}

impl Record for DictNode = {
  fn at(key) = this.dict[key]
  fn insert(key, value) = new DictPushNode(this, key, value)
  fn merge(other) = new DictMergeNode(this, other)
  fn keys() = Object.keys(this.dict)
  fn values() = Object.values(this.dict)
  fn has?(key) = key::as_str() keyof this.dict
  fn len() = this.length
  fn empty?() = this.length === 0
}

impl Plus for DictNode = fn(other) = this::merge(other)
impl Plus for DictPushNode = fn(other) = this::merge(other)
impl Plus for DictMergeNode = fn(other) = this::merge(other)

// vecs are essentially trees of arrays
fn as_vec() = Vec::construct_vector(this::as_array())
fn as_dict() = Dict::construct_record(this::as_array())

let vec = ~[]

for _ of 0..100000 {
  let rand_vec = Array["from"]({length: 50})::map(Math.random)::as_vec()
  vec += rand_vec
}

// so uh, this feels wrong :)
console.log(vec)
// ~[:id :name :age]::skip(2)::as_vec()::log()

// let arr = []
// let rand_array = Array["from"]({length: 500})::map(Math.random)
// arr = [...arr, ...rand_array]


// let arr = ~[]
// let rand_array = Array["from"]({length: 500})::map(Math.random)::as_array()::pipe(#(new VecNode(&)))
// arr += rand_array
