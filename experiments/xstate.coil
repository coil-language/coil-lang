// import {assign} from "xstate"

// FAKE OBJECT API START

fn assign(obj) = obj

protocol PropChain
protocol Accessed
protocol Name
protocol FakeObject
protocol RootName

fn fake_object?() = this[FakeObject]

fn root_node?(root) = this&.[RootName] == root

fn eval_msg_chain(obj) =
  this[PropChain]::reduce(fn(o, k) = o[k], obj)

fn fake_object(root_node, msgs, name) = new Proxy({}, {
  fn get(_target, msg, _receiver) {
    this.accessed ||= []
    this.accessed = [...this.accessed, msg]
    if msg == Printable {
      return name
    } else if msg == RootName {
      return root_node
    } else if msg == FakeObject {
      return true
    } else if msg == Name {
      return name
    } else if msg == Accessed {
      return this.accessed::filter(_ != Accessed)
    } else if msg == PropChain {
      return msgs
    } else {
      return fake_object(root_node, [...(msgs || []), msg], msg)
    }
  }
})

// FAKE OBJECT API END

protocol ResolveAssignExpr

let Target = ~DefVector[:state]
let Assign = ~DefRecord[:properties]
impl Symbol.iterator for Assign = fn*() {
  for entry of this.properties {
    yield entry
  }
}

// We can't take apart a function..
impl ResolveAssignExpr for Function = fn(ctx_key, ctx, args) =
  this(ctx, args)

impl ResolveAssignExpr for ObjectLiteral = fn(ctx_key, ctx, args) {
  let local_ctx = ctx::at(ctx_key)

  let assign_ctx = this::map(fn(key, value) =
    [key, value[ResolveAssignExpr](key, local_ctx, args)]
  )

  return ctx::insert(ctx_key, local_ctx::merge(assign_ctx))
}

impl ResolveAssignExpr for Underscore = fn(ctx_key, ctx, xstate_args) {
  let output = ctx::at(ctx_key)
  for {f, args} of this {
    let actual_args = args::map(fn(arg) {
      if arg::root_node?(:ctx) {
        return arg::eval_msg_chain(ctx::at(ctx_key))
      } else if arg::root_node?(:args) {
        return arg::eval_msg_chain(xstate_args)
      } else {
        return arg[ResolveAssignExpr](ctx_key, ctx, xstate_args)
      }
    })
    output = output::f::call(...actual_args)
  }
  return output
}

protocol GenerateXState

impl GenerateXState for Assign = fn(event_obj) {
  let my_assign = {}
  for [key, value] of this {
    if value&.[ResolveAssignExpr] {
      my_assign[key] = fn(ctx, args) = value[ResolveAssignExpr](key, ctx, args)
    } else {
      my_assign[key] = fn(ctx, args) = value
    }
  }

  return {
    ...event_obj,
    actions: [...event_obj.actions, assign(my_assign)]
  }
}

impl GenerateXState for Target = fn(event_obj) {
  return {
    ...event_obj,
    target: this.state.toString()
  }
}

fn as_xstate() {
  let {initial, context, ...state_defs} = this
  let states = {}
  for [name, events] of state_defs::as_obj() {
    let state_events = {}
    for [event_name, gen_fn] of events {
      state_events[event_name] = 
        gen_fn(fake_object(:ctx), fake_object(:args))
          ::as_array()
          ::reduce(
            fn(event, effect) = effect[GenerateXState](event),
            {actions: []}
          )
    }
    states[name] = {on: state_events}
  }
  return {
    initial,
    context,
    states,
  }
}

let Mask = {
  initial: :idle
  context: {
    masks: []
    creating: null
    editing: null
  }
  idle: {
    fn* START_CREATE(_ctx, {point}) {
      yield ~Assign{creating: {point}}
      yield ~Target[:creating]
    }
    fn* START_EDIT(_ctx, {point, mask}) {
      yield ~Assign{editing: {point, mask}}
      yield ~Target[:editing]
    }
  }
  creating: {
    fn* END_CREATE(_ctx, {mask}) {
      yield ~Assign{
        masks: _::insert(mask)
        creating: null
      }
      yield ~Target[:idle]
    }
    fn* CLEAR() {
      yield ~Assign{creating: null}
      yield ~Target[:idle]
    }
  }
  editing: {
    fn* END_EDIT({editing} {new_point}) {  
      yield ~Assign{masks: _::update(editing.point, new_point)}
      yield ~Target[:idle]
    }
  }
}::as_xstate()
  ::pipe(compose(:states :idle :on :START_CREATE))
  ::pipe(#(console.log(&)))
