protocol Fmt

@def_call
fn fmt = this[Fmt]()

fn Color(@string, @css) {}

fn Colored(@string, @color) {}
fn color(color) = new Colored(this, color)
impl Fmt for Colored = fn = {
  string: str("%c" this.string "%c"),
  css: [str("color: " this.color) "color: unset"]
}

@def_vector
fn FString(...elems) { this.elems = elems }
impl Fmt for FString = fn {
  let fmt_keys = this.elems::map(fmt)::into([])
  return {
    string: str(fmt_keys::map(:string)::join(""))
    css: fmt_keys::flat_map(:css)::into([])
  }
}

define Vector for Color = fn([color]) = fn(...strings) =
  new Color(
    str("%c" ...strings "%c")
    [str("color: " color) "color: unset"]
  )

impl Fmt for Keyword = fn = ~Color[:darkblue](":" this.value)
impl Fmt for Number = fn = ~Color[:darkgreen](this)
impl Fmt for String = fn = ~Color[:blue]("\"" this "\"")

fn def_vec(Ctor, kw) {
  define Vector for Ctor = fn(entries) = new Ctor(...entries)
  impl Fmt for Ctor = fn {
    let fmt_keys = this[kw]::map(fmt)::into([])
    return {
      string: str("~%c" Ctor.name "%c[" fmt_keys::map(:string)::join(" ") "]")
      css: ["color: lightgreen" "color:unset" ...fmt_keys::flat_map(:css)]
    }
  }
  return Ctor
}

@def_vec(:keys)
fn Keys(...keys) { this.keys = keys }

@def_call
fn printf {
  let {string, css} = this::fmt()
  console.log(string, ...css)
  return this
}

fn Raw(@str) {}
@def_call
fn raw = new Raw(this)
impl Fmt for Raw = fn = {string: this.str, css: []}

fn def_fmt(Ctor) {
  impl Fmt for Ctor = fn {
    let size = Object.keys(this)::len()
    return ~FString[
      Ctor.name::color(:darkred)
      "("::raw()
      ...new ObjectLiteral(this)
        ::zip(0..)
        ::map(fn ([[property_key val] idx]) = ~FString[
          property_key::color(:darkblue)
          ": "::raw()
          val
          idx::pipe(~CallMap{0..(size - 1) => ", ", _ => ""} raw)
        ])
      ")"::raw()
    ]::fmt()
  }
  return Ctor
}

@def_fmt
fn One(@kw @as) {}

new One("hey" 1)
  ::printf()
