import {component, use_state} from "./react.coil"
import * as ReactDOM from "react-dom/client"

fn section(lang) =
  :div[
    :button.close{
      onClick: fn (e) = e.preventDefault()
      contentEditable: false
    }["—"]
    :pre.section{
      suppressContentEditableWarning: true,
      contentEditable: true,
      "data-lang" => lang
    }[]
  ]

protocol SnippetView

@def-call
fn snippet-view = this.kind.[SnippetView](this)

define SnippetView for :h1 = fn({title}) = :h1{
  suppressContentEditableWarning: true
  contentEditable: true
}[title]

define SnippetView for :section = fn({body}) = :div[
  :button.close{
    onClick: fn (e) = e.preventDefault()
    contentEditable: false
  }["—"]
  :section{
    suppressContentEditableWarning: true
    contentEditable: true
    autoFocus: true
  }[body]
]

define SnippetView for :code = fn({lang}) =
  section(lang)

@component
fn CreateSnippet({select}) {
  let show-modal = use_state(false)
  fn select-option {
    show-modal.set!(false)
    this::select()
  }

  return :div[
    :button.add{onClick: fn = show-modal.set!(true)}["+"]
    show-modal.val && :dialog.col[
      :p["Select one:"]
      :div.row[
        :button{onClick: :h1::select-option}["Header"]
        :button{onClick: :section::select-option}["Paragraph"]
        :button{onClick: :code::select-option}["Code"]
      ]
    ]
  ]
}

protocol EmptySection

define EmptySection for :h1 = {kind: :h1, title: ""}
define EmptySection for :section = {kind: :section, body: ""}
define EmptySection for :code = {kind: :code, lang: "coil"}

// imagine being able to do the following
// let snippets = use_state([])
// ...snippets::map(fn (entity, ops) {
//   entity::view(ops.delete!)
// })

@component
fn App({}) {
  let snippets = use_state([
    {kind: :h1, title: "Button:"}
    {kind: :section, body: "this is how you make a button"}
    {kind: :code, lang: "coil"}
  ])

  return :main[
    ...snippets.val::map(snippet-view)
    CreateSnippet{
      select: fn {
        snippets.update!(_::push(this.[EmptySection]))
        // :)
        setTimeout(::fn {
          document.querySelector(str(this ":last-of-type"))
            .focus()
        })
      }
    }
  ]
}

// how could we do a reversed into, where you go into a list before
// well the collection that's getting filled gets to decide
// 

ReactDOM
  .createRoot(document.getElementById("app"))
  .render(App[])
// setTimeout(fn {
//   document.querySelector("dialog").showModal()
// })