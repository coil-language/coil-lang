import React from "react"
import {useEffect} from "react"
import ReactDOM from "./react.js"
import {use_state, Atom} from "./react.js"

protocol ToReactChild

impl ToReactChild for Atom = fn = this.val
impl ToReactChild for Object = fn = this

@def_call
fn to_react_child() = this[ToReactChild]()

fn Elem(@ctor, @attrs, @children) {}
impl Into for Elem = fn(children) = 
  new Elem(this.ctor, this.attrs, [...this.children, ...children])
impl ToReactChild for Elem = fn() {
  if this.children is Array {  
    return React.createElement(this.ctor, this.attrs, ...this.children::map(to_react_child))
  } else {
    return React.createElement(this.ctor, this.attrs, this.children::to_react_child())
  }
}

impl Vector for Keyword = fn(children) {
  let str = this.value
  let [elem_name, className] = str.split(".")
  return new Elem(elem_name, {className}, children)
}

impl Record for Keyword = fn(attrs) {
  attrs = attrs::into({})  
  let str = this.value
  let [elem_name, className] = str.split(".")
  return new Elem(elem_name, {className, ...attrs}, attrs::at(:children))
}

fn component(Component) {
  let ReactComponent = fn(...args) = Component(...args)::to_react_child()
  define Record for ReactComponent = fn(attrs) {
    attrs = attrs::into({})
    return React.createElement(ReactComponent, attrs, attrs::at(:children))
  }
  define Vector for ReactComponent = fn(children) =
    React.createElement(ReactComponent, null, ...children::map(to_react_child))
  define Into for ReactComponent = fn(iterable) =
    React.createElement(ReactComponent, null, [...iterable::map(to_react_child)])
  return ReactComponent
}

let char_numeric? = ("0"..="9")::into(#{})

let btns = [
  [:AC :flip_sign :percent :div]
  [7 8 9 :times]
  [4 5 6 :minus]
  [1 2 3 :plus]
]

let op->str = ~Map{
  :AC => "AC"
  :flip_sign => "+/-"
  :percent => "%"
  :div => "/"
  :minus => "-"
  :times => "x"
  :plus => "+"
}

@component
fn CalcRow({btns, select}) = btns
  ::map(fn(field) = ~:button.btn{
    key: field
    onClick: #(select(field))
    children: field::pipe(op->str) || field
  })
  ::into(~:div.row[])

protocol Select
fn select() = this[Select]()

@component
fn App() {
  let amount = use_state(10)
  let op = use_state(null)

  fn num_handler(num) = {
    fn times() = amount.update(_ * num)
    fn plus() = amount.update(_ + num)
    fn minus() = amount.update(_ - num)
    fn div() = amount.update(_ / num)
  }[op.val]()

  impl Select for Number = fn{
    if op.val {
      num_handler(this)
    } else {
      amount.update((_ * 10) + this)
    }
    op.set(null)
  }
  impl Select for Keyword = fn{op.set(this)}
  define Select for :AC = fn{amount.set(0)}
  define Select for :flip_sign = fn{amount.update(_ * -1)}
  define Select for :percent = fn{amount.update(_ / 100)}

  return ~:div[
    ~:div.result[amount]
    ...btns::map(fn(btns_row) = ~CalcRow{
      btns: btns_row,
      select: #(&::select())
    })
  ]
}

ReactDOM
  .createRoot(document.getElementById("app"))
  .render(~App{})
