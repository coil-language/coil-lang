import {lex_and_parse, eval_ast} from "@coil-lang/compiler/src/compiler.coil"
import {render, Render} from "./ui.coil"

import "./css.coil"
import {node_to_html, html_to_ast} from "./ast.coil"

fn eval-node(node) =
  node.children::pipe(html-to-ast eval-ast eval)

let editor = 
  ":p[\"Hello Friends\"]::into(document.body)"
    ::pipe(lex_and_parse)
    ::map(node-to-html)
    ::into(:div.code_block{"tabindex" => 0}[])

:div[
  :header[:h1["Coil-Lang Structural Editor (WIP)"]]
  :a.github{href: "https://github.com/coil-language/coil-lang"}["Github"]
  :ul.legend[  
    :li["Eval:" :div.shortcut["Ctrl+Enter"]]
    :li["Next Node:" :div.shortcut["Tab"]]
    :li["Previous Node:" :div.shortcut["Shift+Tab"]]
    :li["Nav Up:" :div.shortcut["Ctrl+p"]]
    :li["Nav Down:" :div.shortcut["Ctrl+n"]]
    :li["New Node:" :div.shortcut["Esc,Esc,Enter"]]
    :button{onclick: fn = eval-node(document.querySelector(".code_block")) }["Eval"]
  ]
  editor
]
  ::into(document.body)


let block = document.querySelector(".code_block")

document.addEventListener("keydown" fn (e) {  
  if e.key == "Enter" && (e.ctrlKey || e.metaKey) {
    eval-node(document.querySelector(".code_block"))
  } else if e.key == "l" && e.ctrlKey {
    console.clear()
  } else if e.key == "Enter" {
    e.preventDefault()
  }
})

let last_key = null
window.addEventListener("keydown" fn (e) {
  if Set[e.key last_key] == Set["Escape"] ||
    (e.key == "Enter" && e.target == document.body) {
    block.focus()
  }
  last_key = e.key
})

fn handle_delete(e) {
  if Set[e.key last_key] == Set["Backspace"] && e.target.textContent.trim() == "" {
    let closest_node_root = e.target.closest("[data-kind]")
    if closest_node_root.parentNode.childNodes.length == 1 {
      closest_node_root.parentNode.closest("[data-kind]").remove()
    } else {
      closest_node_root.remove()
    }
  }
}

protocol TextNodes

impl TextNodes for Keyword = Set[]
define TextNodes for :id_assign = Set["name"]
define TextNodes for :property_lookup = Set["property"]
define TextNodes for :math_op = Set["op"]
define TextNodes for :spread_assign = Set["name"]

fn register_eval(root) {
  root.querySelectorAll("[data-attr]:not(:has([data-attr]))")::each(fn (elem) {
    elem.addEventListener("blur" fn (e) {
      let parent = e.target.closest("[data-kind]")
      let kind = parent.dataset.kind::as_keyword()
      if e.target.dataset.attr |> kind.[TextNodes] {
        return
      } else {
        let out = elem.textContent::pipe(lex_and_parse).[0]::pipe(node-to-html render)
        let out_target = elem.closest("[data-kind]")
        register_eval(out)
        out_target.replaceWith(out)
      }        
    })
  })
}
register_eval(document)

block.addEventListener("keydown" fn (e) {
  fn most-recent-parent = (e.target.closest("[data-kind=fn] > [data-attr=body] > [data-kind]") || e.target.closest(".code_block > [data-kind]"))
  if e.key == "p" && e.ctrlKey {
    most-recent-parent()
      &.previousSibling
      &.querySelector("[data-attr]:not(:has([data-attr]))")
      &.focus()
  } else if e.key == "n" && e.ctrlKey {
    most-recent-parent()
      &.nextSibling
      &.querySelector("[data-attr]:not(:has([data-attr]))")
      &.focus()
  }
})

block.addEventListener("keydown" fn (e) {  
  if e.target != block { return handle_delete(e) }
  let new_node = :div.plain_node{"contenteditable" => true}[].[Render]()
  block.appendChild(new_node)
  fn reify(e) {
    try {
      let node = lex_and_parse(e.target.textContent).[0]::pipe(node-to-html render)
      e.target.outerHTML = node.outerHTML
    } catch err {
      console.log("there's been an error" err)
      new_node.classList.add("error")
    }
  }

  new_node.addEventListener("blur" reify)
  new_node.addEventListener("keydown" fn (e) {
    if e.key == "Enter" {
      reify(e)
    } else if e.key == "Backspace" && new_node.textContent.trim()::empty?() {
      new_node.remove()
    }
  })
  new_node.focus()
})
