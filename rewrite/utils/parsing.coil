protocol ParseInstruction

fn Type(kw) { this.kw = kw }
fn type(kw) = new Type(kw)
impl ParseInstruction for Type = fn([_expr, tokens]) =
  [{type: this.kw} tokens]

fn Skip(...kws) { this.kws = kws }
fn skip(...kws) = new Skip(kws)
impl ParseInstruction for Skip = fn([expr tokens]) {
  for kw of this.kws {  
    assert! tokens::first() == this.kw
    tokens = tokens::skip(1)
  }
  return [expr, tokens]
}

fn Then(parser, kw) {
  this.parser = parser
  this.kw = kw
}
fn then(parser, kw) = new Then(parser, kw)
impl ParseInstruction for Then = fn([expr tokens]) {
  let [new_expr new_tokens] = this.parser::call(tokens)
  return [expr::merge(new_expr) new_tokens]
}

fn Until(end_kw, parser, kw) {
  this.end_kw = end_kw
  this.parser = parser
  this.kw = kw
}
fn until(end_kw, parser, kw) = new Until(end_kw, parser, kw)
impl ParseInstruction for Until = fn([expr tokens]) {
  let exprs = []  
  while tokens::first() != this.end_kw {
    let [expr, new_tokens] = this.parser::call(tokens)
    exprs.push(expr)
    tokens = new_tokens
  }
  return [expr::merge({[this.kw]: exprs}) tokens]
}

fn parse_step(result) = this[ParseInstruction](result)

fn ParseMap(entries) { this.entries = entries }

define Record for ParseMap = fn(entries) = new ParseMap(entries)

let parse_expr = null

fn Parser(instructions) { this.instructions = instructions }

define Vector for Parser = fn(instructions) = new Parser(instructions)

impl Call for Parser = fn(tokens) {
  let result = [null tokens]
  for instruction of this.instructions {
    result = instruction::parse(result)
  }
  return result
}
