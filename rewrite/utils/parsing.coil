fn from(val, tokens) = [val, tokens]
fn nothing(tokens) = from(null tokens)

export fn ParseMap(entries) { this.entries = entries }

protocol Matches

fn matches?(tokens) = this[Matches](tokens)

impl Matches for Keyword = fn(token, ...rest) =
  token == this

impl Matches for Array = fn(tokens) =
  this::zip(tokens.slice(0, this.length))
      // we could do p::matches?(t) but that seems
      // more powerful than we need, and likely
      // tough to debug.
      ::every?(fn(p, t) = p == t)

impl Matches for Set = fn(token ...rest) = this::has?(token)

impl Call for ParseMap = fn(tokens) =
  this.entries
    ::find(fn(pattern, _f) = pattern::matches?(tokens))
    ::call(tokens)

fn then(then_fn, keyword, [expr tokens]) {
  let [new_expr, new_tokens] = then_fn(tokens)
  return from(expr::merge({[keyword]: new_expr}) tokens)
}

// this is generally a code-smell
fn fmap(map_fn [expr tokens]) = from(map_fn(expr), tokens)

fn peek_type(tokens) = tokens::first()::pipe(:type)

protocol ManyCaseUntil

fn many_case_until(end_token_type, parse_map, [_ tokens]) {
  let exprs = []
  while tokens::peek_type() != end_token_type {
    if let [expr tokens_] = parse_map::call(tokens) {
      exprs.push(expr)
      tokens = tokens_
    } else {
      return from(expr tokens)
    }
  }
  return from(expr tokens)
}

fn many_case_until_store(end_token_type, parse_map, kw, [expr tokens]) {
  let [exprs tokens_] many_case_until(end_token_type parse_map [null tokens])
  return from(expr::merge({[kw]: exprs}) tokens_)
}


fn many_case(parse_map, [expr tokens]) =
  many_case_until(null parse_map [expr tokens])

fn many_case_store(parse_map, kw, [expr tokens]) =
  many_case_until_store(null parse_map kw [expr tokens])

fn until(end_token_type, parse_fn, kw, [_ tokens]) {
  let exprs = []  
  while tokens::peek_type() != end_token_type {
    let [expr tokens_] = parse_fn(tokens)
    exprs.push(expr)
    tokens = tokens_
  }
  return from(exprs tokens)
}

fn until_store(end_token_type, parse_fn, kw, [prev_expr tokens]) {
  let [exprs new_tokens] = until(end_token_type parse_fn [null tokens])
  return from(prev_expr::merge({[kw]: exprs}) new_tokens)
}

fn one(token_type, kw, [expr tokens]) {
  assert! !tokens::empty?() "Expected " + token_type + ", but reached end of file"
  let [token ...rest] = tokens
  assert! token == token_type "Expected " token_type + ", got " token::at(:type)
  expr = expr::merge({[kw]: token::at(:value)})
  return from(expr rest)
}

fn skip(token_type [expr tokens]) {
  let [_ new_tokens] = one(token_type :unused [{} tokens])
  return from(expr new_tokens)
}

fn either(token_set, kw, [expr [token ...rest]]) {
  assert! token_set::has?(token)
  return from(expr rest)
}
