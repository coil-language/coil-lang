fn Lexer(entries) { this.entries = entries }

fn pass() {}
fn newline() {}

define Record for Lexer = fn(entries) = new Lexer(entries)

impl Call for Lexer = fn(str) {
  let tokens = []  
  let index = 0
  fn rest_of_string() = str.slice(index)

  fn scan() {
    let result = rest_of_string().match(this)
    if !result || result.index != 0 { return false }
    index = index + result[0].length
    return result[0]
  }

  let line = 1
  let col = 1
  while rest_of_string() != "" {
    let found = false  
    for [pattern type] of this.entries {
      if let value = pattern::scan() {
        if type == newline {
          line = line + 1
          col = 1
          found = true
          break
        }
        if type != pass {
          tokens.push({type, value, line, col})
          col = col + value::len()
          found = true
          break
        }
      }
    }
    assert! found
  }

  return tokens
}

// this is tested & legit
let lexer = ~Lexer{
  /\n/ => newline
  /\s+/ => pass
  /\/\/.*/ => pass
  /,/ => pass
  /^\~/ => :tilde
  /^if\b/ => :if
  /^is\b/ => :is
  /^unless\b/ => :unless
  /^else\b/ => :else
  /^return\b/ => :return
  /^let\b/ => :let
  /^protocol\b/ => :protocol
  /^for\b/ => :for
  /^try\b/ => :try
  /^catch\b/ => :catch
  /^finally\b/ => :finally
  /^while\b/ => :while
  /^continue\b/ => :continue
  /^break\b/ => :break
  /^of\b/ => :of
  /^impl\b/ => :impl
  /^define\b/ => :define
  /^yield\b/ => :yield
  /^async\b/ => :async
  /^await\b/ => :await
  /^assert\b/ => :assert
  /^new\b/ => :new
  /^keyof\b/ => :keyof
  /^\=\>/ => :arrow
  /^\@/ => :at
  /^\&\&/ => :and_and
  /^\|\|/ => :or_or
  /^\=\=\=/ => :triple_eq
  /^\!\=\=/ => :triple_not_eq
  /^\=\=/ => :double_eq
  /^\!\=/ => :not_eq
  /^\!/ => :bang
  /^\=/ => :eq
  /^fn\b/ => :fn
  /^\{/ => :open_b
  /^\}/ => :close_b
  /^\(/ => :open_p
  /^\)/ => :close_p
  /^[\-\+]?\d+n/ => :big_int
  /^[\-\+]?(\d*\.)?\d+/ => :num
  /^\.\.\./ => :dot_dot_dot
  /^\.\./ => :dot_dot
  /^\./ => :dot
  /^\/.*\// => :regex_lit
  /^\>\=/ => :gt_eq
  /^\<\=/ => :lt_eq
  /^\>/ => :gt
  /^\</ => :lt
  /^\+/ => :plus
  /^\%/ => :mod
  /^\-/ => :minus
  /^\*\*/ => :pow
  /^\*/ => :times
  /^\&/ => :single_and
  /^\:\:/ => :double_colon
  /^\:[a-zA-Z_\?\!\$0-9]+/ => :keyword
  /^\:/ => :colon
  /^\// => :div
  /^\[/ => :open_sq
  /^\]/ => :close_sq
  /^\"([^\\\"]|\\.)*\"/s => :string_lit
  /^[a-zA-Z_\?\!\$0-9]+/ => :id
}

fn str(...args) = args.join("")

fn ParseError(expected_token_type, actual_token) {
  this.stack = (new Error()).stack
  this.message = str(
    "Expected: " expected_token_type::printable()
    " got " actual_token::at(:type)::printable()
    " @ " actual_token::at(:line)::to_s() ":" actual_token::at(:col)::to_s()
  )
}
ParseError.prototype = new Error()

fn expect_token!(kw) {
  if this::first()::at(:type) != kw {
    raise(new ParseError(kw, this::first()))
  } else {
    return this
  }
}

fn verify_exists!(parser) {
  if this::nil?() {
    raise(new Error("Parser Failed - " + parser::printable()))
  } else {
    return this
  }
}

protocol ParseInstruction

fn Init(expr) { this.expr = expr }
fn init(expr) = new Type(expr)
impl ParseInstruction for Type = fn([_expr, tokens]) =
  [this.expr tokens]

impl Printable for Type = fn() = "type(" + this.expr::printable() + ")"

fn One(kw, as) { this.kw = kw, this.as = as }
fn one(kw, as) = new One(kw, as)
impl ParseInstruction for One = fn([expr tokens]) {  
  let {value, type} = tokens::expect_token!(this.kw)::first()
  return [expr::merge({[this.as]: value}) tokens::skip(1)]
}
impl Printable for One = fn() = "one(kw: " + this.kw::printable() + ", as: " + this.as::printable() +  ")"

fn Optional(kw, parse_fn, as) {
  this.kw = kw
  this.parse_fn = parse_fn
  this.as = as
}
fn optional(kw, parse_fn, as) = new Optional(kw, parse_fn, as)
impl ParseInstruction for Optional = fn([expr tokens]) {  
  if tokens::first() && tokens::first()::at(:type) == kw {
    return then(this.parse_fn, this.as)::parse_step([expr tokens])
  } else {
    return [expr tokens]
  }
}
impl Printable for Optional = fn() = "optional(kw: " + this.kw::printable() + ", as: " + this.as::printable() +  ")"


fn Chomp(...kws) { this.kws = kws }
fn chomp(...kws) = new Chomp(...kws)
impl ParseInstruction for Chomp = fn([expr tokens]) {
  let i = 0
  for kw of this.kws {
    tokens::expect_token!(kw)
    i = i + 1
  }
  return [expr, tokens::skip(i)]
}
impl Printable for Chomp = fn() = "chomp(" + this.kws::printable().join(", ") + ")"


fn Then(parser, kw) {
  this.parser = parser
  this.kw = kw
}
fn then(parser, kw) = new Then(parser, kw)
impl ParseInstruction for Then = fn([expr tokens]) {
  let [new_expr new_tokens] = this.parser::call(tokens)::verify_exists!(this)
  return [expr::merge(new_expr) new_tokens]
}
impl Printable for Then = fn() = "then(" + this.kw::printable() + ")"

fn Until(end_kw, parser, kw) {
  this.end_kw = end_kw
  this.parser = parser
  this.kw = kw
}
fn until(end_kw, parser, kw) = new Until(end_kw, parser, kw)
impl ParseInstruction for Until = fn([expr tokens]) {
  let exprs = []  
  while tokens::first()::at(:type) != this.end_kw {
    let [expr new_tokens] = this.parser::call(tokens)
      ::verify_exists!(this)
    exprs.push(expr)
    tokens = new_tokens
  }
  if this.kw {
    return [expr::merge({[this.kw]: exprs}) tokens]
  } else {
    return [exprs, tokens]
  }
}
impl Printable for Until = fn() = "then(end:" + this.end_kw::printable() + ", as: " + this.kw::printable() + ")"

fn Case(parse_map, kw) {
  this.parse_map = parse_map
  this.kw = kw
}
fn case(parse_map, kw) = new Case(parse_map, kw)
impl ParseInstruction for Case = fn([expr tokens]) {
  let parse_fn = this.parse_map::call(tokens)::verify_exists!(this.parse_map)
  let [new_expr, new_tokens] = parse_fn::call(tokens)
  return [expr::merge({[this.kw]: new_expr}), new_tokens]
}
impl Printable for Until = fn() = "case(" + this.parse_map::printable() + ", as: " + this.kw::printable() + ")"

fn Either(set, kw) {
  this.set = set
  this.kw = kw
}
fn either(set, kw) = new Either(set, kw)
impl ParseInstruction for Either = fn([expr tokens]) {
  let op = this.set::at(tokens::first())::verify_exists!(this.set)
  let [{value}, rest] = [tokens::first(), tokens::skip(1)]
  return [expr::merge({[this.kw]: value}), rest]
}

fn parse_step(result) = this[ParseInstruction](result)

fn Parser(instructions) { this.instructions = instructions }

impl Printable for Parser = fn() = "~Parser[" + this.instructions::printable().join(", ") + "]"

define Vector for Parser = fn(instructions) = new Parser(instructions)

impl Call for Parser = fn(tokens) {
  if let result = this::parse_step([null tokens]) {
    return result
  } else {
    return this::log("This one failed")
  }
}

impl ParseInstruction for Parser = fn(result) {
  for instruction of this.instructions {
    result = instruction::parse_step(result)
  }
  return result
}

fn ParseMap(entries) { this.entries = entries }

define Record for ParseMap = fn(entries) = new ParseMap(entries)

impl Call for ParseMap = fn(tokens, ...args) {
  for [pattern parser] of this.entries {
    if pattern == _ {
      return parser::call(tokens, ...args)
    }
    if pattern == tokens::first()::at(:type) {
      return parser::call(tokens, ...args)
    }
    if pattern is Set && pattern::call(tokens::first()::at(:type)) {
      return parser::call(tokens, ...args)
    }
    if pattern is Array && pattern::every?(fn(p, i) = p == tokens::at(i)::at(:type)) {
      return parser::call(tokens, ...args)
    }
  }
}

let math_ops = #{:mod :plus :minus :times :pow :div}
let comparison_ops = #{:lt :gt :lt_eq :gt_eq}
let all_math_ops = math_ops::merg(comparison_ops)

fn parse_partial_obj_dyn_access(tokens) = ~Parser[
  init({type: :partial_obj_dyn_access})
  chomp(:open-sq)
  then(parse-expr :expr)
  chomp(:close-sq)
]::call(tokens)

fn parse_partial_fn_call(tokens) = ~Parser[
  init({type: :partial_fn_clal})
  chomp(:open_p)
  until(:close_p parse_expr :args)
  chomp(:close_p)
]::call(tokens)

fn parse_and_dot(tokens, lhs) = ~Parser[
  init({type: :and_dot, lhs})
  chomp(:single_and :dot)
  case(~ParseMap{
    :id => parse_id,
    :open_sq parse_partial_obj_dyn_access
    :open_p parse_partial_fn_clal
  } :rhs)
]::call(tokens)

fn parse_dot(tokens, lhs) = ~Parser[
  init({type: :property_lookup, lhs})
  chomp(:dot)
  one(:id :property)
]::call(tokens)

fn parse_infix_bind(tokens lhs) = ~Parser[
  init({type: :bind, lhs})
  chomp(:double_colon)
  case(~ParseMap{
    :id => parse_id
    :fn => parse_fn
    [:tilde :id :open_b] => parse_record_syntax
    all_math_ops => parse_unapplied_math_op
    :open_p => parse_paren_expr
  } :expr)
]::call(tokens)

fn parse_id(tokens, lhs) = ~Parser[
  init({type: :is, lhs})
  chomp(:is)
  then(parse_1_2_expr, :rhs)
]::call(tokens)

fn parse_snd_assign(tokens, lhs) = ~Parser[
  init({type: :snd_assign, lhs})
  chomp(:eq)
  then(parse_expr :rhs)
]::call(tokens)

fn parse_math_op(tokens lhs) = ~Parser[
  init({type: :math_op, lhs})
  either(math_ops :op)
  then(parse_1_2_expr :rhs)
]::call(tokens)

fn parse_snd_expr_step(tokens, lhs) = ParseMap{
  :single_and => parse_and_dot
  :dot => parse_dot
  :dot_dot => parse_inclusive_range
  :dot_dot_dot => parse_exclusive_range
  :open_p => parse_fn_call
  :double_colon => parse_infix_bind
  :open_sq => parse_object_dynamic_access
  :is => parse_is
  :eq => parse_snd_assign
  math_ops => parse_math_op
}::call(tokens, lhs)

fn parse_snd_expr([lhs tokens]) {  
  while true {
    if let [new_lhs rest] = parse_snd_expr(tokens, lhs) {
      lhs = new_lhs
      tokens = rest
    } else {
      return [lhs tokens]
    }
  }
}

fn parse_call_expr(tokens) = ~Parser[
  chomp(:open_p)
  until(:close_p parse_expr)
  chomp(:close_p)
]::call(tokens)

fn parse_decorator(tokens) = ~Parser[
  init({type: :decorator})
  chomp(:at)
  one(:id :name)
  optional(:open_p parse_call_expr :args)
  then(parse_fn :fn_def)
]::call(tokens)

let parse_regex = ~Parser[init({type: :regex_lit}) one(:regex_lit :value)]

let parse_str = ~Parser[init({type: :str}) one(:string_lit :value)]

let parse_id = ~Parser[init({type: :id_lookup}) one(:id :name)]

fn parse_reg_obj_entry(tokens) = ~Parser[
  init({type: :reg_obj_entry})
  either(#{:id :num} :key)
  chomp(:colon)
  then(parse_expr :value)
]::call(tokens)

let parse_obj_shorthand_entry = ~Parser[init({type: :obj_shorthand_entry) one(:id :id)]

fn parse_dynamic_obj_entry(tokens) = ~Parser[
  init({type: :dynamic_obj_entry})
  chomp(:open_sq)
  then(parse_expr :key_expr)
  chomp(:close_sq :colon)
  then(parse_expr :value)
]::call(tokens)

fn parse_spread_obj_entry(tokens) = ~Parser[
  init({type: :spread_obj_entry})
  chomp(:dot_dot_dot)
  then(parse_expr :expr)
]::call(tokens)

fn parse_obj_entry(tokens) = ~ParseMap{
  :open_sq => parse_dynamic_obj_entry
  :dot_dot_dot => parse_spread_obj_entry
  :fn => parse_fn
  [:async :fn] => parse_fn
  [:id :colon] => parse_reg_obj_entry
  [:num :colon] => parse_reg_obj_entry
  :id parse_obj_shorthand_entry
}::call(tokens)

fn parse_obj(tokens) = ~Parser[
  init({type: :obj_lit})
  chomp(:open_b)
  until(:close_b parse_obj_entry :entries)
  chomp(:close_b)
]::call(tokens)

let parse_spread_assign = ~Parser[
  init({type: :spread_assign})
  chomp(:dot_dot_dot)
  one(:id :name)
]

let parse_assign_id = ~Parser[init({type: :id_assign}) one(:id :name)]

let parse_assign_array_entry = ~ParseMap{
  :id => parse_assign_id
  :dot_dot_dot => parse_spread_assign
}

let parse_assign_array = ~Parser[
  init({type: :array_deconstruction})
  chomp(:open_sq)
  until(:close_sq parse_assign_array_entry :entries)
  chomp(:close_sq)
]

let parse_obj_entry_rename = ~Parser[
  init({type: :obj_entry_rename})
  one(:id :old_name)
  chomp(:colon)
  one(:id :new_name)
]

let parse_regular_obj_assign_entry = ~Parser[
  init({type: :obj_reg_entry})
  one(:id :name)
]

let parse_obj_assign_entry = ~ParseMap{
  [:id :colon] => parse_obj_entry_rename
  :id => parse_regular_obj_assign_entry
  :dot_dot_dot => parse_spread_assign
}

let parse_assign_obj = ~Parser[
  init({type: :object_deconstruction})
  chomp(:open_b)
  until(:close_b parse_obj_assign_entry :entries)
  chomp(:close_b)
]

let parse_assign_expr = ~ParseMap{
  :id => parse_assign_id
  :open_sq => parse_assign_array
  :open_b => parse_assign_obj
  :dot_dot_dot => parse_spread_assign
}

let parse_keyword = ~Parser[init({type: :keyword}) one(:keyword :value)]

fn parse_paren_expr(tokens) = ~Parser[
  chomp(:open_p)
  parse_expr
  chomp(:close_p)
]::call(tokens)

fn parse_yield(tokens) = ~Parser[
  init({type: :yield})
  chomp(:yield)
  parse_expr
]::call(tokens)

fn parse_await(tokens) = ~Parser[
  init({type: :await})
  chomp(:await)
  parse_expr
]::call(tokens)

let parse_num = ~Parser[init({type: :num}) one(:num :value)]

let parse_big_int = ~Parser[init({type: :big_int}) one(:num :value)]

fn parse_array(tokens) = ~Parser[
  init({type: :array})
  chomp(:open_sq)
  until(:close_sq parse_expr :elements)
  chomp(:close_sq)
]::call(tokens)

fn parse_spread(tokens) = ~Parser[
  init({type: :spread})
  chomp(:dot_dot_dot)
  then(parse_expr :expr)
]::call(tokens)

let parse_unapplied_math_op = ~Parser[
  init({type: :unapplied_math_op})
  either(all_math_ops :op)
]

fn parse_bind_this(tokens) = ~Parser[
  init({type: :bind_this})
  chomp(:double_colon)
  case(~ParseMap{
    :id => parse_id
    :fn => parse_fn
    all_math_ops => parse_unapplied_math_op
    :open_p parse_paren_expr
  } :expr)
]::call(tokens)

fn parse_not(tokens) = ~Parser[
  init({type: :not})
  chomp(:bang)
  then(parse_1_2_expr :expr)
]::call(tokens)

fn parse_not(tokens) = ~Parser[
  init({type: :new})
  chomp(:new)
  then(parse_1_2_expr :expr)
]::call(tokens)

fn parse_num_raw(tokens) =
  parse_num(tokens)::pipe(fn([expr, tokens]) = [expr::at(:value)::to_i(), tokens])

let parse_anon_arg_id = ~Parser[
  init({type: :anon_arg_id})
  chomp(:single_and)
  optional(:num parse_num_raw :arg_num)
]

let parse_unapplied_and_and = ~Parser[
  init({type: :unapplied_and_and})
  chomp(:and_and)
]

let parse_unapplied_and_and = ~Parser[
  init({type: :unapplied_or_or})
  chomp(:or_or)
]

fn parse_shorthand_anon_fn(tokens) = ~Parser[
  init({type: :shorthand_anon_fn})
  chomp(:hash :open_p)
  then(parse_expr :expr)
  chomp(:close_p)
]

let parse_async_modifier = ~Parser[init(true) chomp(:async)]
let parse_gen_modifier = ~Parser[init(true) chomp(:times)]

fn parse_fn_expr_body(tokens) = ~Parser[
  init({type: :return})
  chomp(:eq)
  then(parse_expr :expr)
]::call(tokens)

fn parse_args_def(tokens) = ~Parser[
  chomp(:open_p)
  until(:close_p parse_assign_expr)
  chomp(:close_p)
]::call(tokens)

fn parse_fn_name(tokens) = parse_id(tokens)::pipe(fn([expr, tokens]) = [expr::at(:name) tokens])

fn parse_fn(tokens) = ~Parser[
  init({type: :fn})
  optional(:async parse_async_modifier :async?)
  chomp(:fn)
  optional(:times parse_gen_modifier :generator?)
  optional(:id parse_fn_name :name)
  optional(:open_p parse_args_def :args)
  case(~ParseMap{
    :eq => parse_fn_expr_body,
    :open_b => unnamed_block
  } :body)
]::call(tokens)

fn parse_keyword_record_entry(tokens) = ~Parser[
  init({type: :keyword_record_entry})
  one(:id :name)
  chomp(:colon)
  then(parse_expr :expr)
]::call(tokens)

fn parse_regular_record_entry(tokens) = ~Parser[
  init({type: :regular_record_entry})
  then(parse_expr :key_expr)
  chomp(:arrow)
  then(parse_expr :value_expr)
]::call(tokens)

fn parse_record_entry(tokens) = ~ParseMap{
  [:id :colon] => parse_keyword_record_entry
  _ => parse_regular_record_entry
}::call(tokens)

fn parse_record_syntax(tokens) = ~Parser[
  init({type: :record_syntax})
  chomp(:tilde)
  one(:id :constructor_name)
  chomp(:open_b)
  until(:close_b parse_record_entry :entries)
  chomp(:close_b)
]::call(tokens)

fn parse_vector_syntax(tokens) = ~Parser[
  init({type: :vector_syntax})
  chomp(:tilde)
  one(:id :constructor_name)
  chomp(:open_sq)
  until(:close_sq parse_expr :entries)
  chomp(:close_sq)
]::call(tokens)

fn parse_single_expr(tokens) = ~ParseMap{
  :string_lit => parse_str
  :regex_lit => parse_regex
  :keyword => parse_keyword
  :open_p => parse_paren_expr
  :yield => parse_yield
  :await => parse_await
  :id => parse_id
  :at => parse_decorator
  :num => parse_num
  :big_int => parse_big_int
  :open_sq => parse_array
  :dot_dot_dot => parse_spread
  :double_colon => parse_bind_this
  :bang => parse_not
  :new parse_new
  :single_and parse_anon_arg_id
  :open_b => parse_obj
  :and_and => parse_unapplied_and_and
  :or_or => parse_unapplied_or_or
  all_math_ops => parse_unapplied_math_op
  [:hash :open-p] => parse_shorthand_anon_fn
  [:async :fn] parse_fn
  :fn parse_fn
  [:tilde :id :open_b] => parse_record_syntax
  [:tilde :id :open_sq] => parse_vector_syntax
}::call(tokens)

fn parse_1_2_expr(tokens) =
  parse_single_expr(tokens)
    ::pipe(parse_snd_expr)

fn parse_expr(tokens) =
  parse_single_expr(tokens)
    ::pipe(parse_snd_expr)
    // ::pipe(parse_third_expr)

fn parse_else_branch(tokens) = ~Parser[
  chomp(:else)
  unnamed_block
]

fn parse_if(tokens) = ~Parser[
  init({type: :if})
  chomp(:if)
  then(parse_expr :expr)
  block(:pass)
  optional(:else parse_else_branch :fail)
]::call(tokens)

fn parse_unless(tokens) = ~Parser[
  init({type: :unless})
  chomp(:unless)
  then(parse_expr :expr)
  block(:body)
]::call(tokens)

let parse_let = ~Parser[
  init({type: :let})
  chomp(:let)
  then(parse_assign_expr :assign_expr)
  chomp(:eq)
  then(parse_expr :rhs)
]

fn parse_if_let(tokens) = ~Parser[
  init({type: :if_let})
  chomp(:if :let)
  then(parse_assign_expr :assign_expr)
  chomp(:eq)
  then(parse_expr :expr)
  chomp(:open_b)
  until(:close_b parse_statement :pass)
  chomp(:close_b)
  optional(:else parse_else_branch :fail)
]::call(tokens)

let parse_impl = ~Parser[
  init({type: :impl_for})
  chomp(:impl)
  then(parse_expr :proto_expr)
  chomp(:for)
  one(:id :constructor)
  chomp(:eq)
  then(parse_expr :expr)
]

let parse_define = ~Parser[
  init({type: :define_for})
  chomp(:define)
  then(parse_expr :proto_expr)
  chomp(:for)
  then(parse_expr :src_expr)
  chomp(:eq)
  then(parse_expr :expr)
]

let parse_protocol = ~Parser[
  init({type: :protocol_def})
  chomp(:protocol)
  one(:id :name)
]

let parse_return = ~Parser[
  init({type: :return})
  chomp(:return)
  then(parse_expr :expr)
]

let parse_await_modifier = ~Parser[init(true) chomp(:await)]

fn parse_for_loop(tokens) = ~Parser[
  init({type: :for_loop})
  chomp(:for)
  optional(:await parse_await_modifier :await?)
  then(parse_assign_expr :assign_expr)
  chomp(:of)
  then(parse_expr :iterable_expr)
  block(:body)
]::call(tokens)

fn parse_assert(tokens) = ~Parser[
  init({type: :assert})
  chomp(:assert!)
  then(fn(tokens) = [tokens::first() tokens] :token)
  then(parse_expr :expr)
  optional(:string_lit parse_str :msg)
]::call(tokens)

fn parse_while_loop() = ~Parser[
  init({type: :while_loop})
  chomp(:while)
  then(parse_expr :test_expr)
  block(:body)
]::call(tokens)

fn parse_continue(tokens) = ~Parser[init({type: :continue}) chomp(:continue)]::call(tokens)

fn parse_break(tokens) = ~Parser[init({type: :break}) chomp(:break)]::call(tokens)

fn parse_catch(tokens) = ~Parser[
  init({type: :catch})
  chomp(:catch)
  one(:id :name)
  block(:body)
]::call(tokens)

fn parse_finally(tokens) = ~Parser[
  init({type: :finally})
  chomp(:finally)
  block(:body)
]::call(tokens)

fn parse_try(tokens) = ~Parser[
  init({type: :try})
  chomp(:try)
  block(:body)
  optional(:catch parse_catch :catch)
  optional(:finally parse_finally :finally)
]::call(tokens)

fn parse_statement(tokens) = ~ParseMap{
  :unless => parse_unless,
  :assert! => parse_assert,
  :impl => parse_impl
  :define => parse_define
  :try => parse_try
  :protocol => parse_protocol
  :let => parse_let
  :return => parse_return
  :for => parse_for_loop
  :while => parse_while_loop
  :continue => parse_continue
  :break => parse_break
  [:if :let] => parse_if_let
  :if => parse_if
  _ => parse_expr
}::call(tokens)

fn block(name) = ~Parser[
  chomp(:open_b)
  until(:close_b parse_statement name)
  chomp(:close_b)
]

fn unnamed_block(tokens) = block(:unused)::call(tokens)
  ::pipe(fn([expr tokens]) [expr::at(:unused) tokens])

fn parse(tokens) {
  let ast = []
  while tokens::len() != 0 {
    let [statement_or_expr, rest] = parse_statement::call(tokens)
    ast.push(statement_or_expr)
    tokens = rest
  }
  return ast
}

let tokens = lexer::call("try {
  protocol Name
  impl Name for Array = {}
}")

let ast = parse(new CollectionView(tokens, 0))
  ::log("parse")
