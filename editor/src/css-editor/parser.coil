import "./dist/prelude.js"

fn One(@token) {}
fn Skip(@token) {}
fn Not?(@token) {}
fn Until(@token) {}

protocol Scan

impl Scan for String = fn (str) {
  if str.startsWith(this) {
    return this
  } else {
    return false
  }
}

impl Scan for Until = fn (str) {
  let idx = 0
  let out = ""
  while str.at(idx) && !this.token.[Scan](str.slice(idx)) {
    out += str.[idx]
    idx += 1
  }
  return out
}

impl Scan for Not? = fn (str) {
  if str.at(0) != this.token {
    return str.at(0)
  } else {
    return false
  }
}

impl Scan for Skip = fn (str) {
  if str.startsWith(this.token) {
    return this.token
  } else {
    raise!("unknown skip")
  }
}

fn run(parser) {
  let [str idx gen result] = [this 0 parser() null]
  fn rest-of-string = str.slice(idx)
  let gen_state = gen.next(result)
  while !gen_state.done {
    result = gen_state.value.[Scan](str.slice(idx))
    if result { idx += result::len() }
    gen_state = gen.next(result)
  }
  return gen_state.value
}

fn* parse_rule {
  let name = yield Until["{"]
  yield Skip["{"]
  let rules = []
  while yield Not?["}"] {
    let name = yield Until[":"]
    yield Skip[":"]
    let value = yield Until[";"]
    yield Skip[";"]
    rules.push({type: :rule, name, value})
  }
  return {type: :block, name, rules}
}


"h1 { display: none;}"::run(parse_rule) |> log